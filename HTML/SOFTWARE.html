Operating systems


This page contains references to the following operating system documentations:

MSX-Basic

MSX-DOS

CP/M

UZIX

HALNOTE

MSXView





MSX-Basic


MSX

MSX 2

MSX 2+

MSX Turbo-R

Add-On's



Operators

Variables





MSX (MSX-Basic 1)




ABS

AND

AS #

ASC

ATN

AUTO

BASE

BEEP

BIN$

BLOAD

BSAVE

CALL

CDBL

CHR$

CINT

CIRCLE

CLEAR

CLOAD

CLOAD?

CLOSE #

CLS

COLOR

CONT

COS

CSAVE

CSNG

CSRLIN

DATA

DEF FN

DEFDBL

DEFINT

DEFSNG

DEFSTR

DEFUSR

DELETE

DIM

DRAW

END

EOF

ERASE

ERR

ERL

ERROR

EQV

EXP

FIX

FOR TO STEP

FRE

GOSUB

GOTO

HEX$

IF THEN ELSE

INKEY$

IMP

INP

INPUT

INPUT$

INSTR

INT

INTERVAL ON/OFF/STOP

KEY

KEY LIST

KEY ON/OFF

KEY ON/OFF/STOP

FOR TO STEP NEXT

LEFT$

LEN

LET

LINE

LINE INPUT

LIST

LLIST

LOAD

LOCATE

LOG

LPOS

LPRINT

MAXFILES

MERGE

MID$

MOD

MOTOR

NEW

NOT

OCT$

ON ERROR GOTO

ON GOSUB

ON GOTO

ON INTERVAL GOSUB

ON KEY GOSUB

ON SPRITE GOSUB

ON STOP GOSUB

ON STRIG GOSUB

OPEN

OR

OUT

PAD

PAINT

PDL

PEEK

PLAY

PLAY()

POINT

POKE

POS

PRESET

PRINT

PSET

PUT SPRITE

READ

REM

RENUM

RESTORE

RESUME

RETURN

RIGHT$

RND

RUN

SAVE

SCREEN

SGN

SIN

SOUND

SPACE$

SPC

SPRITE ON/OFF/STOP

SPRITE$

SQR

STICK

STOP

STOP ON/OFF/STOP

STRIG

STRIG ON/OFF/STOP

STR$

STRING$

SWAP

TAB

TAN

TIME

TROFF

TRON

USR

VAL

VARPTR

VDP

VPEEK

VPOKE

WAIT

WIDTH

XOR





MSX 2 (MSX-Basic 2)




COLOR SPRITE

COLOR SPRITE$

COLOR=

COLOR=RESTORE

COLOR=NEW

CALL MEMINI

CALL MKILL

CALL MNAME

CALL MFILES

SET PAGE

SET VIDEO

SET ADJUST

SET BEEP

SET TITLE

SET PASSWORD

SET PROMPT

SET SCREEN

SET DATE

SET TIME

GET DATE

GET TIME

See also: RAM-Disk in MSX-Basic 2





MSX 2+ (MSX-Basic 3)




SET SCROLL





MSX Turbo-R (MSX-Basic 4)




CALL PAUSE

CALL PCMPLAY

CALL PCMREC



BLOAD, BSAVE, LOAD, MERGE, OPEN, RUN, SAVE do no longer support the "CAS:" device

CLOAD, CSAVE, MOTOR are no longer supported and will generate a "syntax error"





Add-On's:





Disk

MSX-Audio

MSX-Music

RS232

Kanji

Hangul

Arabic

Reserved keywords

Turbo-Basic compiler





MSX-DOS





MSX-DOS, Version 1.11


MSX-DOS 1.x is fully located on the appropiate floppy-disks. It's system files are MSXDOS.SYS and COMMAND.COM



DIR

COPY

TYPE

REN

DEL

DATE

TIME

RENAME

ERA

ERASE

PAUSE

REM

VERIFY

MODE

BASIC

FORMAT





MSX-DOS, Version 2.20


MSX-DOS 2.x is located on the appropiate floppy-disks. It's system files MSXDOS2.SYS and COMMAND2.COM are only recognized and loaded if the corresponding MSXDOS2x.ROM is also present in any cartridge-slot of the MSX-computer (which must be MSX2 or higher).



ECHO





HELP





PATH





PROMPT





PARAMETERS





PROGRAM





TEMP





UPPER





REDIR





CD





RD





MD





CLS





DEL

DIR

ERA

REN

REM

SET





VER





VOL





COPY

DATE

ECHO





EXIT





HELP





MODE

MOVE





PATH





TIME

TYPE

ATDIRR





BASIC

CHDIR





ERASE

MKDIR





MVDIR





PAUSE

RMDIR





RNDIR





ASSIGN





ATTRIB





CONCAT





FORMAT

VERIFY

RENAME

BUFFERS





RAMDISK



See also:

MSX-DOS keys,

RAM-Disk in MSX-DOS 2





CP/M


The CP/M operating system is optional (in most cases extra sold).

1976: Gary Kildall developed CP/M, an operating system for personal computers. Widely adopted, CP/M made it possible for one version of a program to run on a variety of computers built around eight-bit microprocessors.





Internal commands:




DIR filespec displays filenames from disk-device

ERA filespec

deletes file(s)

PIP newname=oldname

renames file(s)

SAVE size filename

Copies memory-contents starting from 0100H (256*size bytes) into filename TYPE filename

displays file-contents on the screen

USER number

changes the user-area on disk





External commands:




ASM filename

8080 assembler

DDT filename

debugger/editor for machine-code programs

ED filename

text-editor

FORMAT

formats a disk

MOVCPM

configures CP/M for a different memory-size. Is not used by normal users and therefore not delivered in many cases.

PIP targetfile=sourcefile

copies file(s)

STAT filespec

STAT options

display directory-contents including filesize and attributes, sets and resets file-attributes, changes and displays Iobytes

SUBMIT filename parameter

starts a batch-file

SYSGEN

copies the bootstrap-loader and operating-system onto another disk XSUB

help-program for batch-processing





UNIX implementation for MSX





UZIX


The UZIX operating system is optional (available as freeware, can be downloaded from http://uzix.sourceforge.net/).



Introduction

Technical information

General:

(1) Unix requires a user to be logged on. You cannot perform any action without authorization. Unix-security supports several access-levels, assigned to different users. The default-administrator is "root".

(2) Unix works case-sensitive, so you can execute dir to display the contents of a directory - but not DIR or Dir!

(3) Unix separates directory-names within a path by a slash ('/'), not a backslash ('\') as in several other operating systems.

Command overview:

Attention!

These are not all the UZIX (or UNIX) commands. These are just some of the thousand of utilities for UNIX systems, but they are the basis for operating any UNIX system.

adduser

Adds a specified user, called username, to the system.

alias

Usage: alias [name [command]]

Define an alias for a command.

basename

Usage: basename filename

Show the filename (without path) on screen.

cat

Usage: cat filename ...

Type out the contents of the specified filenames.

cd

Usage: cd [dirname]

If dirname is provided, then the current directory is changed to the dirname. If dirname is absent, change to the user home directory.

chmod

Usage: chmod asciimode|octalmode file(s) asciimode: the mode to set, use [ugoa][-+][rwx] to: apply to (u)ser, (g)roup, (o)ther or (a)ll [default: u]

remove(-) or set(+) bits [required], apply to the (r)ead, (w)rite, e(x)ec bits octalmode: mode as an octal number file(s): the files to process chown

Usage: chown uid filename ...

Change the owner id for the specified list of files. The uid can either be a user name, or a decimal value.

chgrp

Usage: chgrp gid filename ...

Change the group id for the specified list of files. The gid can either be a group name, or a decimal value.

chroot

Usage: chroot dir

Change root directory for a command.

clear

Clear the screen.

cmp

Usage: cmp file1 file2

Compares two files.

cp

Usage: cp srcname ... dstname

Copies file(s).

df

Usage: df [-ik]

Show disk usage.

dir

Lists directory-contents. See also: ls dirname

Usage: dirname filename

Show the directory (without filename) on screen.

echo

Usage: echo [-ne] string ...

Print string on screen.

ed

Usage: ed [filename]

Edit the specified file using line-mode commands. The following ed commands are provided: = c r w i a d p l s f k z and q. Line numbers can be constants, ".", "$", "'x", /string/ and simple arithmetic combinations of these. The substitute command and the search expression can only use literal strings. There are some small differences in the way that some commands behave.

exec

Usage: exec filename [args]

Execute a program.

exit

Closes the open shell. See also: quit false

Return 'false' indication. Used by script files.

fld

Usage: fld -u -z* -[b t s? i? fm1.n1,m2.n2] {infiles} [> outfile]

Read and concatenate fields from a file.

grep

Usage: grep [-in] word filename ....

Display lines of the specified files which contain the given word. If only one filename is given, then only the matching lines are printed. If multiple filenames are given, then the filenames are printed along with the matching lines. Word must be a single word, (ie, not a regular expression). If -i is given, then case is ignored when doing the search. If -n is given, then the line numbers of the matching lines are also printed.

init

The first process executed by UZIX when booted. Not used by the user.

kill

Usage: kill [-sig] pid ...

Sends the specified signal to the specified list of processes. Signal is a numberic value, or one of the special values HUP, INT, QUIT, or KILL.

ln

Usage: ln [-s] srcname ... destname Links one or more files from the srcname to the specified destname. -s option creates soft links.

login

Usage: login [userid]

Logs on a user.

logout

Logs off an user.

ls

Usage: ls [-dilfaouR] [pattern]

Lists directory-contents. See also: dir mkdir

Usage: mkdir [-p] dirname ...

Create a directory.

mknod

Usage: mknod [-m mode] name [b|c|u major minor]

Creates a FIFO, character special device, or block special file with the given name.

more

Usage: more filename ...

Type out the contents of the specified filenames, one page at a time.

mount

Usage: mount [-r] devname dirname Mount a filesystem on a directory name.

mv

Usage: mv srcname ... destname Move or rename file(s).

passwd

Usage: passwd [name]

Changes a user's password.

prompt

Usage: prompt string

Changes the shell prompt.

ps

Usage: ps [-][lusmXacwhrn]

Lists state(s) of running processes pwd

Print name of current/working directory quit

Closes the open shell. See also: exit reboot

Shutdown and reboot system.

rm

Usage: rm filename ...

Remove file(s).

rmdir

Usage: rmdir directory ...

Removes one or more directories.

setenv

Usage: setenv [name [value]]

Display, set or clear environment-variables sh

Starts a new shell.

sync

Do a "sync" system call to force dirty blocks out to the disk.

tar

Usage: tar [xtv]f devname filename ...

List or restore files from a tar archive.

tee

Usage: tee filename

Replicate the standard input to standard output and to a file.

touch

Usage: touch [-c] [-m] [-d time] filename ...

Updates the modify times of the specifed files.

top

Usage: top [-d delay][-q][-s][-i]

Interactively display CPU processes.

tr

Usage: tr FROM TO [+START] [-END] [filein [fileout]]

START - starting position for transliteration END - ending position for transliteration:a is the same as a-zA-Z

len(FROM) == len(TO):

chars in TO are substitutes for chars in FROM

len(TO) == 0:

any chars in FROM are deleted

len(TO) < len(FROM):

all chars in FROM beyond the last one to match up with one in TO translate into the last char in TO; BUT any stream of consecutive characters so translated is reduced to just one occurence of the resulting char.

Escapes: \r \n \t \f \b \s \ddd Ranges: a-e is the same as abcde (e-a is empty range) Classes:

:z empty range

:a is the same as a-zA-Z

:l is the same as a-z

:u is the same as A-Z

:m is the same as á-´

:b is the same as Ç-ƒ

:r is the same as á-´Ç-ƒ

:d is the same as 0-9

:n is the same as a-zA-Z0-9

:s is the range \001-\040

:. is the range including all ASCII other then \0

Negation: if the first character of FROM is '^', any characters not in FROM match. In this case, TO

must be null or only a single char Transliterate characters.

trace

Toggle on or off interrupt trace on shell.

true

Return 'true' indication. Used by script files.

umount

Usage: umount mountpoint

Mount a filesystem on a directory name.

unalias

Usage: unalias name

Remove the definition for the specified alias.

uname

Usage: uname [-snrvma]

Displays the name and information of the Unix-implementation and machine.

uniq

Usage: uniq [-cduzN.M+L] [-fields] [+letters] [file]

Remove duplicate lines from a sorted file.

wc

Usage: wc [-pwp] [filenames]

Print the number of bytes, words, and lines in files.

whoami

Displays the username of the currently logged on user.

yes

Usage: yes [string]

Outputs a infinite number of 'y' characters to confirm Y/N-choices.





HALNOTE


HALNOTE is optional General: HALNOTE is the successor of MSX-DOS 1.x. HALNOTE was developed by the ASCII Corporation and HAL Laboratory.

HALNOTE consists of a 1MByte ROM-cartridge and 1 or 2 floppy-disks. A MSX2 or higher is required to run HALNOTE.

There are a few existing copies of the HALNOTE-ROM in the internet, but the mapper seems to be very complex. Therefore there is currently no detailed information available.

See also:

MSXView





MSXView


MSXView is optional

General: MSXView is the successor of MSX-DOS 2 and HALNOTE. MSXView was developed by the ASCII Corporation and HAL Laboratory.

MSXView is part of the firmware-ROMs and comes with an additional floppy-disk. A MSX Turbo-R or higher is required to run MSXView.

MSXView is divided into multiple modules, such as ViewDRAW, ViewPAINT, ViewTED and PageBOOK.

Currently there is no detailed information about MSXView available.





See also: HALNOTE





Chakkari Copy


The Chakkari Copy is a separately sold cartridge. It's published by Epson and intended to print hardcopies of MSX1 modes (screen 0/40, 1, 2 and 3) by pressing the corresponding buttons on the cartridge.



MSX-Basic programs can use the following commands, provided by this cartridge:

CALL BPRINT

CALL PAUSE

CALL SCHANGE



Note: if the screen mode cannot be auto-detected Chakkari Copy must be started with pressed COPY button. In this case all screen-parameters for later capture can be entered manually.





Operators:


Syntax: <X|X$> <Operator> <Y|Y$> or <Operator> <X|X$>



Operators are used to make expressions (calculations). Underneath is a table with all operators known to MSX Basic, divided in the class sections arithmetical, bitwise, relational and adjudicational:





Class Operator Function Notes

Arithmetical +unary plus has no effect

-unary minus yields the negation of its numeric argument

+addition can be used on strings too

-subtraction

*multiplication

/division

\integer division

MODmodulo calculates the dividend of an integer division

^to the power of

Bitwise NOT logical complement NOT 1 = 0

NOT 0 = 1 one's complements (all bits are inverted)

AND logical conjunction 1 AND 1 = 1

1 AND 0 = 0

0 AND 1 = 0

0 AND 0 = 0 the bit is set if both bits are set

OR logical inclusive or 1 OR 1 = 1

1 OR 0 = 1

0 OR 1 = 1

0 OR 0 = 0 the bit is set if either one of the bits is set

XOR logical exclusive or 1 XOR 1 = 0

1 XOR 0 = 1

0 XOR 1 = 1

0 XOR 0 = 0 the bit is set if one bit is set and the other one isn't

EQV logical equivalence 1 EQV 1 = 1

1 EQV 0 = 0

0 EQV 1 = 0

0 EQV 0 = 1 the bit is set if both bits are equal

IMP logical implication 1 IMP 1 = 1

1 IMP 0 = 0

0 IMP 1 = 1

0 IMP 0 = 1 the bit is not set when the first bit being true implicates that the second bit is false, it is otherwise set

Relational (comparators) =equals to

<smaller than

>larger than

<> or ><not equals to (smaller or larger than)

<= or =<equals to or smaller than

>= or =>equals to or larger than

Adjudicational =assignment only used to assign values to variables





The associativity (reading distance) is always from left to right, with the exception of the unary operators. Priorities are as followed:





Operator(s) priority level

( )

^

*, /, and \

unary operators

MOD

+ and -

relational operators

bitwise operators





Parentheses: ( ) can be used to override any priority; they can be nested, eg. A=((1+2)*3)^2.





See also:

Variables,

AND, EQV, IMP, MOD, NOT, OR,

XOR





Variables:


Syntax to assign a value to a variable: [LET] <variable name> = <X|X$>

The LET command is optional, and it's commonly never used.



Variables can have names up to only 2 characters, excluding the variable type character, example: X11% and X12% will both be X1%. A variable name can contain letters and numbers, and must begin with a letter. Continue this chapter for examples.



Variable types

Variable conversion functions

Definitions (DEF <type>)

Arrays (DIM, ERASE)





Variable types:




MSX Basic knows 4 types of variables which can be seen in the table underneath. The variable type character is part of the variable name, Example: A$, A%, and A are 3 different variables. If the variable isn't defined manually, MSX Basic defines it to Double Precision.



The variable types below are ordered from simple to complex. With each more complex variable type, the size gets bigger and the calculation speed gets slower.



Type Notation Notes

Integer decimal: <n>%

binary: &B<n>

octal: &O<n>

hexadecimal: &H<n> (examples) - DEF INT can also be used to define this type. Value can range between -32768 and 32767, thus, this is a signed 16-bit value where the msb (most significant bit) determines if the value is negative (1), or positive (0). There is no -0; '-0'=-32768.

Single Precision normal: <n>!

exponential: <mantissa>E <exponent> (examples) - DEF SNG can also be used to define this type. This type can hold up to 6 numbers, if it exceeds that, zeroes are appended.

Double Precision normal: <n>#

exponential: <mantissa>D <exponent> (examples) - DEF DBL can also be used to define this type. This type can hold up to 14 numbers.

String <n>$ (examples) - DEF STR can also be used to define this type. A String can be up to 255 characters long, dependent on the free string memory assigned with CLEAR.



<n> is a value (excluding the String type), or a variable name.



def int

def sng

def dbl

def str

f87f 99

dim

let



cint

cdbl

bin$

csng

hex$

oct$

str$

val



time





Variable conversion functions:




CINT,

CSNG,

CDBL,

ASC

MKI$,

MKS$,

MKD$,

CHR$





DEF <type: INT|DBL|SNG|STR> <letter>[,-<last letter>] [<letter 2> [,-<last letter 2>]]




DEFINT,

DEFSNG,

DEFDBL,

DEFSTR





DIM|ERASE <array name>(<maximum index>)[,<array name>...]




DIM,

ERASE





ABS


(MSX-Basic)

Syntax: ABS(<number>)

Function:

Generates the absolute-value (unsigned) of the specified number.

Example:



PRINT ABS(-10) 10 Ok

See also:

SGN





AND


(MSX-Basic)

Syntax: <number1> AND <number2>

Function:

Performs a bitwise AND-operation:

0 AND 0 = 0

0 AND 1 = 0

1 AND 0 = 0

1 AND 1 = 1

The AND-operation is often used to "mask" one or more bits.

Example:



PRINT 15 AND 11 1111B 11 1011B AND Ok ----- 1011B PRINT 6 AND 13 0110B 4 1101B AND Ok ----- 0100B

See also:

EQV, IMP, MOD, NOT, OR, XOR, MSX-Basic operators





OPEN "CAS:TEST" FOR OUTPUT AS #1

PRINT #1,X

OPEN "CAS:TEST" FOR INPUT AS #2

INPUT #2,X

10 SCREEN 2:COLOR 15,4,7

20 OPEN "GRP:" FOR OUTPUT AS #1

30 LINE (32,32)-(120,120),6,B

40 CIRCLE (120,120),56,1

50 PRESET (40,8)

60 PRINT #1,"Text in graphic screen"

70 FOR I=1 TO 2000: NEXT I





80 END


RUN


See also:

CLOSE, INPUT#, PRINT#, EOF, LOC, LOF, MAXFILES, RAM-Disk in MSX-Basic 2





ASC


(MSX-Basic)

Syntax: ASC(<string>)

Function:

Returns the ASCII-code of the 1st character in string.

Example:



PRINT ASC("EMIL") 69 Ok

See also:

CHR$





ATN


(MSX-Basic)

Syntax: ATN(<number>)



Function:

Returns the arc-tangent of the specified number in radians.

Example:



PRINT ATN(100) 1.5607966601082 Ok

See also:

COS, SIN, TAN





AUTO


(MSX-Basic) Syntax: AUTO [<linenumber>[,<increment>]]

Function:

Generates and increments line-numbers automatically.

Example:



AUTO 100,20

The line-numbering begins at 100 and is subsequently incremented by 20. You can stop this operation mode by pressing Ctr+C.

A '*' (asterisk) character indicates that the linenumber is already in use. I.e. if

120*

is displayed, this line already exists in the program. See also:

RENUM





PRINT BASE(2)





2048


Ok


See also:

VDP





BEEP


(MSX-Basic)

Syntax: BEEP

Function:

Generates a short beep. On MSX1-computers this is 800Hz, 0.25s. PRINT CHR$(7) also generates a BEEP.

Example:



BEEP

See also:

PLAY, SET BEEP





BIN$


(MSX-Basic)

Syntax: BIN$(<number>)

Function:

Returns a string which contains the binary representation of number.

Example:



PRINT BIN$(100) 1100100 Ok

See also:

HEX$, OCT$, STR$, VAL





BLOAD


(MSX-Basic, Disk-Basic)

Syntax: BLOAD "<name>"[,R[,<offset>]]

BLOAD "<name>"[,S]

Function:

Binary LOAD:

The binary file (often a assembly language program) name will be loaded at the beginaddress that was specified during BSAVE. If the option ',R' is added, the program will be started automatically. If there was no startadress specified for BSAVE, the program begins it's execution on beginadress.

If an offset is specified the program will be loaded at beginaddres+offset.

If 'S' is specified this contents are loaded to VRAM from disk files. This can done in any screen mode, note, however, that only the active pages are valid when the screen mode is from 5 to 8. No cassette tapes can be used.

Turbo-R: the "CAS:" device is no longer supported!

Example:



BLOAD "TEST.BIN",R

See also:

LOAD, CLOAD, DEFUSR, SET PAGE, BSAVE





BSAVE


(MSX-Basic, Disk-Basic)

Syntax: BSAVE "<name>"[,<beginadress>,<endadress>[,<startadress>][,2]]

BSAVE "<name>"[,<beginadress>,<endadress>][,S]

Function:

Saves the memory-contents from beginadress to endadress with name on the device. If a startadress is specified the machine-code program will be started on this address if it is loaded using BLOAD with the ',R' option. When no startaddress is specified the beginaddress will be used as startaddess.

If the tape-device is used the ',2' option causes the recording speed to be set to 2400 baud in stead of the normal 1200 baud.

If 'S' is specified VRAM contents are saved to disk. This can be done for any screen mode, note, however, that only the active pages are valid when the screen mode is from 5 to 8. No cassette tapes can be used. Valid value range of address is from -32768 to -2, or from 0 to 65534 (&HFFFE). Turbo-R: the "CAS:" device is no longer supported!

Example:



BSAVE "TEST.BIN",&H9000,&H92FF

See also:

SAVE, CSAVE, SET PAGE, BLOAD





CALL


(MSX-Basic)

Syntax: CALL <extended statement name>[(<arguments>)]

_ <extended statement name>[(<arguments>)]

Function:

Executes a extended BASIC-command stored in an extension ROM. Instead of the keyword CALL you can also use a _ (underscore).

Examples:



CALL SYSTEM CALL KANJI CALL ANK CALL TURBO ON CALL TURBO OFF CALL PAUSE(100)

See also:





CDBL


(MSX-Basic)

Syntax: CDBL(<number>)

Function:

Converts number into a double-precision value.

Example:



See also:

CINT, CSNG





CHR$


(MSX-Basic)

Syntax: CHR$(<number>)

Function:

Returns the character with the ASCII-code number. number must be an integer between 0 and 255.

Example:



10 FOR I=0 TO 255 20 PRINT CHR$(I); 30 NEXT I

See also:

ASC





CINT


(MSX-Basic)

Syntax: CINT(<number>)

Function:

Converts number into an integer value between -32768 and 32767. Digits behind the decimal-point are ignored. In other BASIC-dialects the value is rounded up or down.

Example:



PRINT CINT(12.34) 12 Ok PRINT CINT(123.54) 123 Ok

See also:

CDBL, CSNG





CIRCLE


(MSX-Basic)

Syntax: CIRCLE [STEP](<x,y>),<radius> [,<color> [,<start>,<end> [,<proportion>]]]

Function:

This command draws an ellipse on the screen.

x, y are coordinates of the center,

radius is the radius of the biggest main-axis

These values must be specified. Optional arguments are the

color of the line (see color-table)

start and end of the line (multiple of PI) and

proportion the aspect-ratio* of the x- and y-axis



Examples:



10 SCREEN 2 20 CIRCLE(100,100),40,1 30 GOTO 30

Draws an ellipse in the center of the screen. With 20 CIRCLE(100,100),40,,,1.4

you'll draw a circle *note: On a real msx the results of "aspect-ratio" will be different depending on your screens refresh-frequency, this example assumes 50 Hz (PAL) but when in 60 Hz (NTSC) specifing no aspect-ratio will result in a circle.

See also:

DRAW, LINE, PSET, PAINT, SCREEN, CLS





CLEAR


(MSX-Basic)

Syntax: CLEAR [<stringsize> [,<adress>]]

Function:

This command clears the contents of all variables and all dimensions of arrays. The optional stringsize reserves additional memory on top of memory. Initially there are 200 Bytes reserved - for use in character-strings.

If adress is specified, this is the maximum address of BASIC-memory. This command can also be used if arrays must be dimensioned dynamically.

Example:



10 CLEAR 20 INPUT "N=";N 30 DIMA(N) 40 GOTO 10

See also:

ERASE, DIM, FRE, MAXFILES, DEF FN

Note: do not confuse with CLS





CLOAD


(MSX-Basic)

Syntax: CLOAD "<name>"

Function:

Cassette LOAD:



Loads a basic program from tape. If no name is specified the first available basic-program will be loaded.

Turbo-R: CLOAD is no longer supported and will generate a "syntax error"

Example:



CLOAD Found: TEST.BAS Ok

See also:

CSAVE, BLOAD, RUN





CLOAD?


(MSX-Basic)

Syntax: CLOAD? "<name>"

Function:

Compares a program on tape with the one in memory.

If the program in memory differs from the program on tape a "Verify error" will occur.

Turbo-R: CLOAD? is no longer supported and will generate a "syntax error"

Example:



CLOAD?

See also:

CSAVE





CLOSE


(MSX-Basic, Disk-Basic, RS232-Basic) Syntax: CLOSE [#][<filenumber>]

Function:

Closes a file, if no filenumber is specified all open files will be closed.

RS232: If the channel was opened in output mode, the EOF character is sent. Note that the file buffer allocated by BASIC following the FCB is not actually used.

Example:



10 MAXFILES=1 20 OPEN "TEST" FOR OUTPUT AS#1 30 A$="MSX" 40 PRINT #1,A$ 50 CLOSE #1 60 END

See also:

OPEN, EOF, LOC, LOF





CLS


(MSX-Basic)

Syntax: CLS

Function:

Clears the screen (as well in text as in graphics modes).

Example:

-

See also:

CALL CLS, PRINT, CIRCLE, DRAW, LINE, PSET, PAINT, SCREEN





COLOR


(MSX-Basic)

Syntax: COLOR [<foreground>][,<background>][,<border>]

Function:

COLOR modifies the color of the foreground (active drawing), background and border. Possible values and differences in various screen-modes can be found in the color-table.

Example:



1000 COLOR 15,1,1:SCREEN 2 1010 OPEN "GRP:" FOR OUTPUT AS #1 1020 PRESET (10,5) 1030 PRINT #1, "A WELL TUNED TV-SET" 1040 PRESET (10,15) 1050 PRINT #1, "SHOWS 15 COLORS AND BLACK" 1060 CLOSE #1 1070 FOR G=2 TO 15 1080 COLOR G 1090 LINE (G*16-15,30)-(G*16,184),,BF 1100 NEXT G 1110 GOTO 1110

See also:

COLOR SPRITE COLOR SPRITE$ COLOR=, COLOR=RESTORE, COLOR=NEW, DRAW, LINE, CIRCLE, PSET, PAINT





CONT


(MSX-Basic)

Syntax: CONT

Function:

CONT continues a program, which was halted with CTRL/STOP or the STOP or END instruction.

Example:



10 PRINT "Test line 1" 20 END 30 PRINT "Test line 2" RUN Test line 1 Ok CONT Test line 2 Ok

See also:

RUN, END, STOP





COS


(MSX-Basic)

Syntax:

COS(<number>)

Function: Calculates the cosine of the specified number.

Example:



PRINT COS(100) .86231887228917

See also:

ATN, SIN, TAN





CSAVE


(MSX-Basic) Syntax: CSAVE "<name>" [,2]

Function:

Cassette Save, stores a basic program on tape.

If the ',2' option is added the recording speed is set to 2400 baud in stead of the normal 1200 baud.

Turbo-R: CSAVE is no longer supported and will generate a "syntax error"

Example:



CSAVE "TEST",2

See also:

CLOAD?, CLOAD, SAVE, BSAVE





CSNG


(MSX-Basic)

Syntax: CSNG(<number>)

Function:

Converts number into a single-precision value.

Example:

-

See also:

CDBL, CINT





CSRLIN


(MSX-Basic)

Syntax: CSRLIN

Function:

Returns the current Y-position of the cursor.

Example:



LOCATE 0,5:PRINT CSRLIN 5 Ok

See also:

LOCATE, POS





DATA


(MSX-Basic) Syntax: DATA <value>[,<value2> [,...]]

Function:

With this instruction a set of elements can be added a program.

These elements can be either numbers or strings, they can be accessed one by one using the READ instruction and are always separated by comma's. Strings are also placed between quotation marks.

Example:



10 READ A$ 20 PRINT A$ 30 READ A,B 40 PRINT A 50 PRINT B 60 DATA "TEST",10,20

See also:

READ, RESTORE





DEF FN


(MSX-Basic)

Syntax: DEF FN <functionname>[(<arguments>)]=<function definition>

Function:

With this instruction one can create his own functions.

Example:



10 DEF FN TEST$(E)="And the character is: "+CHR$(E) 20 PRINT FN TEST$(65) RUN "And the character is: A"

See also:

CLEAR





DEFDBL


(MSX-Basic)

Syntax: DEFDBL <letter>[-<lastletter>] [<letter2> [,-<lastletter2>]]

Function:

Defines all variables starting with the specified letter(s) as double-precision variables.

Example:

DEF DBL A-E

See also:

DEFINT, DEFSNG, DEFSTR, CLEAR





DEFINT


(MSX-Basic)

Syntax: DEFINT <letter>[-<lastletter>] [<letter2> [,-<lastletter2>]]

Function:

Defines all variables starting with the specified letter(s) as integer variables.



Example:



DEF INT G

See also:

DEFDBL, DEFSNG, DEFSTR, CLEAR





DEFSNG


(MSX-Basic)

Syntax: DEFSNG <letter>[-<lastletter>] [<letter2> [,-<lastletter2>]]

Function:

Defines all variables starting with the specified letter(s) as single-precision variables.

Example:



DEF SGN A

See also:

DEFDBL, DEFINT, DEFSTR, CLEAR





DEFSTR


(MSX-Basic)

Syntax: DEFSTR <letter>[-<lastletter>] [<letter2> [,-<lastletter2>]]

Function:

Defines all variables starting with the specified letter(s) as string variables.

Example:



DEF STR A

See also:

DEFDBL, DEFINT, DEFSNG, CLEAR





DEFUSR


(MSX-Basic)

Syntax: DEFUSR[<number>] = <address>

Function:

Specifies the starting address of a machine-language program, the program can be executed by using the USR function. number can be 0-9, if no number is specified 0 is assumed.

Example:



DEF USR1=&H156:A=USR1(0)

See also:

USR, BLOAD, POKE, VARPTR





DELETE


(MSX-Basic)

Syntax: DELETE <line> [-<line2>]

Function:

Deletes program-lines, if this command is executed within a program the program will terminate after this command.

Example:



DELETE 10-40

See also:

MERGE, RENUM





DIM


(MSX-Basic)

Syntax: DIM <array-name>(<maximun index>)[,<array-name>...]

Function:

Reserves memory for the specified variables and intitializes the array.

If if an array is referred to when not first created with a DIM instruction, a maximum index of 10 is assumed. The first index is always 0.

Example:



10 DIM M(25) 20 FOR A=0 TO 25:M(A)=3*A:NEXT 30 FOR A=0 TO 25 40 PRINT "3 times ";A;" is ";M(A) 50 NEXT A

See also:

CLEAR





10 SCREEN 5


20 A$="C15BM50,50"

30 S=50

40 DRAW "XA$;D=B;R=B;U=B;L=B;"

50 A$=INPUT$(1)

See also:

CIRCLE, LINE, PSET, PAINT, SCREEN, CLS





END


(MSX-Basic)

Syntax: END

Function:

Terminates a programs execution. When the interpreter reaches the last line of the program, it is automaticly terminated, END is not necessary there. After END a CONT instruction can continue the program execution on the next line.

Example:



10 FOR A=1 TO 10 20 PRINT A 20 IF A=5 THEN END 30 NEXT

See also:

STOP, RUN, CONT





EOF


(MSX-Basic, RS232-Basic)

Syntax: EOF(<filenumber>)

Function:

EOF is zero while the end of the open file in not reached.

Example:



10 IF EOF(2) THEN CLOSE#2

See also:

OPEN, CLOSE, LOC, LOF





ERASE


(MSX-Basic)

Syntax: ERASE <array-name>[,<array-name>]

Function:

ERASE frees up the memory used by array's previously allocated by a DIM instruction.

Example:



10 DIM A(100),X$(60) ... 500 ERASE A,X$

See also:

CLEAR, DIM





ERR


(MSX-Basic, Disk-Basic)

Syntax: ERR

Function:

Returns the number of the last error that occurred. The error-number can be found in the error-table.

Example:



10 ON ERROR GOTO 50 20 A=25: PRINT A 30 B=A/0 40 END 50 PRINT "Error number ";ERR;" occured in line ";ERL 60 RESUME NEXT

See also:

ERL, ERROR, ON ERROR GOTO, RESUME





ERL


(MSX-Basic)

Syntax: ERL

Function:

Returns the line-number where the last error occured.

Example:

See ERR

See also:

ERR, ERROR, ON ERROR GOTO, RESUME





ERROR


(MSX-Basic, Disk-Basic)

Syntax: ERROR <number>

Function:

Displays the error-message that belongs to the error-number. The error-number can be found in the error-table.

Example:



ERROR 64 File still open Ok

See also:

ERR, ERL, ON ERROR GOTO, RESUME





EQV


(MSX-Basic)

Syntax: number1 EQV number2

Function:

Logical equivalence.

0 EQV 0 = 1

0 EQV 1 = 0

1 EQV 0 = 0

1 EQV 1 = 1

Example:



See also:

AND, IMP, MOD, NOT, OR, XOR, MSX-Basic operators





EXP


(MSX-Basic)

Syntax: EXP(<number>)

Function:

Calculates the power of e for number (base is e=2.718281884588).

number must be less or equal 145.06286058562.

Example:



PRINT EXP(10) 22026.4657948 Ok

See also:

LOG





FIX


(MSX-Basic)

Syntax: FIX(<number>)

Function:

Return the integer part of number. This function is identical to

SGN(<number>)*INT(ABS(<number>)).

The difference between "FIX" and "INT" is that negative values are not rounded to the next lower value.

Example:



PRINT FIX(1.7) 1 Ok

See also:

INT, SGN, ABS





FOR


(MSX-Basic)

Syntax: FOR <variable>=<number> TO <number2> [STEP <number3>]

NEXT [<variable> [,<variable2>][, ...]]]

Function:

This instruction forms a program loop that looks like:

FOR <variable>=X TO Y [STEP Z]

.

. Instructions

.

NEXT <variable>

The instructions between FOR and NEXT are executed with values from X to Y. If STEP Z is not specified a step-width of 1 is used. Within a loop another loop can be implemented, so loops can be nested.

Every loop will be executed at least once because the termination-condition is checked in the NEXT statement.

Example:



10 FOR I=1 TO 4 20 PRINT I; 30 NEXT:PRINT 40 FOR I=0 TO 5 STEP 5 50 FOR J=0 TO I+2 60 PRINT J 70 NEXT J,I:PRINT 80 END

See also:

CALL PAUSE





FRE


(MSX-Basic)

Syntax: FRE(number)

FRE(string)

Function:

FRE(number) returns the free memory available to Basic programs, where FRE(string) returns the free memory for strings.

Example:



NEW PRINT FRE(0) 28815 Ok PRINT FRE("") 200 Ok

See also:

CLEAR, ERASE, DIM, MAXFILES





GOSUB


(MSX-Basic) Syntax: GOSUB line

Function:

This statement jumps to a subroutine. The program can return from this routine by using the RETURN statement.

Example:



100 PRINT "Hello" 110 GOSUB 200 120 GOSUB 300 130 END 200 PRINT "Here am I" 210 RETURN 300 PRINT "End" 310 RETURN

Outputs the following text: Hello Here am I End See also:

RETURN, ON GOSUB, GOTO





GOTO


(MSX-Basic)

Syntax: GOTO line

GO TO line

Function:

Unconditional jump-statement. The program continues at the specified line.

Example:

-

See also:

ON GOTO, GOSUB





HEX$


(MSX-Basic)

Syntax: HEX$(number)

Function:

Converts the specified number into a hexadecimal value. A hexadecimal-number consists of digits 0 to 9 and the characters A to F.

Example:



PRINT HEX$(1023) 3FF Ok

See also:

BIN$, OCT$, STR$, VAL





IF


(MSX-Basic)

Syntax: IF expression THEN <StatementsA> [ELSE <StatementsB>]

Function:

If the condition is met StatementsA are executed. After this the program continues with the next program line.

If the condition is not met then StatementsB after the ELSE are executed. After this the program continues with the next program line too.

Example:



100 INPUT "A=";A 110 IF A>=0 THEN PRINT "positive" ELSE PRINT "negative" 120 INPUT "Again ( /N)";A$ 130 IF A$<>"N" GOTO 100 ELSE END

Is the condition A>=0 in line 110 met then "positive" is printed. As line 130 indicates the THEN can be replaced by GOTO. On the other hand the GOTO after THEN is not necessary. Line 130 can also look like: 130 IF A$<>"N" THEN 100 ELSE END

See also:

GOTO





INKEY$


(MSX-Basic) Syntax: INKEY$

Function:

The function INKEY$ scans the keyboard for a pushed key. The returned string is empty if no key is pressed or the ASCII character of the pressed key.

Example:



10 PRINT "Please press any key" 20 IF INKEY$="" THEN 20 30 PRINT "Continuing..."

If the key-input should result in a more detailed evaluation it should be stored in a string-variable. 10 PRINT "Please press any key" 20 A$=INKEY$:IF A$="" THEN 20 30 IF ASC(A$)=13 THEN 10

If ENTER/RETURN is pressed in line 20 the program restarts in line 10. See also:

INPUT$, STICK, STRIG





IMP


(MSX-Basic)

Syntax: number1 IMP number2

Function:

Logical implication.

0 IMP 0 = 1

0 IMP 1 = 1

1 IMP 0 = 0

1 IMP 1 = 1

Example:



See also:

AND, EQV, MOD, NOT, OR, XOR, MSX-Basic operators





INP


(MSX-Basic)

Syntax: INP(port)

Function:

Reads the content of the specified input-port (0-255).

The statement "OUT" can be used to write a byte to an output-port.

Example:



10 A=INP(&HA8) 20 A$="00000000"+BIN$(A) 30 PRINT RIGHT$(A$,8) 40 END RUN

See also:

OUT, WAIT





INPUT


(MSX-Basic, Disk-Basic)

Syntax: INPUT ["prompt";] variable [,variable2 [,...]]

INPUT#channel, variable [,variable2 [,...]]

Function:

Retrieves a number or string from the keyboard and assignes it to a variable. The input is finished with the Return/Enter key. A prompt can be printed before the input starts. A "?" sign is also printed to indicate the input.

The INPUT# statement reads data from a sequential file opened as #channel and assigns it to the listed variables.

Special: If a string already has a value and the new input is empty (only Return/Enter pushed) then the old value remains unchanged. In other Basic dialects the value will be cleared. This is also valid for the input of numbers (not only strings).

Example:



10 INPUT "Length of the page";L

See also:

LINE INPUT, GET, INPUT$, PRINT, OPEN, PRINT[#]





INPUT$


(MSX-Basic) Syntax: INPUT$(number [#channel]) Function:

This function reads number characters from the keyboard or a file opened as #channel.

The INPUT$ function can also recognize control-sequences, which cannot be entered using the INPUT statement. Therefore INPUT$ is useful for data-transfer from other machines. In such transmissions all characters might be important.

Example:



10 PRINT "C continues, E ends the program" 20 A$=INPUT$(1) 30 IF A$="E" THEN END 40 IF A$="C" THEN GOTO 60 50 GOTO 10 60 REM code continues here

See also:

INKEY$





INSTR


(MSX-Basic) Syntax: INSTR([position,] string, substring) Function:

This function looks for the 1st occurence of the substring in the specified string and returns the start-position. In addition a position (0-255) can be specified, which indicates where the search should start.

If the substring is not found, or position is larger as the length of the string or the string is empty then INSTR returns 0. If substring is empty INSTR returns 1.

Example:



10 A$="Merry Christmas" 20 PRINT INSTR(A$, "ist") 30 PRINT INSTR(A$, "IST") 40 PRINT INSTR(5, A$, "r") RUN 10 0 9

See also:

LEN, MID$





INT


(MSX-Basic)

Syntax: INT(<number>)

Function:

Returns the integer-part of <number>.

Example:



10 A=-2.7 20 PRINT INT(A) 30 A=2.7 40 PRINT INT(A) 50 END RUN -2 2 Ok

See also:

FIX, SGN, ABS





INTERVAL


(MSX-Basic) Syntax: INTERVAL ON

INTERVAL OFF

INTERVAL STOP

Function:

After "INTERVAL ON" the program checks if a specified time-interval has been elapsed. If so MSX-Basic calls the subroutine that was specified with the "ON INTERVAL GOSUB" statement. After the "INTERVAL OFF" statement no checking is performed. After "INTERVAL STOP" MSX-Basic still checks if the interval has been elapsed, but calls the subroutine only after the next call of "INTERVAL ON".

Example:

See: ON INTERVAL GOSUB

See also:

ON INTERVAL GOSUB





KEY


(MSX-Basic)

Syntax: KEY number, string

Function:

Associates the function key identified by number (1-10) with a string. The string can have up to a maximum of 15 characters.

Example:



10 A$="CLOAD" 20 KEY 1,A$+CHR$(13) 30 END

See also:

KEY LIST, KEY ON/OFF





KEY


(MSX-Basic)

Syntax: KEY LIST

Function:

Lists the assignment of the function-keys (F1-F10).

Example:



KEY LIST color auto goto list run color 15,4,4 cload" cont list.

See also:

KEY (assignment), KEY ON/OFF





KEY


(MSX-Basic)

Syntax: KEY ON

KEY OFF

Function:

"KEY ON" enables and "KEY OFF" disables the display of the function-key assignment in line 25 (only in textmodes 1 and 2).

Example:



KEY OFF

See also:

KEY (assignment), KEY LIST





KEY


(MSX-Basic) Syntax: KEY(number) ON

KEY(number) OFF

KEY(number) STOP

Function:

number specifies a function-key number (1-10).

After the "KEY(number) ON" statement MSX-Basic checks if the specified function-key was pressed. If so MSX-Basic calls the subroutine, that was defined by the "ON KEY GOSUB" statement.

After the statement "KEY(number) STOP" MSX-Basic checks if the specified function-key was pressed, but does not call the defined subroutine until the next invocation "KEY(number) ON".

Example:

See: ON KEY GOSUB

See also:

ON KEY GOSUB





LEFT$


(MSX-Basic) Syntax: LEFT$(string, number) Function:

Returns the first number (0-255) characters from the specified string. If number is larger than the string the whole string is returned. If number is 0 an empty string is returned.

Example:



10 A$="MSX-Computer" 20 FOR I=1 TO LEN(A$) 30 PRINT LEFT$(A$,I) 40 NEXT I RUN M MS MSX MSX- MSX-C MSX-Co MSX-Com MSX-Comp MSX-Compu MSX-Comput MSX-Compute MSX-Computer

See also:

MID$, RIGHT$





LEN


(MSX-Basic)

Syntax: LEN(string)

Function:

Returns the number of characters in the string.

Example:



PRINT LEN("BASIC") 5

See also:





LET


(MSX-Basic)

Syntax: [LET] variable=value

Function:

Assigns a value to the specified variable. The LET statement itself is optional and can be skipped.

Example:



LET A=10 LET B$="Hello" C=20 D$="World"

See also:

SWAP





LINE


(MSX-Basic)

Syntax: LINE[[STEP](x1,y1)]-[STEP](x2,y2)[,color [,B[F]]]

Function:

Draws a line from x1,y1 to x2,y2, which can be absolute or relative ("STEP" keyword) coordinates.

If the word "STEP" is used x1 and y1 are interpreted relative to the current cursor-position. In this case the values can also be negative.

x2 and y2 are the coordinates of the line-endpoint. If the word "STEP" is specified these are also relative to the cursor-position.

color is the line-color to be used for drawing (see color-table). If color is not specified the current foreground-color is used. If "B" is specified a rectangle is drawn, where the current line is used as diagonal.

If "F" after "B" is specified the rectangle is filled with the given color.

Example:



10 SCREEN 2 20 FOR I=0 TO 95 STEP 2 30 LINE (128-I,95-I)-(128+I,95+I),1,B 40 NEXT 50 FOR K=0 TO 2000:NEXT 60 END

See also:

CIRCLE, DRAW, PSET, PAINT, SCREEN, CLS





LINE INPUT


(MSX-Basic)

Syntax: LINE INPUT ["prompt";] stringvariable

LINE INPUT #channel, stringvariable

Function:

Retrieves a whole line, up to 254 characters, from the keyboard into the specified stringvariable. A given prompt (if any) is printed first.

The LINE INPUT# statement is used to read a complete record from a sequential file (opened as #channel), which must have been opened for "INPUT". The "LINE INPUT" statement is often used to read a MSX-Basic program as datafile, if it was saved (by using the "SAVE" statement) in ASCII format.

Example:



10 LINE INPUT "TEXT";A$ 20 PRINT A$ 30 END RUN TEXT Ok

See also:

INPUT, GET, PRINT, OPEN





LIST


(MSX-Basic) Syntax: LIST [[startline] [-[endline]]]

Function:

Lists a whole or part of the Basic-program from memory.

If only startline is given this line is listed only. If startline and endline are specified all lines within this range are listed. If only endline is given all lines from the beginning to this line are listed. If neither startline nor endline are given the whole program is listed. If startline and "-" are given then this line and all followings are listed.

Example:



LIST 10

Program line 10 is listed only. LIST 50-100

Program lines 50 to 100 are listed. LIST -100

All program lines from 0 to 100 are listed. LIST

All program lines are listed. LIST .

The last maintained line is listed. See also:

LLIST





LLIST


(MSX-Basic)

Syntax: LLIST [[startline] [-[endline]]]

Function:

A complete program or part of it is printed. The statement works in the same way as "LIST".

Example:

See LIST

See also:

LIST





LOAD


(MSX-Basic, Disk-Basic)

Syntax: LOAD "devicename:filename" [,R]

Function:

Loads a program from a device into the computer-memory.

Devicenames can be, e.g.: CAS:, A: or B:

The "SAVE" statement must have been used to store the program in ASCII format (on tape or disk).

The filename is an alphanumerical constant, that has been specified while the program was stored using the "SAVE" statement.



Disk-Basic: if ",R" is specified the programm is started immediately, after the load-operation is finished.

Turbo-R: the "CAS:" device is no longer supported!

Example:



LOAD "CAS:DEMO"

"LOAD CAS:" can only be used if a tape-recorder is connected to the MSX-Computer. LOAD "A:DEMO"

"LOAD A:" or "LOAD B:" can only be used if a disk-drive is connected to the MSX-Computer. See also:

BLOAD, CALL MFILES, CLOAD, FILES, MERGE, RUN, SAVE





LOCATE


(MSX-Basic) Syntax: LOCATE line, column [,cursoronoff]

Function:

Places the cursor to the position specified by line and column, where 0,0 is the upper left corner. Option cursoronoff toggles the cursor on/off. Usually the cursor is only visible during input, but

LOCATE,,1

can enable it at any time.

Example:



10 KEY OFF 20 LOCATE 1,23 30 PRINT "A" 40 LOCATE,,1 50 GOTO 50

See also:

CRSLIN, POS, PRINT





LOG


(MSX-Basic)

Syntax: LOG(number)

Function:

Calculates the natural logarithm (base e=2.718281884588).

Example:



PRINT LOG(10) 2.302585092994 PRINT LOG(100)/LOG(10) 2

See also:

EXP





LPOS


(MSX-Basic)

Syntax: LPOS(number)

Function:

Returns the position in the printer-buffer. The result is not necessarily the physical position of the printhead.

Example:



10 FOR I=1 TO 1000 20 LPRINT "Hello"; 30 IF LPOS(0)>38 THEN LPRINT CHR$(13) 40 NEXT 50 END

See also:

LPRINT





LPRINT


(MSX-Basic)

Syntax: LPRINT [USING "format";] [value [,value2 [,...]]] [;]

Function:

Prints information on the printer. The statement works in the same way as "PRINT".

Example:

See PRINT

See also:

PRINT, TAB, SPC, LPOS





MAXFILES


(MSX-Basic) Syntax: MAXFILES=number

Function:

Specifies the maximum number of files, that can be simultaneously open. number can be in range from 0-15.

Technote: the MAXFILES statement is built by 2 basic tokens (MAX FILES) Example:



10 MAXFILES=2 20 OPEN "CAS:DEMO" FOR INPUT AS #1 30 OPEN "LPT:" FOR OUTPUT AS #2 40 INPUT #1,A$ 50 PRINT #2,A$ 60 CLOSE 70 END

See also:

CLEAR, OPEN





MERGE


(MSX-Basic, Disk-Basic) Syntax: MERGE "[device:]filename"

Function:

Merges a program in memory with another from tape or disk. The lines to be merged must be saved in ASCII by using the "SAVE" statement. If some new lines have the same numbers as in memory the already existing lines will be replaced.

Turbo-R: the "CAS:" device is no longer supported!

Example:



MERGE "CAS:DEMO"

See also:

LOAD, SAVE





MID$


(MSX-Basic)

Syntax: MID$( string, position [,characters])

MID$( string, position [,characters])=string2

Function:

(1) An alphanumerical expression consisting of characters number of characters (or up to the string-end) beginning by position will be returned.

If characters is not specified or there are no more characters to the right of position then all remaining characters is returned. If position if larger than LEN(string) then an empty string is returned.

(2) Replaces parts of string by string2. Characters in string, beginning on position are replaced by string2. If characters is not specified all characters of string2 are used, as long as enabled by the length of string.

Disk-Basic: in addition to LSET and RSET also MID$ can be used to format strings, declared in the FIELD statement.

Example:



10 A$="Basic MSX Computer" 20 PRINT MID$(A$,7,3) 30 END RUN MSX Ok

10 A$="ABCDEFG" 20 PRINT A$ 30 MID$(A$,4)="XYZ" 40 PRINT A$ 50 END RUN ABCDEFG ABCXYZG Ok

See also:

LEFT$, RIGHT$, INSTR, LSET, RSET





MOD


(MSX-Basic)

Syntax: number MOD number2

Function:

Calculates the dividend of an integer division.

Example:



PRINT 5 MOD 3 2 Ok

PRINT 5 MOD 5 0 Ok

See also:

AND, EQV, IMP, NOT, OR, XOR, MSX-Basic operators





MOTOR


(MSX-Basic) Syntax: MOTOR ON

MOTOR OFF

Function:

Turns the motor of the tape-recorder on or off. If "ON" or "OFF" is specified the motor is toggled. This means that a switched on motor is turned off and a switched off motor is turned on.

Setting "ON" turns the motor on, setting "OFF" turns the motor off.

Turbo-R: MOTOR is no longer supported and will generate a "syntax error"

Example:



10 FOR I=1 TO 10 20 MOTOR 30 FOR J=1 TO 500:NEXT J 40 NEXT I

See also:

CLOAD, CLOAD?, CSAVE





NEW


(MSX-Basic)

Syntax: NEW

Function:

Erases the Basic program in memory.

"NEW" is usually used to delete the computer memory before starting with a new Basic program.

Example:



NEW

See also:





NOT


(MSX-Basic)

Syntax: NOT expression

Function:

Logical complement.

NOT 0 = 1

NOT 1 = 0

Example:



PRINT HEX$(NOT &H7FFF) 8000 Ok

100 INPUT "Y/N";A$ 120 IF NOT A$="N" THEN PRINT "Yes" ELSE PRINT "No" RUN (Y/N)?N No

See also:

AND, EQV, IMP, MOD, OR, XOR, MSX-Basic operators





OCT$


(MSX-Basic)

Syntax: OCT$(number)

Function:

Converts the specified number into an octal value. An octal number consists of the digits 0 to 7.

Example:



PRINT OCT$(1023) 1777 Ok

See also:

BIN$, HEX$, STR$, VAL





ON ERROR


(MSX-Basic) Syntax: ON ERROR GOTO line

Function:

line is the 1st line of an error-handling routine.

If "ON ERROR GOTO" statement is set MSX-Basic jumps to the specified line of the error-handler routine, whenever an error occurs.

"ERR" returns the corresponding errorcode and "ERL" returns the line-number where the error occured.

If the statement "ON ERROR GOTO 0" is set MSX-Basic does not jump to a specific line. In this case the normal error-handler takes place, stops the program and prints the error-message. Its recommended to use "ON ERROR GOTO 0" for errors, which are not handled by another error-handling routine.

If MSX-Basic recognizes an error while the error-handling routine is executed the common error is displayed.

The "RESUME" statement returns from the error-handling routine to the program location where the error occured.

Example:

See ERR

See also:

RESUME, ERL, ERROR, ERR





ON GOSUB


(MSX-Basic) Syntax: ON value GOSUB line [,line2 [,...]]

Function:

line1 respectively line2 are the 1st program-line of a subroutine.

The value determines, which subroutine MSX-Basic executes.

If, for example value is 3 a jump to the 3rd subroutine is performed.

If value is no integer it will be rounded down.

The value cannot be greater than 255 or negative.

Example:



10 FOR I=1 TO 3 20 ON I GOSUB 50,70,90 30 NEXT I 40 END 50 PRINT "I=";I;"subroutine line 50" 60 RETURN 70 PRINT "I=";I;"subroutine line 70" 80 RETURN 90 PRINT "I=";I;"subroutine line 90" 100 RETURN RUN I= 1 subroutine line 50 I= 2 subroutine line 70 I= 3 subroutine line 90 Ok

See also:

GOSUB





ON GOTO


(MSX-Basic) Syntax: ON value GOTO line [,line2 [,...]]

Function:

line1 and line2 are program line-numbers.

The value determines to which line number MSX-Basic jumps and where the program continues.

If, for example value is 3 a jump to the 3rd routine is performed.

If value is no integer it will be rounded down.

The value cannot be greater than 255 or negative.

Example:



10 FOR I=1 TO 3 20 ON I GOTO 50,70,90 30 NEXT I 40 END 50 PRINT "I=";I;"line 50" 60 GOTO 30 70 PRINT "I=";I;"line 70" 80 GOTO 30 90 PRINT "I=";I;"line 90" 100 GOTO 30 RUN I= 1 line 50 I= 2 line 70 I= 3 line 90 Ok

See also:

GOTO





ON INTERVAL


(MSX-Basic) Syntax: ON INTERVAL=number GOSUB line Function:

Calls a subroutine after the specified timeout has been elapsed. The timeout is number*1/60 (or number*1/50) seconds. After this statement MSX-Basic automatically calls the subroutine in line in the number of intervals.

During the processing of an errorhandler MSX-Basic automatically performs the "INTERVAL OFF" statement.

Example:



10 ON INTERVAL=300 GOSUB 60 20 INTERVAL ON 30 FOR I=1 TO 10000:NEXT I 40 INTERVAL OFF 50 END 60 K=K+6:PRINT K;"seconds" 70 RETURN RUN 6 seconds 12 seconds Ok

See also:

INTERVAL ON/OFF/STOP





ON KEY


(MSX-Basic) Syntax: ON KEY GOSUB line [,line2 [,...]]

Function:

line, line2, ... are the first line number of the corresponding subroutine. line substitutes the linenumber of the subroutine, which is called after the function-key 1 (F1) has been pressed, line2 references F2, and so on...

Before a subroutine can be called the "KEY(number) ON" statement must be executed. After doing so MSX-Basic automatically checks if the corresponding function-key was pressed and calls the associated subroutine.

During the processing of an errorhandler MSX-Basic automatically performs the "KEY(number) OFF" statement.

Example:



10 KEY OFF 20 ON KEY GOSUB 70, 80, 90 30 KEY(1) ON:KEY(2) ON:KEY(3) ON 40 GOTO 60 50 PRINT " pressed" 60 GOTO 60 70 PRINT "F1";:RETURN 50 80 PRINT "F2";:RETURN 50 90 PRINT "F3";:RETURN 50

See also:

KEY ON/OFF/STOP





10 DATA 60,66,165,129,165,153,66,60

20 DATA 60,126,219,255,255,219,102,60

30 A$=""

40 FOR I=1 TO 8

50 READ A:A$=A$+CHR$(A)





60 NEXT I


70 B$=""

80 FOR I=1 TO 8

90 READ A:B$=B$+CHR$(A)





100 NEXT I


110 SCREEN 2,1:COLOR 15,4,1





120 ON SPRITE GOSUB 210


130 SPRITE$(0)=A$:SPRITE$(1)=B$





140 SPRITE ON


150 A=INT(RND(1)*256) 160 B=INT(RND(1)*256) 170 FOR I=0 TO 191

180 PUT SPRITE 0,(A,I),1

190 PUT SPRITE 1,(B,191-I),15

200 NEXT I:GOTO 140





210 SPRITE OFF


220 PLAY "L4CDEFEDCREFGAGFER"


230 PUT SPRITE 0,(0,208) 240 PUT SPRITE 1,(0,208) 250 I=191:RETURN

RUN

See also:

SPRITE ON/OFF/STOP, GOSUB





ON STOP


(MSX-Basic) Syntax: ON STOP GOSUB line

Function:

Calls a subroutine in CTRL+STOP keys are pressed simultaneously. line is the first line of the subroutine.

The subroutine cann only be called after the "STOP ON" statement. After this instruction MSX-Basic automically calls the subroutine when CTRL- and STOP keys are pressed simultaneously.

During the processing of an errorhandler MSX-Basic automatically performs the "STOP OFF" statement.

Example:



10 ON STOP GOSUB 50 20 STOP ON 30 INPUT A$ 40 IF A$="END" THEN STOP OFF:END ELSE GOTO 30 50 PRINT "Enter END and press Return":RETURN RUN END Ok

See also:

STOP ON/OFF/STOP





ON STRIG


(MSX-Basic) Syntax: ON STRIG(stick) GOSUB line, line2, ...

Function:

Pressing a "fire-button" calls a subroutine. line respectively line2 is the first line of the corresponding subroutine.

line corresponds to the first line number of the subroutine which is called if the Space key is pressed, where line2 is the line-number to be called if the key on Joystick 1 is pressed, and so on. The subroutine can only be called after the "STRIG(stick) ON" statement. After this instruction MSX-Basic automically calls the subroutine when a fire-button is pressed.

During the processing of an errorhandler MSX-Basic automatically performs the "STRIG(stick) OFF" statement.

Example:



10 CLS 20 ON STRIG(X) GOSUB 50 30 STRIG(0) ON 40 GOTO 40 50 LOCATE 5,5 60 PRINT "SPACE key pressed" 70 FOR I=1 TO 300:NEXT I 80 LOCATE 5,5:PRINT SPC$(17) 90 RETURN RUN

See also:

STRIG ON/OFF/STOP





OR


(MSX-Basic)

Syntax: number1 OR number2

Function:

Logical inclusive or.

0 OR 0 = 0

0 OR 1 = 1

1 OR 0 = 1

1 OR 1 = 1

Example:



See also:

AND, EQV, IMP, MOD, NOT, XOR, MSX-Basic operators





OUT


(MSX-Basic)

Syntax: OUT port,value

Function:

Writes a value to an output-port. value and port must be in range from 0 to 255.

To read a byte from an input-port the function "INP" must be used.

Example:



See also:

INP, WAIT





PAD


(MSX-Basic)

Syntax: PAD( <number> )

Function:

Returns the position on the touchpad. One or more touchpads can be connected on the joystick-port(s).

<number> is an integer between 0 and 7. If <number> has a value between 0 and 3 it's assumed that the touchpad is connected to port 1. If <number> has a value between 4 and 7 the touchpad is connected to port 2.

If <number> is 0 or 4 the state of the touchpad is returned. The function returns -1, if the pad is touched and 0 if not.

If <number> is 1 or 5 the X-coordinate is returned, if <number> is 2 or 6 the Y-coordinate is returned.

If <number> is 3 or 7 the state of the button on the touchpad is returned. This function returns -1 if the button is pressed and 0 is not.



MSX 2 and MSX 2+:

If <number> is in range from 8 to 11 PAD is used to retrieve the state of a lightpen.

Note: this support is removed at the MSX Turbo-R, therefore such computers will return 0 in this case.



MSX 2 and higher:

If <number> is 12 the X/Y-offset of the mouse in port 1 is retrieved and can be queried by using PAD(13) and PAD(14). The return-value of PAD(12) is always -1.

If <number> is 13 the X-offset of the mouse in port 1 is returned (-128 to +127)

If <number> is 14 the Y-offset of the mouse in port 1 is returned (-128 to +127)

If <number> is 15 the return-value is 0 (reserved for mouse in port 1).

If <number> is 16 the X/Y-offset of the mouse in port 2 is retrieved and can be queried by using PAD(17) and PAD(18). The return-value of PAD(16) is always -1.

If <number> is 17 the X-offset of the mouse in port 2 is returned (-128 to +127)

If <number> is 18 the Y-offset of the mouse in port 2 is returned (-128 to +127)

If <number> is 19 the return-value is 0 (reserved for mouse in port 2).

Please note that the button-state of the mouse must be retrieved with the STRIG-function.



Example:



10 SCREEN 2 20 A=0 30 IF PAD(0)=0 THEN 20 40 X=PAD(1):Y=PAD(2) 50 IF A=0 THEN PSET(X,Y) ELSE LINE-(X,Y) 60 A=1 70 GOTO 30

See also:

PDL, STICK, STRIG





PAINT


(MSX-Basic) Syntax: PAINT [STEP](x,y)[,color][,bordercolor]

Function:

Fills a drawing in graphics mode with the specified color.

x is the X-coordinate of the starting point and must be an integer between 0 and 255 (or 511).

y is the Y-coordinate of the starting point and must be an integer between 0 and 191 (or 211).

If the word "STEP" is used the values of x and y are depending on the current cursor-position. In this case x and y can be negative too.

color is the color-number to be used for filling.

bordercolor is the color-number of the border-line.

In graphic-mode 1 the fill-color must be equal to the border-color. In this case bordercolor does not need to be specified. In graphic-mode 2 (and higher) fill-color and border-color can be different.

color and bordercolor must be integers between 0 and 15. See: color-table

Example:



10 SCREEN 2:COLOR 15,4,7 20 CIRCLE (80,80),20,8 30 PAINT (80,80),8 40 FOR I=1 TO 2000:NEXT I 50 SCREEN 3:COLOR 15,4,7 60 LINE (10,10)-(100,100),8,B 70 PAINT (45,45),2,8 80 FOR I=1 TO 2000:NEXT I 90 END RUN

See also:

CIRCLE, DRAW, LINE, PSET, SCREEN, CLS





PDL


(MSX-Basic) Syntax: PDL( <number> ) Function:

Returns the position of a paddle. One or two paddles can be connected to the joystick-port(s).

This function returns a value between 0 and 255.

<number> is a number from 1 to 12. If <number> is 1, 3, 5, 7, 9 or 11 so the paddle is connected to port 1. If <number> is 2, 4, 6, 8, 10 or 12 the paddle is connected to port 2.

Example:



10 CLS 20 FOR I=1 TO 500 30 LOCATE 10,5:PRINT PDL(1),PDL(2) 40 NEXT I 50 END

See also:

PAD, STICK, STRIG





PEEK


(MSX-Basic) Syntax: PEEK(address)

Function:

Returns a memory-byte.

This function returns the decimal-value of a memory-address and therefore results in a value between 0 and 255.

address is the memory-address and must be in range between -32768 and 65535.

If address is negative the binary complement is used. This means PEEK(-1)=PEEK(65536-1)=PEEK(65535).

The "POKE"statement is used to write a byte to a specific memory-address.

Example:



10 A=PEEK(65535) 20 A$="00"+HEX$(A) 30 PRINT RIGHT$(A$,2) 40 END RUN F0 Ok

See also:

POKE, VPEEK, BLOAD, BSAVE, VARPTR





PLAY


(MSX-Basic)

Syntax: PLAY "string" [,"string2"[,"string3"]]

Function:

This functions plays the notes specified in string. In this string you can also specify the pitch, duration, tempo and pause.

string, string2 and string3 are sub-commands built by alphanumeric constants. string corresponds to voice 1, string2 to voice 2 and string3 to voice 3.



To play a note from the scale: the following sub-commands are creating a note from the scale: A, B, C, D, E, F and G. A "+" or "#" after a note are indicating an -is (increased by a halftone) where A "-" indicates an -es (decreased by a halftone.

To set an octave: the sub-command "Onumber" sets the octave-number, which should be played. number is an integer from 1 to 8.

If no octave is specified the last used octave is used. The default value is 4.

To play a note-number: instead of playing an octave-number and a note-number music-note-numbers can be specified also. The sub-command "Nnumber" is used to specify a note-number. number is an integer between 0 and 95. If number is 0 no sound is generated. In this case a short pause is played before the remaining part.

To specify a note-length: the note-length is specified by the sub-command "Lnumber". number is an integer between 1 and 64 and has the following meaning:

1 = full note

2 = half note

3 = third note

4 = quarter note

and so on.

If no length is specifed the last used note is used. The default value is 4.

To change a note-length: by adding a dot (.) direct after specifying a note the length is multiplied by 1/2. You can also add multiple dots; e.g. "..." means the note is played in 15/8 times the speed of its original length.

To set a pause: the sub-command "Rnumber" is used to set a pause. number is an integer between 1 and 64 and has the following meaning:

1 = full pause

2 = half pause

3 = third pause

4 = quarter pause

and so on.



To set a tempo: the tempo is set with the sub-command "Tnumber". number is an integer from 32 to 255 and indicates the number of quarter notes per minute. If no tempo is set the last tempo will be used. The default value is 120.

To set an envelope: the envelope is set with the sub-command "Snumber". number is an integer from 0 to 15.

If no envelope is specified the last set value will be used. The default value is 1.

Sound modulation: the sound-period is specified with the sub-command "Mnumber". number is an integer from 1 to 65536 and sets the sound-period.

If no modulation is specified the last set modulation will be used. The default value is 255.

To start execution: The music instructions in an alphanumeric variable can be executed with the sub-command "XA$;" (don't forget the semicolon!).

A$ is the name of the variable that contains the musical sub-commands. Numeric variables can be used instead of numeric values in sub-commands. In this case an equal sign (=) has to be specified before these numeric variables and they have to be terminated with a semicolon (;), e.g.: AB=10:PLAY "N=AB;".

If MSX-Basic generates a beep-sound all values of the sub-commands will be reset to their default values!

Example:



PLAY "O5CDEFGABO6C"

10 A$="T128" 20 B$="L4CCFGL2AL8FEL4D.L8B-L4B" 30 PLAY "XA$;" 40 PLAY "XB$;" 50 END RUN

See also:

BEEP, PLAY(), PLAY (MSX-Music)





PLAY


(MSX-Basic) Syntax: PLAY(voice)

Function:

Returns the state of playing music.

voice has the following meaning:

0 = voice1, voice 2 and voice 3

1 = voice 1

2 = voice 2

3 = voice 3

The function returns -1 if the selected voice is playing. If playing has ended the function returns 0 again.

If the function is called immediately after the "PLAY" statement the value -1 is persistent.

Example:



10 A$="":BEEP 20 FOR I=1 TO 6 30 READ AA$:A$=A$+AA$ 40 NEXT I 50 PLAY "XA$;" 60 SCREEN 0:WIDTH 35:CLS 70 IF PLAY(0)=-1 THEN PRINT "The music is playing":GOTO 70 80 PRINT "The music has ended" 90 END 100 DATA CCGGAAGR 110 DATA FFEEDDCR 120 DATA GGFFEEDR 130 DATA GGFFEEDR 140 DATA CCGGAAGR 150 DATA FFEEDDCR RUN

See also:

PLAY





POINT


(MSX-Basic) Syntax: POINT(x,y) Function:

Returns the color-number of the specified point in graphics-mode.

x is the X-coordinate and must be an integer between 0 and 255 (or 0 and 511).

y is the Y-coordinate and must be an integer between 0 and 191 (or 0 and 211).

Example:



10 SCREEN 2:COLOR 15,1,7 20 OPEN "GRP:" FOR OUTPUT AS #1 30 FOR I=1 TO 10 40 PRESET(I*16,8) 50 C=INT(RND(1)*13)+2 60 COLOR C 70 PRINT #1,CHR$(1)+CHR$(66) 80 NEXT I 90 COLOR 15 100 PRESET (40,24) 110 PRINT #1,"Color numbers" 120 FOR I=1 TO 20 130 C=POINT(I*16+4,12) 140 PRESET(I*16,I*8+56),4 150 PRINT#1,USING "##";C 160 NEXT I 170 FOR I=1 TO 2000:NEXT I 180 COLOR 15,4,7 190 END RUN

See also:

PSET





POKE


(MSX-Basic) Syntax: POKE adress,value Function:

Fills a byte in memory adress with a byte of value.

address is the memory-address and must be in range between -32768 and 65535.

If address is negative the binary complement is used. This means POKE-1,0=POKE(65536-1),0.

This function is used to change the value of a specific byte in memory.

Example:



10 POKE 65534,PEEK(65534) 20 END RUN Ok

See also:

PEEK, VPOKE, BLOAD, BSAVE, DEFUSR, VARPTR





POS


(MSX-Basic) Syntax: POS(number)

Function:

Gives the X-coordinate (column-number) of the cursor.

This function returns a number between 0 and 39 (or 0 and 79). The most left column is 0. This function can only be used in text mode.

Example:



10 SCREEN 0 20 LOCATE 10,20 30 PRINT POS(0) 30 END RUN 10 Ok

See also:

CSRLIN, LOCATE





PRESET


(MSX-Basic) Syntax: PRESET [STEP](x,y)[,color]

Function:

Sets a color into the specified point at x,y in graphics mode.

x is the X-coordinate of the point and must be an integer between 0 and 255 (or 0 and 511).

y is the Y-coordinate of the point and must be an integer between 0 and 191 (or 0 and 211).

If the word "STEP" is used values for x and y are relative to the current cursor-position. In this case x and y can be negative too.

color is the color-number and must be an integer between 0 and 15 (see: color-table).

If color is not set the last used background-color will be assumed. The default-value of color is 4.

Example:



10 SCREEN 2:COLOR 15,4,7 20 LINE (40,40)-(215,151),15,BF 30 FOR I=0 TO 1000 40 A=INT(RND(1)*173)+41 50 B=INT(RND(1)*109)+41 60 PRESET(A,B) 70 FOR K=0 TO 300:NEXT K 80 NEXT I 90 END RUN

See also:

PSET, CIRCLE, DRAW, LINE, PAINT, SCREEN, CLS





PRINT


(MSX-Basic, Disk-Basic)

Syntax: PRINT [USING "format";] [value [,value2 [,...]]] [;]

PRINT #channel, [USING "format";] variable

Function:

The first format is used to display data on the screen. If the word PRINT is used without suffix MSX-Basic generates an empty line. If an expression is added it's value is displayed on the screen. The expression can be of numeric or alphanumeric type. In case of alphanumeric constants these have to be quoted (e.g. 10 PRINT "Hello").

Print position: The position where the printout appears on the screen depends on the punctation between different values (expressions). MSX-Basic separates each screen-line into zones of 14 positions. If a value is followed by a colon (,) the next output appears in the next zone. If the value is followed by a semicolon (;) the next output appears immediately behind the last value. If a "PRINT" statement ends with a colon (,) or a semicolon (;) the output of the next "PRINT" statement appears on the same screen-line. If a "PRINT" statement does not end with a colon (,) or a semicolon (;) the output of the next "PRINT" statement appears in the next line. If the number of positions in the printout is larger than the number of positions per screen-line (defined by the "WIDTH" statement) MSX-Basic automatically continues in the next line.

Numbers: Behind each number, that is displayed on the screen, is always a space. In front of positive numbers is a space, in front of negative numbers a minus (-).

The 2nd format of the "PRINT" statement is used to write data into a sequential file (opened as #channel) opened for OUTPUT. After every "PRINT" statement a 'CR' and 'LF' character is written into the file. MSX-Basic automatically places a colon "," between numerical expressions in a simple "PRINT" statement as well as a hyphen if printing goes to a file. Alphanumerical expressions have to be separated by a colon and a hyphen. To read data from a file with uniform records the statement "INPUT#" can be used.

Printing formats: printout can be formatted, if preceded by "USING". Possible syntax of the specified format is documented in the chapter "USING".

Instead of the keyword "PRINT" also a question mark (?) can be used.

Example:



? "Hello" Hello

PRINT "World" World

10 CLS 20 FOR I=1 TO 5 30 ? USING "Number is #.#-";I 40 NEXT

See also:

LPRINT, TAB, SPC, PUT, INPUT, CLS, WIDTH, LOCATE, OPEN, INPUT[#]





PSET


(MSX-Basic) Syntax: PSET [STEP](x,y)[,color]

Function:

Sets a color into the specified point at x,y in graphics mode.

x is the X-coordinate of the point and must be an integer between 0 and 255 (or 0 and 511).

y is the Y-coordinate of the point and must be an integer between 0 and 191 (or 0 and 211).

If the word "STEP" is used values for x and y are relative to the current cursor-position. In this case x and y can be negative too.

color is the color-number and must be an integer between 0 and 15 (see: color-table).

If color is not set the last used foreground-color will be assumed. The default-value of color is 15.

Example:



10 SCREEN 2:COLOR 15,4,7 20 LINE (40,40)-(215,151),15,B 30 FOR I=0 TO 1000 40 A=INT(RND(1)*173)+41 50 B=INT(RND(1)*109)+41 60 PSET(A,B) 70 FOR K=0 TO 300:NEXT K 80 NEXT I 90 END RUN

See also:

PRESET, CIRCLE, DRAW, LINE, PAINT, POINT, SCREEN, CLS





PUT SPRITE


(MSX-Basic) Syntax: PUT SPRITE priority, [STEP](x,y), color, number Function:

Put a defined sprite in graphics mode on the screen.

priority specifies the priority of the sprite and must be an integer between 0 and 31.

x is the X-coordinate of the sprite and must be an integer between -32 and 255.

y is the Y-coordinate of the sprite and must be an integer between -32 and 191 or 208 or 209. If y is 208 all sprites with a lower priority will disappear from the screen. If y is 209 only this sprite will disappear from the screen.

If the word "STEP" is specified the values x and y are relative to the current screen-position. In this case x and y can be negative too. If x and y are not specified the actual coordinate remains unchanged.

color is the color-number of the sprite and must be an integer between 0 and 15 (see: color-table).

If color is not set the last foreground-color will be used. The default-value is 15.

number is the number of the sprite, as used in SPRITE$(number). If number is not specified its equal to the priority.

Example:

See: ON SPRITE GOSUB

See also:

SPRITE$, ON SPRITE GOSUB, SCREEN, COLOR SPRITE, COLOR SPRITE$





READ


(MSX-Basic) Syntax: READ variable [,variable2 [,...]]

Function:

Reads a constant from the "DATA" statement and assigns it to a variable.

The "READ" statement can only be used with a "DATA" statement. The "READ" statement gives access to the data, listed after the "DATA" statement and in order of the line-numbers.

The variable in the "READ" statement can be numeric or alphanumeric. The type of the variable must match with the corresponding constant in the "DATA" statement.

A single "READ" statement can give access to one or more "DATA" statements. Its also possible to access the data of a single "DATA" statement with multiple "READ" statements.

If the number of variables in the "READ" statement is larger than the number of constants in the "DATA" statement MSX-Basic generates an "Out of data" error.

If the number of variables in the "READ" statement is smaller than the number of constants in the "DATA" statement the next "READ" statement continues with the remaining constants. If no more "READ" statements are executed the remaining constants are ignored.

"DATA" statements can be specified since the program-start, or explicitly selected with a line-number in the "RESTORE" statement.

Example:

See: DATA

See also:

DATA, RESTORE





REM


(MSX-Basic) Syntax: REM

'

Function:

Inserts a remark into the program text.

"REM" statements are not executed when the program runs, but printed if the program is listed.

The program use "GOTO" and "GOSUB" to link to a "REM" statement. In this case the program execution continues at the statement behind the "REM".

Instead of the keyword "REM" also a single apostroph (') can be used. Do not use this keyword within a "DATA" statement.

Example:



10 REM Calculation 20 FOR I=1 TO 10 30 SUM=SUM+I 40 NEXT I 50 SUM=SUM/10

or 10 FOR I=1 TO 10 'Calculation 20 SUM=SUM+I 30 NEXT I 40 SUM=SUM/10

See also:

DATA





RENUM


(MSX-Basic) Syntax: RENUM [line] [,line2 [,increment]

Function:

Renumbers program lines.

line is the first program-line, which is used in the new order. If line is not specified the order starts in line 10.

line2 is the existing program-line where the re-ordering should start. If line2 is not specified the order starts in the 1st program-line.

increment is the step-width of the new order. If increment is not specified MSX-Basic uses 10.

The statement "RENUM" renumbers also the line-numbers after the statements "GOTO", "GOSUB", "IF THEN ELSE", "ON GOTO" and "ON GOSUB". The renumbered value is based on the new line-number which has been changed due to the re-ordering. If a non-existing line-number is recognized the error "Undefined line XX in YY" is raised.

The statement "RENUM" can not be used to change the order of line-numbers.

Example:



RENUM

This statement renumbers all program lines, beginning at the first line. The first line gots the number 10. Subsequent line-numbers are increased by 10. RENUM 1000,900,50

(new value=1000, previously 900, increment by 50)

This statement renumbers all program lines, beginning on line 900. Line 900 becomes line 1000 ands ubsequent line-numbers are increased by 50. 900 FOR I=1 TO 10 910 PRINT I; 920 IF I<10 THEN 930 ELSE 940 930 NEXT 940 END

1000 FOR I=1 TO 10 1050 PRINT I; 1100 IF I<10 THEN 1150 ELSE 1200 1150 NEXT 1200 END

See also:

AUTO





RESTORE


(MSX-Basic) Syntax: RESTORE [line]

Function:

The "RESTORE" statement sets the data-pointer to the first element of the "DATA" statement to line of the program.

line is the line-number of a "DATA" statement. After a "RESTORE" is performed the first constant of a "DATA" statement is returned by the "READ" statement.

If line is not specified the "READ" statement returns the 1st constant of the 1st "DATA" statement.

Example:



10 DATA 123,ABC,48.5 20 READ A%,A$,A! 30 PRINT A%;A$;A! 40 RESTORE 50 READ A%:PRINT A% 60 END RUN

See also:

DATA, READ





RESUME


(MSX-Basic) Syntax: RESUME [line]

RESUME 0

RESUME NEXT

Function:

line is the line-number of the program, in which - after execution of the error-handling routine specified by "ON ERROR GOTO" - the program will be resumed. If line is not specified or 0 the program will be continued on the location where the error was detected.

If the keyword "NEXT" is used (instead of line) the program execution is resumed on the statement immediately following the error-location.

Example:

See ERR

See also:

ON ERROR GOTO, ERL, ERROR, ERR





RETURN


(MSX-Basic) Syntax: RETURN [linenumber]

Function:

Returns from a subroutine that was invoked by GOSUB.

In contrast to other Basic dialects the RETURN statement can specify an explicit line-number where the program can return to.

Example:



100 PRINT "Hello" 110 GOSUB 200 120 END 200 PRINT "Here am I" 210 RETURN 110

Generates an infinite loop because the subroutine always returns to it's invocation point: Hello Here am I Here am I ... See also:

GOSUB





RIGHT$


(MSX-Basic) Syntax: RIGHT$(string, number) Function:

Returns the last number (0-255) characters from the right end of the specified string. If number is larger than the string the whole string is returned. If number is 0 an empty string is returned.

Example:



10 A$="Basic" 20 FOR I=1 TO LEN(A$) 30 PRINT RIGHT$(A$,I) 40 NEXT 50 END RUN c ic sic asic Basic

See also:

LEFT$, MID$





RND


(MSX-Basic) Syntax: RND(number)

Function:

Generates a random-number between 0 and 1.

Whenever a program is started with "RUN" the same sequence of random-numbers is generated.

If number is greater than 0 the next random-value of the sequence is returned. If number is equal to 0 the last random-value of the sequence is returned.

If number is less than 0 the sequence of random-numbers is rebuilt based on the negative number.

To generate a real random-number the generator must always select a new sequence after the program has been started. This can be ensured by using the variable "TIME".

Example:



10 R=RND(TIME) 20 FOR I=1 TO 10 30 SCREEN 2:COLOR 15,4,7 40 C=INT(RND(1)*15+1) 50 IF C=4 GOTO 40 60 CIRCLE (80,80),20,C 70 PAINT (80,80),C 90 NEXT I 100 END RUN

See also:

TIME





RUN


(MSX-Basic, Disk-Basic) Syntax: RUN [line]

RUN "devicename:filename" [,line]

Function:

Starts the execution of a program, which is stored in the computer-memory or a device.

Devicenames can be, e.g.: CAS:, A: or B:

The "SAVE" statement must have been used to store the program in ASCII format (on tape or disk).

The filename is an alphanumerical constant, that has been specified while the program was stored using the "SAVE" statement.

If devicename and filename are not specified the program in memory will be executed.

line corresponds to the program line-number. If line is specified the program starts in this line. If line is not specified the program starts in the first line.

Turbo-R: the "CAS:" device is no longer supported!

Example:



RUN 100

(in this case the program execution starts in line 100) See also:

LOAD, CALL RUN, END, STOP, CONT





SAVE


(MSX-Basic, Disk-Basic) Syntax: SAVE "devicename:filename" [,A]

Function:

Stores a program of the computer-memory onto a device (tape or disk).

If a program is saved to a tape ("CAS:") it can be restored with the "LOAD" and "MERGE" statements.

Reminder:

CSAVE saves in binary format

SAVE "CAS:" saves in ASCII format onto tape

SAVE saves binary and SAVE...,A in ASCII code onto disk

Devicenames can be, e.g.: CAS:, A: or B:

Turbo-R: the "CAS:" device is no longer supported!

Example:



SAVE "CAS:DEMO"

See also:

BSAVE, CSAVE, LOAD, MERGE





10 FOR I=2 TO 3

20 SCREEN I:COLOR 15,4,7

30 LINE (32,32)-(200,132),6

40 FOR K=0 TO 3000:NEXT

50 NEXT I





60 END


RUN


See also:

PRINT, INPUT, CIRCLE, DRAW, LINE, PAINT, PSET, PRESET, WIDTH, CLS, CALL CLS, CALL KANJI, CALL ANK, SET PAGE, SET SCREEN





SGN


(MSX-Basic) Syntax: SGN(number)

Function:

Returns the value 1 if number is > 0, returns the value 0 if number is = 0 and returns the value -1 if number is < 0.



Example:



10 INPUT "Number";N 20 IF N<-1 OR N>1 THEN GOTO 10 30 H=SGN(N):H=H+2 40 ON H GOSUB 70,80,90 50 PRINT B$ 60 END 70 B$="Number is negative":RETURN 80 B$="Number is zero":RETURN 90 B$="Number is positive":RETURN RUN

See also:

ABS





SIN


(MSX-Basic)

Syntax: SIN(number)

Function:

Returns the sinus of the specified number in radians.

Example:



10 X=5 20 PRINT SIN(X) 30 END RUN

See also:

ATN, COS, TAN





SOUND


(MSX-Basic) Syntax: SOUND register, value Function:

Writes a value into the PSG register.

register is the register-number and must be an integer betwenn 0 and 15.

value is the value to be written into the register. This must be an integer between 0 and 255.

USE THIS STATEMENT ONLY IF YOU ARE FAMILIAR WITH THE PSG (PROGRAMMABLE SOUND GENERATOR).

Example:



10 FOR I=0 TO 13 20 SOUND I,0 30 NEXT I 40 SOUND 7,62:SOUND 8,15 50 FOR I=0 TO 255 60 SOUND 0,I 70 NEXT I 80 SOUND 8,0 90 END RUN

See also:

PLAY, BEEP, CALL AUDREG (MSX-Music)





SPACE$


(MSX-Basic) Syntax: SPACE$(number)

Function:

Generates an alphanumeric string with number of spaces.

number must be an integer between 0 and 255.

Example:



10 FOR I=0 TO 5 20 A$=SPACE$(I) 30 PRINT A$;I 40 NEXT I 50 END RUN 1 2 3 4 5 Ok

See also:

STRING$, TAB, SPC





SPC


(MSX-Basic)

Syntax: SPC(number)

Function:

Prints number of characters.

This function can only be used with "PRINT" and "LPRINT" statements.

number must be an integer between 0 and 255.

Example:



See also:

PRINT, LPRINT, TAB, SPACE$, STRING$





10 DATA 60,66,165,129,165,153,66,60

20 DATA 60,126,219,255,255,219,102,60

30 A$=""

40 FOR I=1 TO 8

50 READ A:A$=A$+CHR$(A)





60 NEXT I


70 B$=""

80 FOR I=1 TO 8

90 READ A:B$=B$+CHR$(A)





100 NEXT I


110 SCREEN 2,1:COLOR 15,4,1





120 ON SPRITE GOSUB 210


130 SPRITE$(0)=A$:SPRITE$(1)=B$





140 SPRITE ON


150 A=INT(RND(1)*256) 160 B=INT(RND(1)*256) 170 FOR I=0 TO 191

180 PUT SPRITE 0,(A,I),1

190 PUT SPRITE 1,(B,191-I),15

200 NEXT I:GOTO 140





210 SPRITE OFF


220 PLAY "L4CDEFEDCREFGAGFER"


230 PUT SPRITE 0,(0,208) 240 PUT SPRITE 1,(0,208) 250 I=191:RETURN

RUN

See also:

ON SPRITE GOSUB





10 SCREEN 2,0

20 Y=1

30 B$=""

40 FOR I=1 TO 8

50 READ A$:B$=B$+CHR$(VAL("&B"+A$))





60 NEXT I


70 SPRITE$(0)=B$

80 FOR X=1 TO 200

90 Y=Y+1

100 PUT SPRITE 0,(X,Y)

110 NEXT X





120 END


130 DATA 00011000,00111100,01111110,11111111,00100100,00100100,010000010,10000001

10 SCREEN 2,0

20 Y=1

30 B$=""

40 FOR I=1 TO 8

50 READ A$:B$=B$+CHR$(VAL("&H"+A$))





60 NEXT I


70 SPRITE$(0)=B$

80 FOR X=1 TO 200

90 Y=Y+1

100 PUT SPRITE 0,(X,Y)

110 NEXT X





120 END


130 DATA 18,3C,7E,FF,24,24,42,81

10 SCREEN 2,0

20 Y=1

30 B$=""

40 FOR I=1 TO 8

50 READ A$:B$=B$+CHR$(VAL(A$))





60 NEXT I


70 SPRITE$(0)=B$

80 FOR X=1 TO 200

90 Y=Y+1

100 PUT SPRITE 0,(X,Y)

110 NEXT X





120 END


130 DATA 24,60,126,255,36,36,66,129

Example:

See: ON SPRITE GOSUB

See also:

PUT SPRITE, ON SPRITE GOSUB





SQR


(MSX-Basic)

Syntax: SQR(number)

Function:

Returns the square-root of the specified number.

Example:



10 X=10:Y!=SQR(X) 20 PRINT Y! 30 END RUN 3.16228 Ok

See also:





STICK


(MSX-Basic) Syntax: STICK(sticknumber)

Function:

This function returns the direction of the joystick. The meaning of the returnvalue is as following:

8 1 2

7 0 3

6 5 4



The sticknumber can have the following values:

0 = Cursor-keys (space is trigger)

1 = Joystick on port 1

2 = Joystick on port 2

Example:



10 PRINT "Press the cursor-keys" 20 PRINT STICK(0) 30 FOR I=0 TO 300:NEXT I 40 GOTO 20 RUN

See also:

PAD, PDL, STRIG, INKEY$, ON GOSUB, ON GOTO





STOP


(MSX-Basic)

Syntax: STOP

Function:

Terminates a programs execution. When the interpreter reaches the last line of the program, it is automaticly terminated, STOP is not necessary there. After STOP a CONT instruction can continue the program execution on the next line.

Example:



10 PRINT "Test" 20 STOP 30 PRINT "CONT was used" 40 END RUN

See also:

END, RUN, CONT





STOP


(MSX-Basic) Syntax: STOP ON

STOP OFF

STOP STOP

Function:

Checks if the CTRL and STOP keys are pressed simultaneously.

After the "STOP" stamement MSX_Basic checks with every statement if the CTRL+STOP keys are pressed simultaneously. If so the MSX-Basic program calls the subroutine that was specified in the "ON STOP GOSUB" statement.

After the "STOP OFF" statement MSX-Basic does no no longer check if CTRL+STOP keys are pressed simultaneously.

After the "STOP STOP" statement MSX-Basic checks if CTRL+STOP are pressed simultaneously, but does not call the subroutine that was specified in the "ON STOP GOSUB" statement. But the state is remembered. In this case the subroutine is immediately called after the "STOP ON" statement is executed.

Example:



10 ON STOP GOSUB 50 20 STOP ON 30 INPUT A$ 40 IF A$="END" THEN STOP OFF:END ELSE GOTO 30 50 PRINT "Enter END and press Return":RETURN RUN END Ok

See also:

ON STOP GOSUB





10 PRINT "Hit the space key"

20 P=STRIG(0) 30 IF P=-1 THEN BEEP





40 GOTO 20


RUN


See also:

PAD, PDL, STICK, INKEY$





STRIG


(MSX-Basic)

Syntax: STRIG(number) ON

STRIG(number) OFF

STRIG(number) STOP

Function:

Checks the status if the joystick or space key.

number is a number between 0 and 4 and has the following meaning:

0 Space key

1 Joystick in connector 1

2 Joystick in connector 2

3 Joystick in connector 1

4 Joystick in connector 2

After the "STRIG(number) ON" statement MSX-Basic checks with every statement if the specified joystick button is pressed. If so MSX-Basic calls the subroutine, that was specified in the "ON STRIG GOSUB" statement.

After the "STRIG(number) OFF" statement MSX-Basic no longer checks, if the specified joystick button is pressed.

After the "STRIG(number) STOP" statement MSX-Basic checks if the specified joystick button is pressed, but does not call the subroutine that was specified in the "ON STRIG GOSUB" statement. But the state is remembered and the subroutine is automatically called after the "STRIG(number) ON" statement.



Example:

See: ON STRIG GOSUB

See also:

ON STRIG GOSUB





STR$


(MSX-Basic) Syntax: STR$(number)

Function:

Creates the alpanumeric representation of the numeric expression in number.

Use the "VAL" function to get the numeric representation of the alphanumeric expression.

Example:



10 AMOUNT=12.34216:PRINT AMOUNT 20 A$=STR$(AMOUNT) 30 H%=INSTR(A$,".") 40 IF H%=<1 GOTO 80 50 MID$(A$,H%,1)="," 60 H$=LEFT$(A$,H%+2) 70 PRINT H$ 80 END RUN 12.34216 12,34 Ok

See also:

BIN$, HEX$, OCT$, VAL





STRING$


(MSX-Basic) Syntax: STRING$(length, character) Function:

Creates a string with length characters, which consists only of characters that was specified in character.

length is the length of the alpanumeric value and must be an integer in range between 0 and 255.

character is the code of the character and must be an integer between 32 and 255, or the corresponding character (string) directly.

Example:



10 SCREEN 1:COLOR 15,4,7 20 A$=CHR$(42) 30 FOR K=1 TO 22 40 C=INT(RND(1)*20) 50 LOCATE 3,K 60 PRINT USING "##";C 70 LOCATE 6,K 80 PRINT STRING$(C,A$) 90 NEXT K 100 END RUN

See also:

SPACE$, SPC, TAB





SWAP


(MSX-Basic) Syntax: SWAP variable, variable2

Function:

Exchanges the contents of two variables.

Every type of variable (integer, single precision, double precision, alphanumeric) can be used. The only restriction is that both variables are of the same type.

Example:



10 X=3:Y=7 20 GOSUB 60 30 SWAP X,Y 40 GOSUB 60 50 END 60 PRINT "X=";X;"Y=";Y 70 RETURN RUN

See also:

LET





TAB


(MSX-Basic) Syntax: TAB(position)

Function:

Sets a tabulator. The cursor jumps to a pre-defined position in the same line.

This function can only be used with "PRINT" and "LPRINT" statements.

number must be an integer between 0 and 255.

If the cursor has already reached the specified position the function is ignored.

Example:



10 PRINT "0";TAB(9);"9" 20 END RUN

See also:

PRINT, LPRINT, SPC, SPACE$, STRING$





TAN


(MSX-Basic)

Syntax: TAN(number)

Function:

Returns the tangent of the specified number in radians.

Example:



10 X=5 20 PRINT TAN(X) 30 END RUN -3.3805150062446 Ok

See also:

ATN, COS, SIN





TIME


(MSX-Basic)

Syntax: TIME

Function:

Contains the internal system-time.

Every time the video display processor creates an interrupt (every 1/60s or 1/50s), the variable "TIME" is incremented by 1.

If no interrupt is generated (e.g. while saving a program to tape or loading from tape) the "TIME" variable remains unchanged.

Example:



10 CLS 20 LOCATE 10,6 30 PRINT "HH:MM:SS START" 40 TIME=0 50 T=TIME 60 H=INT(T/180000) 70 T=T-(H*180000) 80 M=INT(T/3000) 90 T=T-(M*3000) 100 S=INT(T/50) 110 LOCATE 10,8 120 PRINT USING "##:##:##";H;M;S 130 GOTO 50 RUN

See also:

RND, GET TIME





TROFF


(MSX-Basic)

Syntax: TROFF

Function:

Disable tracing of the program execution.

The trace function is enabled with the "TRON" statement. The trace function can also be disabled with the "NEW" statement.

Example:

See: TRON

See also:

TRON, NEW





TRON


(MSX-Basic)

Syntax: TRON

Function:

Enables the trace function.

After the "TRON" statement MSX-Basic prints all program-lines (that are executed during the program flow) in brackets.

Example:



10 FOR I=1 TO 3 20 PRINT I 30 NEXT 40 END TRON Ok RUN [10][20] 1 [30][20] 2 [30][20] 3 [30][40] Ok TROFF Ok

See also:

TROFF





DEF USR1=&H156:A=USR1(0)

10 CLEAR 200,&HEFFF

20 AB=&HF000

30 FOR I=AB TO AB+9

40 READ A$:A=VAL("&H"+A$) 50 POKE I,A





60 NEXT I


70 DEFUSR=&HF000

80 INPUT "Enter an integer";A%

90 PRINT "The integer is";A%

100 R=USR(A%)

110 PRINT "Result is the integer plus 1";R





120 END


130 DATA 23,23,4E,23,46,03,70,2B,71,C9

RUN

See also:

DEFUSR, BLOAD, POKE, VARPTR, CLEAR





VAL


(MSX-Basic) Syntax: VAL(string)

Function:

Returns the value of the alphanumeric expression in string.

The function ignores spaces and control-characters in the expression.

The "STR$" function can be used to get an alphanumeric representation of a numeric expression.

Example:



10 AMOUNT=12.34216:PRINT AMOUNT 20 A$=STR$(AMOUNT) 30 H%=INSTR(A$,".") 40 IF H%=<1 GOTO 80 50 H%=H%+2 60 B$=LEFT$(A$,H%) 70 AMOUNT=VAL(B$):PRINT AMOUNT 80 END RUN 12.34216 12.34 Ok

See also:

BIN$, HEX$, OCT$, STR$





VARPTR


(MSX-Basic, RS232-Basic) Syntax: VARPTR(variable)

VARPTR(#channel)

Function:

Returns the memory-address of the first byte of a variable or the first byte of a file-control-block (of an open file).

The first format returns the memory-address of a variable. This variable must be already initialized with a value, otherwise an "Illegal function call" will be generated.

Every type of variable (integer, single precision, double precision, alphanumeric) and dimensioned variables (defined by the "DIM" statement) can be used with the "VARPTR" function.

Before the address of a dimensioned variable can be accessed its necessary to assign a value to all non-dimensioned variables. This is required because adresses of dimensioned variables will change if new not-dimensioned variables are used.

The function "VARPTR" is most recently used to get the memory-address of a variable, which should be passed to an assembly-language subroutine.

The second format returns the first address of the file-control-block of a file.

channel is the file-number of the file, which was opened with the "OPEN" statement.

The "VARPTR" function returns a value between -32768 and 32767. If a negative value is given 65536 is added first to get the actual address.

Example:



10 A=10 20 B=VARPTR(A) 30 IF B<0 THEN B=B+65536 40 C$="0000"+HEX$(B) 50 PRINT RIGHT$(C$,4) 60 END RUN C059 Ok

See also:

PEEK, POKE, DEFUSR, USR, DIM, OPEN





VDP


(MSX-Basic) Syntax: VDP(register)

Function:

Contains the value of the specified VDP register (video display processor).

register is the register number and must be an integer between 0 and 8. The content of register 8 is read-only and cannot be changed.

MSX2: registers 9 to 24 and 33 to 47 are added.

MSX2+ registers 26-28 are added.

USE THIS VARIABLE ONLY IF YOU ARE FAMILIAR WITH THE VDP (VIDEO DISPLAY PROCESSOR).

Example:



10 FOR I=0 TO 8 20 A=VDP(I) 30 B$="00000000"+BIN$(A) 40 PRINT RIGHT$(B$,8) 50 NEXT I 60 END RUN

See also:

BASE





VPEEK


(MSX-Basic) Syntax: VPEEK(adress)

Function:

Returns the value of a byte within the video-memory.

The function returns a byte-value for the specified address and is therefore in range between 0 and 255.

address is the address within the video-memory and must be in range between 0 and 16383 (or -32768 and 32767).

The statement "VPOKE" can be used to write a byte into the video memory.

MSX2: the size of video-memory has been increased from 16KB to 64KB and more, therefore address can be in range from -32768 to 32767.

USE THIS FUNCTION ONLY IF YOU ARE FAMILIAR WITH THE VDP (VIDEO DISPLAY PROCESSOR) Example:



10 A=VPEEK(0) 20 A$="00"+HEX$(A) 30 PRINT RIGHT$(A$,2) 40 END RUN

1000 REM ******************** 1010 REM Hardcopy of screen 0 1020 REM ******************** 1030 LPRINT CHR$(13):FOR I=0 TO 959 1040 LPRINT CHR$(VPEEK(I)); 1050 IF I>0 AND (I+1)/40=INT((I+1)/40) THEN LPRINT CHR$(13); 1060 NEXT I

See also:

VPOKE, PEEK, SCREEN, SET PAGE





VPOKE


(MSX-Basic) Syntax: VPOKE adress,value

Function:

Writes a byte into the video-memory.

address is the address within the video-memory and must be in range between 0 and 16383 (or -32768 and 32767).

value is the byte value and must be between 0 and 255.

The function "VPEEK" can be used to read a byte from video-memory.

MSX2: the size of video-memory has been increased from 16KB to 64KB and more, therefore address can be in range from -32768 to 32767.

USE THIS FUNCTION ONLY IF YOU ARE FAMILIAR WITH THE VDP (VIDEO DISPLAY PROCESSOR) Example:



10 VPOKE 0,(VPEEK(0)) 20 END RUN

See also:

VPEEK, POKE, SCREEN, SET PAGE





WAIT


(MSX-Basic) Syntax: WAIT port, xormask[, andmask]

Function:

Monitors the status of a machine input-port port.

While this statement is executed data from the port is read and compared with xormask (on XOR base) and andmask (on AND base) . If the result of this comparison is 0, then MSX-Basic reads the port again and compares the data. In all other cases the program will be continued.

If andmask is not specified the value 0 will be assumed.

Example:

See: INP and OUT

See also:

INP, OUT, XOR, AND





WIDTH


(MSX-Basic) Syntax: WIDTH textwidth

Function:

Specifies the number of positions in a single screenline for textmode 1 and 2.

textwidth is the number of positions per line and must be an integer between 1 and 40 (or 1 and 80) in textmode 1 and an integer between 1 and 32 in textmode 2.

If MSX-Basic starts Textmode 1 uses "WIDTH 37" and textmode 2 uses "WIDTH 19".

MSX2: the textmode 1 can now have up to 80 characters, therefore the textwidth can be in range between 1 and 80. If textwidth is > 40 the 80 character mode is activated, if textwidth is <= 40 the 40 character mode is activated.

The width can also be saved by using the "SET SCREEN" statement, so the system will restore the changed defaults on power-up.

Example:



5 SCREEN 0 10 FOR I=37 TO 10 STEP -1 15 WIDTH I 20 PRINT "This is a line of text on the screen" 25 FOR X=1 TO 300:NEXT 30 REM line 25 is a time-delay 35 NEXT I 40 WIDTH 40 45 REM line 40 restores the old format again 50 END

See also:

SCREEN, SET SCREEN, CALL KANJI





XOR


(MSX-Basic)

Syntax: number1 XOR number2

Function:

Logical exclusive or.

0 XOR 0 = 0

0 XOR 1 = 1

1 XOR 0 = 1

1 XOR 1 = 0

Example:



See also:

AND, EQV, IMP, MOD, NOT, OR, MSX-Basic operators





COLOR SPRITE(0)=15

See also:

COLOR, COLOR SPRITE$, PUT SPRITE





---------------------------------

Line 1 --> | * | | | * | * | | | * |

|---+---+---+---+---+---+---+---|

Line 2 --> | * | * | | | | | * | * |

|---+---+---+---+---+---+---+---|

| | | | | | | | |

|---+---+---+---+---+---+---+---|

| * | * | | | | | * | * |

|---+---+---+---+---+---+---+---|

| | | * | | | * | | |

|---+---+---+---+---+---+---+---|

| * | | | * | * | | | * |

|---+---+---+---+---+---+---+---|

| * | * | | | | | * | * |

|---+---+---+---+---+---+---+---|

Line 8 --> | | | * | * | * | * | | | The color for each line --------------------------------- can be set.

COLOR SPRITE$(0)=STRING$(16,&HFF)

See also:

COLOR, COLOR SPRITE, PUT SPRITE





COLOR=


(MSX-Basic 2)

Syntax: COLOR=(palette no., red luminance, green lumincane, blue luminance)

Palette no. Condition: when screen mode is 0 to 7 or 10: 0 to 15. Numerical constant variable, array variable or expression.

Red/green/blue luminance: 0 to 7. Integer constant

Function:

You can express 512 kind of colors by combining red, green and blue luminance. If you do not execute this command to a palette no, it's color stays default.



Note: use CALL PALETTE statement to specify palette color under Japanese input mode. If you try to use this COLOR statement during Japanese input mode, you will get "Illegal function call". (Same is true with COLOR=NEW and COLOR=RESTORE statements).

Example:



100 SCREEN 5 110 FOR I=7 to 0 STEP -1 120 CIRCLE(120,100),I*10+5,I 130 PAINT(120,100),I,1 140 NEXT I 150 J=(J+1) MOD 8 160 FOR I=0 to 7 170 COLOR=(I,0,J,0) 180 J=(J+1) MOD 8 190 NEXT I 200 GOTO 150

See also:

CALL PALETTE, COLOR=RESTORE, COLOR=NEW, DRAW, LINE, CIRCLE, PSET, PAINT





COLOR=RESTORE


(MSX-Basic 2) Syntax: COLOR=RESTORE

Function:

This commands substitues contents of "Color Lookup Table" inside VRAM, into VDP color palette registers.



Usage:

COLOR=RESTORE (no options whatsoever; just this form) How it works, and how you use this:



If you BSAVE with ,S option, you can save the contents of VIDEO RAM to the disk along with color palette infos. If you BLOAD with ,S option, you can load such palette data to VRAM. However, such color palette info is only set into lookup table, and do not make any changes to the actually displayed colors. If you execute COLOR=RESTORE, then you can set the info inside lookup table as color palette, and you can display the picture in the same color at the time you saved with BSAVE,S.

Example:



10 SCREEN 2 20 BLOAD "BOX",S 30 COLOR=RESTORE 40 GOTO 40

See also:

COLOR=, COLOR, COLOR=NEW





COLOR=NEW


(MSX-Basic 2) Syntax: COLOR=NEW

Function:

This statement initialises the colour palette to the same state as when the power of the computer is turned on (see Color-table). It is a good idea to place this statement at the beginning and the end of the program.

Example:



COLOR=NEW

See also:

COLOR=, COLOR, COLOR=RESTORE





CALL MEMINI


(MSX-Basic 2) Syntax: CALL MEMINI [(size)]

Function:

This statement specifies the amount of memory to be used as a RAM disk, initialises the RAM disk, and deletes all files. When the RAM disk is to be used, this statement should always be executed.

Size is "the amount of memory to be used as RAM disk minus 1". By default, the maximum size is allocated for RAM disk. "CALL MEMINI(0)" causes the RAM disk feature to be disabled.

Example:



CALL MEMINI(&H3FFF)

See also:

CALL MFILES, CALL RAMDISK RAM-Disk in MSX-Basic 2, RAM-Disk in Disk-Basic 2, RAM-Disk in MSX-DOS 2





CALL MKILL


(MSX-Basic 2)

Syntax: CALL MKILL("filename")

Function:

This statement deletes the specified file.

Example:



See also:

KILL, CALL MNAME





CALL MNAME


(MSX-Basic 2)

Syntax: CALL MNAME ("old filename" AS "new filename")

Function:

This statement renames the specified file.

Example:



See also:

NAME, CALL MKILL





CALL MFILES


(MSX-Basic 2)

Syntax: CALL MFILES

Function:

This statement displays file names on the RAM disk.

Example:



See also:

FILES, LOAD, CALL MEMINI





SET PAGE


(MSX-Basic 2) Syntax: SET PAGE [visible][,work]

Function:

This statement allows users to set the page to display and the page to read and write data to.

This is valid when the screen mode is greater than 4, and the value specified depends on the VRAM capacity and the screen mode:

Screen mode VRAM 64K VRAM 128K

SCREEN 5 0 to 1 0 to 3

SCREEN 6 0 to 1 0 to 3

SCREEN 7 Unusable 0 to 1

SCREEN 8 Unusable 0 to 1

SCREEN 10 Unusable 0 to 1

SCREEN 11 Unusable 0 to 1

SCREEN 12 Unusable 0 to 1

Example:



See also:

BSAVE,

BLOAD, COPY,

SCREEN





SET VIDEO 2

See also:

COPY SCREEN





SET ADJUST


(MSX-Basic 2)

Syntax: SET ADJUST(x,y)



Function:

This statement sets the location to display on the screen. The coordinate offset is from -7 to 8.

Example:



SET ADJUST(0,0)

See also:

SET SCROLL





SET BEEP


(MSX-Basic 2) Syntax: SET BEEP timbre, volume Function:

This statement sets BEEP sound. Timbre and volume are from 1 to 4. The table below shows the correspondance of timbre and to the actual sound.

Timbre Sound

1 High tone beep (same as MSX1)

2 Low tone beep

3 2 - tone beep

4 3 - tone beep

Example:



See also:

BEEP





SET TITLE


(MSX-Basic 2) Syntax: SET TITLE "greeting" [, color]

Function:

This statement specifies the title and the colour of the initial screen at system startup. The title is set by a string of up to 6 characters and color is one of the values listed below. When title is 6 characters, keyboard input is awaited just after the title screen is displayed.

Color Screen color

1 Blue

2 Green

3 Red

4 Orange

Example:



SET TITLE "Hello"

See also:

SET PROMPT, SET PASSWORD





SET PASSWORD


(MSX-Basic 2) Syntax: SET PASSWORD "password"

Function:

This statement sets a system password. Password is a string expression up to 255 characters. Once this statement is done, input of the password is requested for invoking the system. When the correct password is given, the system is normally invoked; otherwise, correct password input is requested. When the system is invoked by pressing both graphic key and stop key, no password input is requested (in this case, the password setting has been done by the key cartridge; however, password input is always required for system startup). The password is disabled by specifying a null character in SET TITLE.

Example:



See also:

SET TITLE, SET PROMPT





SET PROMPT


(MSX-Basic 2)

Syntax: SET PROMPT "prompt"

Function:

This statement sets the prompt. Prompt can have up to 6 characters.

Example:



SET PROMPT "Ready"

See also:

SET PASSWORD, SET TITLE





SET SCREEN


(MSX-Basic 2) Syntax: SET SCREEN

Function:

This statement records the current parameters of the "SCREEN" statement. At the system startup, they are automatically set. Items to be recorded are the following:



Screen number of text mode

Key click switch

Screen width of text mode

Printer option

Foreground, background, and border colours

Cassette baud rate

Function key switch

Display mode



Example:



See also:

SCREEN, WIDTH





SET DATE


(MSX-Basic 2)

Syntax: SET DATE "date" [,A]

Function:

This statement sets date to timer. The form of parameter and option is the same as "GET DATE". When option A is specified, the alarm date is set.

Example:



SET DATE "85/03/23"

See also:

GET DATE, SET TIME





SET TIME


(MSX-Basic 2) Syntax: SET TIME "time" [,A]

Function:

This statement sets the time to the timer. The form of parameter and option is the same as "GET TIME".

e.g.) SET TIME "22:15:00"

When option A is specified, the alarm time is set.

Example:



See also:

SET DATE, GET TIME





GET DATE


(MSX-Basic 2) Syntax: GET DATE string-variable [,A]

Function:

This statement is for reading the date from the timer and assigning it to the string variable. The format of date to be read is as follows:

Japanese: YY/MM/DD (YY = lower two digits of year, MM = month, DD = day)

e.g. 85/03/23 (March 23, 1985)

International: MM/DD/YY (YY = lower two digits of year, MM = month, DD = day)

e.g. 03/23/85 (March 23, 1985)

Korean: DD/MM/YY (YY = lower two digits of year, MM = month, DD = day)

e.g. 23/03/85 (March 23, 1985)

When option A is specified, the alarm date is read. Example:



GET DATE D$ PRINT D$

See also:

GET TIME, SET DATE, CALL GREG





GET TIME


(MSX-Basic 2) Syntax: GET TIME string-variable [,A]

Function:

This statement is for reading time from the timer and assigning it to a string variable. The form of time to be read is as follows:

HH:MM:SS(HH = hour, MM = minute, SS = second)

e.g. 22:15:00(22 hours 15 minutes 0 seconds) When A is specified, the time for the alarm time is read.

Example:



GET TIME T$ PRINT T$

See also:

GET DATE, SET TIME, TIME, CALL TIME





RAM-Disk


(MSX-Basic 2)

CALL MEMINI

CALL MFILES

CALL MKILL

CALL MNAME



Note: the MSX2 RAM-Disk can not store binary files. All data is stored in ASCII-mode. See also: RAM-Disk in Disk-Basic 2, RAM-Disk in MSX-DOS 2





SET SCROLL


(MSX-Basic 3) Syntax: SET SCROLL [x ] [,y]

Function:

Performs horizontal and vertical scrolling of the screen-contents in graphic-mode.



This is a MSX2+ only command and supports the hard scroll of the V9958. <X coordinate> is between 0 and 511, <Y coordinate> is between 0 and 255. Leftmost 8 dots part of the screen is not displayed if the <left mask> is 1, displayed if this value is 0. If the <2 page sequential> is 1, two sequential pages (for instance 0 and 1) are treated as a horizontally connected page or if this value is 0, the scroll takes place only in a single page. To execute 2 page sequential display, the display page must be a odd numbered page. The hard scroll can be done only with SCREEN 1 and later, and 2 page sequential display can be done only with SCREEN 5 and later.

Notes:

Under screen 0 mode 0-7 is specifyable as X-distance. If 0 (or omitted), horizontal scroll does not happen. If a value between 1 and 7 is specified, 1 causes 7 pixels, 2 causes 6 pixels, ... 7 causes 1 pixel of scroll to right. 0 to 7 is specifiyable as Y-distance. If 0 (or omitted), vertical scroll does not happen. If a value between and 7 is specified, 1 causes 1 pixel, 2 causes pixels, ... 7 causes 7 pixels of scroll to up. "Vertical scroll" does not move displayed characters themselves, but instead causes scrolling inside each of the horizontal character rows.

After scrolling, (if horizontal scroll was specified) entire displayed screen is displaced to X-axial direction and (if vertical scroll was) character patterns are scrolled Y-axially inside each of the rows. Scrolled positions return to initial conditions if you re-set the screen mode by using SCREEN statement.

Example:



SET SCROLL ,1

See also:

SET ADJUST





CALL PAUSE


(MSX-Basic 4) Syntax: CALL PAUSE(time)

Function:

Stops execution of BASIC program for the specified time. The unit of the pause time is millisecond. When the CALL PAUSE is being executed, interrupt is enabled. Even when the CALL PAUSE is being executed, you can quit the program by the CTRL + STOP keys. This command is used when you want to take a timing without being affected by the CPU execution speed.

Example:



CALL PAUSE(1000)

See also:



NOTE: the Chakkari Copy cartridge provides also a CALL PAUSE statement, which performs a different function.





CALL PCMPLAY


(MSX-Basic 4)

Syntax: CALL PCMPLAY(@startaddr, endaddr, samplerate, ramtype [,S])

CALL PCMPLAY(arrayname, [length], samplerate)

CALL PCMPLAY(@start address, end address, sampling rate) for playing from the main RAM CALL PCMPLAY(@start address, end address, sampling rate,S) for playing from the VRAM CALL PCMPLAY(array variable name, [length], sampling rate) for playing from array variables

Function:

Play a PCM sound.

Treats the contents of either the main RAM or the VRAM as a PCM data and plays it by the specified sampling frequency.

- Sampling rate

Specifies the sampling rate.

Sampling rate Meaning (KHz)

0 15.75

1 7.875

2 5.25

3 3.9375

- Length

You can omit this. If you omit, all of the contents of the array variable is played.

The format of the data is absolute binary and 1 to 255 is a normal data. 0 is a special data and causes 0 level (127) to be outputted by a number of the cycles specified by 1 byte proceeding the 0.

Caution

If the mode is Z80 mode, the mode is automatically switched to the R800 mode before the execution, and after finishing the Z80 mode is restored. If the STOP key is pushed during the playing, the program execution is quit and returns to BASIC.

Be careful that in the MSX-BASIC, the hexadecimal number you can express with &H is a four digit number between &H000 and &HFFFF and that &H8000 to &HFFFF are the negative numbers. This does not cause any problem when main RAM is specified but requires caution when VRAM is specified. For instance, to play 64KB part in the latter half of the VRAM, you must specify like,

CALL PCMPLAY(@65536,131071,2,S)

(131071=65536x2-1). If you specify like,

CALL PCMPLAY(@&H10000,&H1FFFF,2,S)

this results in "Overflow" error. On the other hand,

CALL PCMPLAY(&HFFFF+1,&1FFFFx2+1,2,S)

(Translator's note: This is obviously typo of CALL PCMPLAY(&HFFFF+1,&1FFFF*2+1,2,S) )

results same with CALL PCMPLAY(@0,&HFFFF,2,S) since &HFFFF+1=-1+1=0 and &HFFFx2+1=-1x2+1=&HFFFF .

Example:



CALL PCMPLAY(@&HB000,&HDFFF,1)

See also:

CALL PCMREC





CALL PCMREC


(MSX-Basic 4)

Syntax: CALL PCMREC(@start address, end address, sampling rate,[,[trigger level][,compression switch]])

for recording to the main RAM

CALL PCMREC(@start address, end address, sampling rate, [trigger level], [compression switch],S)

for recording to the VRAM

CALL PCMREC(array variable name, [length],sampling rate[,[trigger level][, compression switch]])

for recording to array variables



Function:

Records sounds as PCM.

Samples sound by the PCM method and by the specified frequency, and records in either main RAM, VRAM or array variable.



- Sampling rate

Specifies the sampling rate.

Sampling rate Meaning (KHz)

0 15.75

1 7.875

2 5.25

3 3.9375

- Trigger level

Specifies the input level when starting the recording. The range of this value is 0 to 127. If this is omitted or is 0, the recording is started immediately.

- Compression switch

Specifies whether or not to execute the silent data compression.

Value Meaning

Omitted Does not compress

0 Does not compress

1 Compress

The format of the data is absolutely binary and 1 to 255 is normal data. When two or more data near the 0 level (126 to 128) are consecutive, the data can be compressed by recording a 0 and count of the consecutive data. This compression is called silent data compression.

Caution

If the mode is Z80 mode, the mode is automatically switched to the R800 mode before the execution, and after finishing the Z80 mode is restored. If you specify the sampling rate to 15.75 KHz under Z80 mode or R800 ROM mode, you get "Illegal function call" error. Note if the STOP key is pushed during the playing, the program execution is quit and returns to BASIC. When recording to the VRAM, be careful with the address you specify, in the same way with CALL PCMPLAY.

Example:



CLEAR 300,&HB000 CALL PCMREC(@HB000,&HDFFF,1,32,1)

See also:

CALL PCMPLAY





Disk (Basic)





The following statements/functions are new and/or extended in Disk-Basic:





BLOAD

BSAVE

COPY

CVI

CVS

CVD

DSKF

DSKI$

DSKO$

ERR

ERROR

FIELD

FILES

GET

INPUT

KILL

LFILES

LOAD

LOC

LOF

LSET

MERGE

MKI$

MKS$

MKD$

NAME

OPEN

PRINT

PUT

RSET

RUN

SAVE

CALL FORMAT

CALL SYSTEM



Since Disk-Basic 2 following commands were added:





CALL CHDRV

CALL CHDIR

CALL MKDIR

CALL RMDIR

CALL RAMDISK



See also: RAM-Disk in MSX-DOS 2





MSX-Audio (Basic)


The MSX-Audio is a rarely sold cartrige, which was replaced by MSX-Music (lower quality). The Philips Music Module is hardware-compatible to the MSX-Audio, but has no MSX-Audio basic (the Music Module uses a separate firmware ROM).

The firmware of both cartridges (MSX-Audio and Music-Module) can be bypassed by pressing ESC during startup.

CALL AUDIO



See also:

MSX-Music, CALL MUSICBOX





MSX-Music (Basic)


The MSX-Music is available in the FM-PAC, the FM STEREO PAK and since MSX 2+ (optional) and MSX-Turbo R. The following MSX-Basic commands are supported by FM-Basic:



CALL MUSIC

CALL BGM

CALL PITCH

CALL TEMPER

CALL TRANSPOSE

PLAY

CALL PLAY

CALL STOPM

CALL VOICE

CALL VOICE COPY

CALL AUDREG



See also: MSX-Audio





RS232 (Basic)


CALL COMINI

CALL COMDTR

CALL COMSTAT

CALL COMBREAK

CALL COMTERM

CALL COM

CALL COMON

CALL COMOFF

CALL COMSTOP

CALL COMHELP



See also: RTS/DTR control, XON/XOFF control





Kanji (Basic)


Kanji-Basic is available since MSX-DOS 2.20 and MSX Turbo-R's

CALL PALETTE

CALL CLS

CALL AKCNV

CALL JIS

CALL SJIS

CALL KACNV

CALL KEXT

CALL KINSTR

CALL KLEN

CALL KMID

CALL KNJ

CALL KTYPE

CALL KANJI

CALL KANJI0

CALL KANJI1

CALL KANJI2

CALL KANJI3

CALL ANK





Hangul (Basic)


Hangul ROM's are managing Korean Kanji.

CALL HANON

CALL HANOFF



New since Version 2:

CALL ADJUST

SCREEN 9 mode





Arabic (Basic)


Arabic MSX-computers were found to have following extensions:





CALL OPTIONS

CALL CALENDAR

CALL GPRINT

CALL ARB0

CALL ARB1

CALL ARB2

CALL ENGL

CALL LATIN

CALL RECON

CALL NOCON

CALL INDVAL

CALL ARBVAL

CALL DCOLOR

CALL PRESORT

CALL PRESEND

CALL COMPRESS

CALL ASTR

CALL ESTR

CALL FNKEY

CALL HCOPY

CALL CHCOPY

CALL SPAINT

CALL VPRINT

CALL TIME

CALL GREG

CALL HIJRI

CALL TOHIJRI

CALL TOGREG

CALL ARABIC

CALL ARABON

CALL ARABOFF





Firmware extension:



CALL MENU





Reserved keywords (Basic)


Following keywords are reserved on all MSX machines. These keywords can be use to extend the MSX-Basic funtionality:

ATTR$

CMD

IPL

FPOS





Turbo-Basic compiler


The Turbo-Basic compiler is a separately sold cartridge. It can be found in MSX2+ Sanyo machines too. It is also known as KUN-Basic or X-Basic. The following additional commands are provided:

CALL TURBO ON

CALL TURBO OFF

CALL RUN

CALL BC (in MSX-2+ Sanyo only)





DIR


(MSX-DOS)

Format: DIR [/H] [/W] [/P] [compound-filespec]

Purpose:

Displays the names of files on disk.

Use:

The compound-filespec specifies which files are to be 	listed. If the /H option is given, then hidden files will 	also be listed.

In the DIR command, unlike all other commands, it is 	permissible to not give the main filename or the filename 	extension, and both will default to '*'. Thus a filename of 	'FRED' is equivalent to 'FRED.*' and a filename of '.COM' is 	equivalent to '*.COM'. Note that if the '.' at the end of a 	main filename is given, then the extension is also assumed 	to have been given, so that the filename 'FRED.' is not 	equivalent to 'FRED.*', unlike the example above.

There are two formats of the listing. If the /W option 	is given, then a 'wide' listing is printed, with several 	filenames output per line. Sub-directory names, file 	attributes, and the date and time each file was created are 	not displayed.

If the /W option is not given, then the filenames are 	printed with one filename per line, together with the 	attributes, the file size and the date and time at which the 	file was last modified. The attributes are printed as an 'r' 	if the file is read-only and an 'h' if the file is hidden 	(and /H is given). If the time of a file is zero (i.e. the 	file does not have an associated time) then the time field 	will not be printed. If the date of a file is zero, then 	neither the date nor the time fields will be printed. The 	formats in which the dates and times are printed in can be 	changed (see HELP DATE and HELP TIME).

The non-/W display is designed to fit within a 40 	column screen, but if fewer columns are available then some 	fields of the listing will not be shown so that the display 	will always fit on one line. The number of files per line 	that are printed when /W is specified is also adjusted 	according to the screen width. If the width of the display 	is less than 13 characters however, then in both cases the 	filenames will wrap to the next line.

At the top of the list of files, the volume name of the 	disk and the name of the directory being listed is 	displayed. At the bottom, the number of files listed, the 	total number of bytes in the files and the amount of 	remaining disk space is printed.

When the directory of a sub-directory is printed, the 	first two items listed will always be two special 	sub-directories called '.' and '..'. These are automatically 	created when a new directory is created, and it is these 	that allow '.' and '..' to be given in path names to signify 	the current and parent directories respectively (see HELP 	SYNTAX for a description of paths).

When printing a number of bytes, the number is 	truncated and printed as the number of kilobytes if 1K or 	greater.

If the /P option is given, then the output will pause 	at the bottom of the screen until a key is pressed.

Examples:



DIR

	 All filenames and directory names in the current 	directory of the current drive will be printed. This might 	be as follows: Volume in drive A: is MSX-DOS 2 	 Directory of A:\ 	 MSXDOS2 SYS r 4096 86-06-19 2:45p 	 COMMAND2 COM r 10496 86-06-19 2:46p 	 UTILS <dir> 86-06-19 2:50p 	 HELP <dir> 86-06-19 2:50p 	 14K in 2 files 222K free

	The disk thus contains the two MSX-DOS system files 	MSXDOS2.SYS and COMMAND2.COM, which are read only, and two 	directories called UTILS and HELP. DIR B:\HELP/W

	 A 'wide' directory format has been requested of the 	HELP directory on drive B:. This might be as follows: Volume in drive B: is MSX-DOS 2 	 Directory of B:\HELP 	 BUFFERS .HLP ATTRIB .HLP ASSIGN .HLP 	 ATDIR .HLP CHDIR .HLP CD .HLP 	 SYNTAX .HLP ENV .HLP BATCH .HLP 	 EDITING .HLP 	 25K in 10 files 222K free



DIR UTILS + HELP/P

	 This will list all the files in the UTILS directory and 	all the files in the HELP directory, and will pause at the 	end of every screen full. DIR .COM

	 No main filename was given, and so defaults to *. Thus 	this command is equivalent to the command DIR *.COM. DIR COMMAND2

	 No extension was given, so this defaults to .*. Thus 	this command is equivalent to the command DIR COMMAND2.*.





COPY


(MSX-DOS)

Format: COPY [/H] [/P] [/A] [/B] [/V] [/T] source dest

Purpose:

Copies data from files/devices to other files/devices.

Use:

The definition of the source is:

compound-filespec

The compound-filespec specifies the files or devices that 	are to be copied. If /H is given then hidden files may be 	copied.

The definition of the dest is:

[d:][path][filename] | device

where d: and path default to the current drive and directory 	respectively. If any part of the filename is ambiguous then 	the appropriate character from the source filename is 	substituted, thus allowing the files to be renamed in the 	process. If the filename is not given, then the entire 	source filename is used. If the dest is an unambiguous 	directory, then the files are copied into that directory 	with a filename of *.*.

COPY will read as many source files as possible into 	memory before writing any out. When it can read no more into 	memory (eg. when it has used all available memory) it will 	write out each file in the order that it read them. When it 	creates each destination file, it prints the source file- 	name. Then if it is unable to create the destination file, 	an error message is printed and the copy operation continues 	with the next file. /P can be given to make the output pause 	at the end of the screen.

Many reasons exist for COPY to be unable to create the 	destination, such as a read-only file already existing with 	the same name. Sometimes COPY will refuse to create the 	destination because the user may have made a mistake. For 	example, a file cannot be copied onto itself, or several 	files cannot be copied onto one file. A 'Cannot create 	destination' error may be given if the destination of one 	file would delete a previous source file or a file already 	being used for something else (eg. the currently executing 	batch file). A 'Cannot overwrite previous destination file' 	error results if an attempt is made to copy many files to 	one file. This usually means that the intended destination 	was a directory, but that the name has been misspelled.

If /A is specified, then an ASCII copy is performed. 	This means that source files will only be read as far as the 	first end-of-file character (CTRL-Z) and then each 	destination will have a single end-of-file character 	appended to it.

It is also possible to give a /A to the destination or 	to any of the filespecs in the compound-filespec separately, 	in which case it applies only to that source or dest 	specification. Also /B may be given to reverse the effect of 	/A.

The /V option can be given to turn write verification 	on for the duration of the COPY command (see the VERIFY 	command). This will ensure that data is written correctly to 	disks but will slow the operation down.

Normally, the destination files are given the same date 	and time as the source files. However, the /T option can be 	given to cause the destination files to have the current 	date and time. The destination files will not be hidden or 	read-only, regardless of the attributes of the source files. 	The ATTRIB command can be used to change these.

If COPY gives a 'Not enough memory' error then probably 	reducing the number of buffers (see the BUFFERS command) or 	removing some environment items (see HELP ENV on Environment 	Items) will free up sufficient memory.

Note that the COPY command is simpler than that in MS- 	DOS and MSX-DOS 1 because it cannot concatenate (join 	together) files. To do this, a CONCAT command is available 	(see the CONCAT command).

Examples:



COPY FILE1 B:

	 The file FILE1 is copied from the current directory of 	the current drive to the current directory of drive B:. COPY /H MSXDOS2.SYS + COMMAND2.COM B:

	 The two hidden files MSXDOS2.SYS and COMMAND2.COM are 	copied to drive B:, thus making it a booting disk. COPY A:\DIR1 B:\DIR1 /V

	 All files in the directory DIR1 from the root of drive 	A: are copied to a similar directory on drive B: with verify 	on to ensure that the files were written correctly. COPY B:

	 All files in the current directory of drive B: are 	copied to the current directory of the current drive. COPY /A AUX CON

	 Characters are read from the device AUX (which may be 	used for RS232 serial for example) to the device CON, which 	is the screen. The copy is done as far as the first end-of- 	file character. If /A was not given, then there may have 	been no way of stopping the COPY operation without pressing 	the CTRL-STOP key. COPY A:*.DOC B:/T

	 All files matching *.DOC (for example FILE1.DOC, 	FILE2.DOC and FILE3.DOC) are copied to the current directory 	of drive B: and are given the current date and time instead 	of the dates and times of the *.DOC files. COPY *.BAT 	AUTOEXEC.BAT -- File cannot be copied onto itself 	REBOOT.BAT -- File cannot be copied onto itself

	 This command told COPY to copy all files matching *.BAT 	(in this case AUTOEXEC.BAT and REBOOT.BAT) from the current 	directory of the current drive to the same place, and COPY 	printed the messages to warn of this. No data in this case 	was actually copied. COPY *.BAT DIR2 	AUTOEXEC.BAT 	REBOOT.BAT -- Cannot overwrite previous destination file

	 This command told COPY to copy all files matching *.BAT 	(in this case AUTOEXEC.BAT and REBOOT.BAT) to a directory 	called DIR2. DIR2, however, did not exist so AUTOEXEC.BAT 	was copied to a file called DIR2, and then an attempt was 	made to copy REBOOT.BAT also to a file called DIR2. The 	message was printed as a warning that a mistake was probably 	made (in this case DIR2 not existing). REBOOT.BAT was not 	actually copied anywhere.





TYPE


(MSX-DOS)

Format: TYPE [/H] [/P] [/B] compound-filespec | device Purpose:

Displays data from a file or device.

Use:

	The compound-filespec specifies the files that are to 	be displayed, and /H allows hidden files to be typed. If the 	compound-filespec is ambiguous, then the filename is printed 	before each one is typed.

If /B is specified, then data is read from each file 	and displayed without modification on the screen, until the 	end of file is reached. This may have strange effect on the 	screen if the file contains control characters.

If /B is not given, then TYPE will look for the end-of- 	file character (CTRL-Z) and stop when it finds it. Also 	control characters except carriage return, line feed and tab 	will be converted into a '^' symbol followed by that control 	letter so that they will be visible on the screen. 	 If /P is given, then the output will pause at the end 	of the screen until a key is pressed.

Examples:



TYPE FILE1

	 Data is read from the file and printed on the screen, 	up to the first end-of-file character. TYPE *.BAT/H/P

	 All batch files, including hidden ones, are read in and 	displayed. A prompt is printed at the end of every screen 	full. TYPE AUTOEXEC.BAT + REBOOT.BAT

	 The files AUTOEXEC.BAT and REBOOT.BAT are displayed. TYPE /B DIR1

	 All files in the directory DIR1 are printed on the 	screen and no interpretation is put on the data in the 	files. TYPE AUX

	 Data is read from the AUX device (which may be, for 	example, an RS232 serial device) up to the first end-of-file 	character and printed on the screen.





RENAME


(MSX-DOS)

Format: RENAME [/H] [/P] compound-filespec filename

REN [/H] [/P] compound-filespec filename

Purpose:

Renames one or more files.

Use:

	The compound-filespec specifies the files that are to 	be renamed, and /H allows hidden files to be included in the 	rename operation.

The second filename specifies the new name for the 	files. A '?' in the new name indicates that the 	corresponding character from the filename being renamed will 	be used, thus allowing an ambiguous rename. Thus '*' in the 	second filename, which is just equivalent to a series of 	'?'s, indicates that the whole of the filename or extension 	will remain unchanged.

If for some reason a particular file cannot be renamed 	(eg. if a file or directory with the new name already 	exists) then the offending filename will be printed along 	with an error message and the rename operation will continue 	with the next file. If many errors occur, then /P will cause 	the output to pause at the end of the screen.

Examples:



RENAME FILE1 FILE2

	 The file FILE1 in the current directory of the current 	drive is renamed to FILE2. REN B:\DIR1\*.DOC/H/P *.OLD 	FILE2.DOC -- File exists

	 All files matching *.DOC in the directory called DIR1 	in the root directory of drive B:, including hidden files, 	are renamed with the same main name but with an extension of 	.OLD. The file FILE2.DOC could not be renamed because there 	was already a file called FILE2.OLD in the directory, so the 	error was printed. Neither FILE2.DOC nor FILE2.OLD was 	altered at all. If many such errors had been printed, then a 	prompt would have been printed at the bottom of every screen 	full. REN DOC + FILE1 *.OLD

	 All files in the directory called DOC and the file 	FILE1, both in the current directory of the current drive, 	and renamed with an extension of .OLD.





DEL


(MSX-DOS)

Format: DEL [/H] [/P] compound-filespec

ERA [/H] [/P] compound-filespec

ERASE [/H] [/P] compound-filespec

Purpose:

Deletes one or more files.

Use:

	The compound-filespec specifies which files are to be 	deleted. The /H option allows hidden files to also be 	deleted.

During the delete operation, if a file cannot be 	deleted for some reason (eg. it is set to 'read only') then 	the offending filename is printed along with an error 	message, and the delete operation continues with the next 	file. If many such errors occur, then the /P option will 	cause the output to pause at the end of the screen.

If the filename is *.*, then the prompt: Erase all files (Y/N) ? 	is printed, and a reply is waited for. If the reply is 	anything other than 'Y' or 'y', then the file deletion does 	not take place. This is a safety feature designed to prevent 	accidental loss of all files in a directory.

If files are deleted unintentionally on a disk that was 	formatted under MSX-DOS 2, then the UNDEL command may be 	used immediately afterwards to restore them again.

Examples:



ERASE FILE1.BAK

	 The file FILE1.BAK is deleted from the current 	directory of the current drive. DEL *.COM/H

	 All files matching *.COM, both hidden and not hidden, 	are deleted. DEL B:\UTIL\*.COM + B:\UTIL\*.BAT

	 All files matching *.COM or *.BAT are deleted from the 	directory called UTIL on drive B:. DEL B:\UTIL 	Erase all files (Y/N)?

	 All files in the directory called UTIL on drive B: are 	deleted. Since so many files are being deleted, a prompt is 	printed first to prevent a catastrophe. DEL *.BAT 	AUTOEXEC.BAT -- Read only file 	REBOOT.BAT -- Read only file

	 All files matching *.BAT are deleted except for 	AUTOEXEC.BAT and REBOOT.BAT which have been marked as read 	only.





DATE


(MSX-DOS)

Format: DATE [date]

Purpose:

Displays or sets the current date.

Use:

	If the date is given after the command, then the date 	is set to this value (for the format see below). If the date 	is not given after the command, then the current day and 	date is printed and the new date is prompted for and input. 	If no input is given (i.e. if the 'enter' key alone is 	pressed) then the current date is not altered. Otherwise the 	input is assumed to be a new date, and is interpreted as 	described below. If the date is invalid then an error 	message is displayed and the new date again prompted for and 	input.

The date is expected to consist of up to three numbers, 	separated by one of the following characters:

space tab , - . / :

with spaces allowed either side of the character. Any 	missing numbers will default to the current setting. The 	year may either be a full century and year, or may be just 	the year in which case the century defaults to 19 if the 	year is greater than 80 or 20 otherwise.

The format in which the date is printed and input is 	flexible and can be changed. An environment item called DATE 	is set up by default to a format that is appropriate for the 	country of origin of the MSX machine (see HELP ENV on 	Environment Items). For example, on Japanese machines the 	default setting is YY-MM-DD. The command SET DATE DD-MM-YY 	will change the date format to the UK format. The format 	also affects the dates printed by the DIR command.

If the DATE environment item is defined, then it will 	be printed by the DATE command to indicate the format in 	which the date is required to be input.

Examples:



DATE 86-6-18

	 The current date is set to the 18th June 1986. DATE 	Current date is Wed 1986-06-18 	Enter new date (yy-mm-dd): - -19

	 No parameter was given, so the current date of 18th 	June 1986 was printed and a new date prompted for. In the 	reply to the prompt, the date was updated to the next day by 	only specifying the 19th. Since the year and month were not 	given, they remained the same. SET DATE = DD/MM/YY

	 The date format has been changed to the UK format. DATE 	Current date is Thu 19-06-1986 	Enter new date (DD/MM/YY):

	 No parameter was given, so the current date of 19th 	June 1986 was printed in the UK format, and the prompt 	printed. The reply is expected in the UK format.





TIME


(MSX-DOS)

Format: TIME [time]

Purpose:

Displays or sets the current time.

Use:

	If the time is given after the command, then the time 	is set to this value (for the format see below). If the time 	is not given after the command, then the current time is 	printed and the new time is prompted for and input. If no 	input is given (i.e. if the 'enter' key alone is pressed) 	then the current time is not altered. Otherwise the input is 	assumed to be a new time, and is interpreted as described 	below. If the time is invalid then an error message is 	displayed and the new time again prompted for and input.

The time is expected to consist of up to four numbers, 	separated by one of the following characters:

space tab , - . / :

with spaces allowed either side of the character. Any 	missing numbers will default to the current setting. The 	first number is the hour, the second is the minutes, the 	third is the seconds and the forth is the centi-seconds. The 	centi-seconds are not printed however since it is not very 	useful to know the current value, or indeed to enter a new 	one.

The format in which the time is printed is flexible and 	can be changed. An environment item (see HELP ENV on 	Environment Items) called TIME is set up by default to the 	value '12', which indicates that the time will be printed in 	12 hour format with a following 'a' or 'p' for am and pm. 	The command SET TIME 24 will cause the time to be printed in 	24 hour mode. The time can be input unambiguously in either 	format. The time format also affects the times printed by 	the DIR command.

Examples:



TIME 16:45

	 The current time is set to 4:45 pm. TIME 	Current time is 10:45:58a 	Enter new time:

	 No parameters were given, so the current time is 	printed (in this case in 12 hour mode) and the new time 	prompted for. TIME 10-50-30-23

	 The time is set to 30.23 seconds after 10:50 am.





PAUSE


(MSX-DOS) Format: PAUSE [comment]

Purpose:

Prompts and waits for a key press in a batch file.

Use:

	The comments consists of an arbitrary sequence of 	characters.

The comment, if given, is printed followed by the 	prompt 'Press any key to continue... ' on the next line. The 	system will then wait for a key to be pressed and will echo 	the key pressed if it is a printable character. If no 	comment is given as a parameter, then just the prompt will 	be printed.

The main use of this command is to issue prompts from 	within a batch file.

Examples:



PAUSE 	Press any key to continue...

	 No comment was given, so just the prompt was printed. PAUSE Insert document disk in drive B: 	Insert document disk in drive B: 	Press any key to continue

	 The comment given was 'Insert document disk in drive 	B:' so this was printed followed by the prompt.





REM


(MSX-DOS) Format: REM [comment]

Purpose:

Introduces a comment in a batch file.

Use:

	The comment is simply ignored, and the next command 	executed. The comment consists of a sequence of any 	characters up to the maximum length of a command line (127 	characters).

Examples:



REM This is my AUTOEXEC batch file

	 This command, either in a batch file or typed in, does 	nothing at all with it's parameters.





VERIFY


(MSX-DOS) Format: VERIFY [ON | OFF]

Purpose:

Displays/sets the current disk write verify state.

Use:

	If no parameters are given, then the current verify 	state is displayed on the screen.

If ON or OFF is given, then the verify state is changed 	appropriately.

The verify state affects all writes to disk. If OFF, 	the default state, then data is simply written. If ON, then 	after writing the data it is read back and compared with the 	original to ensure that it was written correctly. The extra 	overhead of this means that writing is slower when verify is 	on.

Examples:



VERIFY 	VERIFY=OFF

	 No parameters were given, so the current verify 	state is printed, which in this case is off. VERIFY ON

	 Disk write verification is turned on.





MODE


(MSX-DOS) Format: MODE number

Purpose:

Changes the number of characters/line on the screen.

Use:

The number must be in the range 1 to 80 inclusive, and 	the number of characters per line on the screen will be set 	to this. The screen will be cleared and the cursor moved to 	the top left corner in the process.

Examples:



MODE 80

	 The screen is set to 80 column mode and is cleared in 	the process.





BASIC


(MSX-DOS) Format: BASIC [program]

Purpose:

Transfers control to MSX disk BASIC.

Use:

	Program is the name of a BASIC program on disk.

Control is passed to the built-in MSX BASIC, which will 	load and execute the BASIC program if specified. If a RAM 	disk has been set up, then it can still be used from BASIC.

The BASIC command _SYSTEM("command") can be used to 	return to MSX-DOS, and the optional command, which can be 	any command mentioned in this manual, will be executed. If 	the command is not given, then a batch file called 	REBOOT.BAT will be searched for and executed (see HELP 	BATCH on Batch Files).

Examples:



BASIC

	 MSX disk BASIC is entered. BASIC MYPROG.BAS

	 MSX disk BASIC is entered, and the BASIC program 	MYPROG.BAS loaded and RUN.





FORMAT


(MSX-DOS) Format: FORMAT [d:]

Purpose:

Formats (initializes) a disk.

Use:

	The specified or default drive is formatted, and all 	data on the disk will be destroyed.

After giving a FORMAT command, an option may be 	prompted for, allowing the required format of the disk to be 	selected. The exact nature of these prompts depends on the 	manufacturer of the MSX machine.

After formatting, there will be no files or directories 	on the disk, and the maximum amount of disk space will be 	free. The disk will not have a volume name, but can be given 	one with the VOL command. To turn the disk into a boot disk 	so that MSX-DOS can be started up from it, the files 	MSXDOS2.SYS and COMMAND2.COM must be copied onto it with the 	COPY command.

Examples:



FORMAT B: 	1 - Single sided 	2 - Double sided 	? 2 	All data on drive B: will be destroyed 	Press any key to continue...

	 The command was given to format the disk in drive B:. 	In this case, the options available were to select either 	double sided or single sided, and double sided was selected. 	The standard warning prompt was then printed. FORMAT

	 This will format the current drive after the prompts 	given above.





RAMDISK


(MSX-DOS 2) Format: RAMDISK [number[K]] [/D]

Purpose:

Displays or sets the RAM disk size.

Use:

If no parameters are given, then the current RAMDISK size is displayed as the number of kilobytes.

The number, if given, specifies the maximum size for the new RAM disk, and is specified in kilobytes. The range is 0 to 4064. If the number is 0 or only /D is specified, the RAM disk will be deleted. This number will be rounded up to the nearest multiple of 16K since the RAM disk is always a multiple of 16K. A RAM disk smaller then the specified maximum size may be created if there is not enough free memory for the full size, although a 'not enough memory' error will be given if there is no memory at all available for the RAM disk. Note that the number specified is the maximum amount of RAM to use for the RAM disk, which is not the same as the maximum amount of free space available on the newly-created RAM disk since the system needs to use some for FAT or directories.

On MSX machines with 128K RAM, the maximum amount of RAM disk is 32K.

If a RAM disk already exists before a new one is created, then a 'Destroy all data on RAM disk (Y/N)?' prompt is printed to avoid accidental loss of data. /D can be given which will automatically delete any existing RAM disk first, thus suppressing the prompt.

Having created a RAM disk, it can be referred to as drive H:.

The RAMDISK command is normally only used in an AUTOEXEC.BAT batch file, with a large number specified so that as large a RAMDISK as possible is created. It is not advisable to keep any data on a RAM disk except for a short length of time that is not also kept on a floppy disk, since it will be lost if, for example, the power to the computer fails. Examples:



RAMDISK RAMDISK=160K

No parameters were given, so the current size is printed, in this case 160K. RAMDISK *** RAM disk does not exist

No parameters were given but no RAM disk has been created, so the error is given. RAMDISK = 300 Destroy all data on RAM disk (Y/N)? y

A RAM disk already existed, so the prompt was printed. In this case, the reply was 'y' so the current RAM disk was deleted and the new one set up with a maximum size of 300K. See also:

CALL RAMDISK, RAM-Disk in MSX-Basic 2, RAM-Disk in Disk-Basic 2, RAM-Disk in MSX-DOS 2





MSX-DOS keys




KeyFunction

Ctrl+P Printer protocol on

Ctrl+N Printer protocol off

Ctrl+C

Ctrl+Stop Abort the running program

Ctrl+J Moves the cursor to the beginning of the next line.

This has impact to the display only but does not affect the input-data.



Ctrl+S Pauses the screen-output (similar to STOP in Basic).

Backspace Same as Cursor-Left



See also:

MSX-DOS





RAM-Disk


(MSX-DOS 2)

RAMDISK



See also: RAM-Disk in MSX-Basic 2, RAM-Disk in Disk-Basic 2





UZIX introduction




What is the UZIX?

UZIX: UNIX IMPLEMENTATION FOR MSX based on UZI written by Douglas Braun and ported to MS-DOS / MSX by Archi Schekochikhin and Adriano Rodrigues da Cunha.

UZIX is an implementation of the UNIX kernel written for a MSX/PC computer. It implements almost all 7th Edition AT&T UNIX kernel functionality. UZIX was written to run on PC (under MS DOS) or MSX2/2+/TR. The source code is written mostly in C, and was compiled with Turbo-C (PC) or Hitech-C (MSX). UZIX's code was based on public domain Doug Braun's UZI, which was written from scratch, and contains no AT&T code, so it is not subject to any of AT&T's copyright or licensing restrictions.

UZIX implements almost all of the 7th Edition functionality. All file I/O, directories, mountable file systems, user and group IDs, pipes, and applicable device I/O are supported. The number of processes is limited only by the swap space available, with a maximum of 31 processes (total of 1024k memory). UZIX implements UNIX well enough to run the Bourne Shell in its full functionality.





UZIX technical information




How it works:

UZIX uses MSX2 memory mapper to achieve multiprocessing. On PC UZIX use additional PC memory for swapping. In both cases UZIX use 64K of virtual address space (full Z80 space or one full segment on PC). UZIX itself occupies the upper 32K of address space, and the currently running process occupies the lower 32K.

UZIX does need some additional hardware support. First, UZIX uses system clock that provide a periodic interrupt. Also, the current implementation uses an additional real-time clock to get the time for file timestamps, etc. The current TTY driver assumes an polling-driven buffered keyboard, which should exist on most systems.

How UZIX is different than real UNIX:

Again, UZIX implements almost all of the 7th Edition AT&T UNIX functionality. All file I/O, directories, mountable file systems, user and group IDs, pipes, and applicable device I/O are supported. Process control (fork(), execve(), signal(), kill(), pause(), alarm(), and wait()) are fully supported. The number of processes is limited only by the swap space available, with a maximum of 31 processes (total of 1024k memory). As mentioned above, UZIX implements UNIX well enough to run the Bourne Shell in its full functionality. The only changes made to the shell's source code were to satisfy the limitations of the C compiler.

Here is a (possibly incomplete) list of missing features and limitations:

	The debugger- and profiler-related system calls do not exist.





	The supplied TTY driver is bare-bones. It supports only one port.





	Inode numbers are only 16-bit, so filesystems are 32MB or less.





	File dates are not in the standard format. Instead they look like those used by MS-DOS.





	The 4.2BSD execve() was implemented. Additional flavors of exec() are supported by the library.





	The necessary semaphores and locking mechanisms to implement reentrant disk I/O are not there. This would make it harder to implement interrupt-driven disk I/O without busy-waiting.



Developer notes:

MSX UZIX can be compiled with any ANSI-compatible C compilers. The only true one for MSX is Hitech-C (CP/M version) and MS-DOS Hitech-C (cross-compiler). MSX UZIX was written using MS-DOS Hitech-C. You'll find many constructions and functions not supported (and also limitations) by MSX-DOS Hitech-C or other MSX C compilers if you try compiling UZIX with them. Of course UZIX can be compiled using other compiler than MS-DOS Hitech-C, but it will requires a lot of changes in the source code.

MSX UZIX can't be compiled for running on a MSX1, since it uses Memory Mapper for multitasking, system real-time clock for file timestamps, and 80-column screen. Of course, is possible doing a "light" MSX UZIX for MSX1, with a fake real-time clock (software emulated by the kernel), using a 40-column display and other memory device (such as MegaRAM) for multitasking, but it's not the target of this release.

This release of MSX UZIX can handle a maximum of 31 processes. It could handle up to 127 processes (4Mb RAM), but it's nonsense a single user running so many processes at a time. That's why this limit of 31 concurrent processes.





CALL BPRINT


(Chakkari Copy) Syntax: CALL BPRINT

Function:

Prints a hardcopy of the screen contents in all MSX1 screen modes (0-3).

It's the same operation as pressing the COPY button on the Chakkari Copy cartridge.

Note: if the screen mode cannot be auto-detected Chakkari Copy must be started with pressed COPY button. In this case all screen-parameters for later capture can be entered manually.

Example:



CALL BPRINT

See also:





CALL PAUSE


(Chakkari Copy) Syntax: CALL PAUSE

Function:

Puts the Chakkari Copy cartridge into PAUSE mode. In this mode it's only possible to print a hardcopy by pressing the COPY button or to resume execution by pressing the PAUSE button.

It's the same operation as pressing the PAUSE button on the Chakkari Copy cartridge.

Note: the paused program can only be resumed by pressing the PAUSE button. It cannot be resumed by software.

Example:



CALL PAUSE

See also:



IMPORTANT NOTE: the MSX-Turbo R provides also a CALL PAUSE statement, which usually supersedes this functionality. It performs another function and has a different syntax.





CALL SCHANGE


(Chakkari Copy)

Syntax: CALL SCHANGE

Function:

In case the PAUSE and COPY buttons of the Chakkari Copy cartridge don't work the CALL SCHANGE statement restores this functionality. Most common use is for MSX-Basic programs (when MSX-Basic is started the buttons on the Chakkari Copy cartridge will not work).

The CALL SCHANGE command is also available on function-key "Shift+F5" and will be removed after executing it once.

CALL SCHANGE works only if the cartridge is in COPY mode!!! This statement has no effect while in RAM mode.

Details: if, for some reason, the COPY and PAUSE buttons do not work the CALL SCHANGE command restores this functionality.

It switches the MSX BIOS (page 0) from slot 0 to a patched copy within the slot, where the Chakkari Copy cartridge is inserted. The patched copy is read-only and initialized while booting the system with Chakkari Copy inserted into any slot.

NOTE: Because of a programming issue in this cartridge the ROMSLT (&HFFF7) is not updated. Therefore, depending on executed MSX programs, the BIOS patch might loose it's effect.

Another bug prevents correct function-key reassignment for "Shift+F5" on MSX2 and later machines (works on MSX1 only). So the CLS+"run" command is not available by pressing Shift+F5 on such computers.

Example:



CALL SCHANGE

See also:





LSET MKI$(I)

See also:

CHR$, MKS$, MKD$, ASC, CVI, CVS, CVD





LSET MKS$(S)

See also:

CHR$, MKI$, MKD$, ASC, CVI, CVS, CVD





LSET MKD$(D)

See also:

CHR$, MKI$, MKS$, ASC, CVI, CVS, CVD





LOC


(Disk-Basic, RS232-Basic) Syntax: LOC( channel )

Function:

Returns the current recordnumber in the opened file as #channel.

Example:



100 OPEN "ADRESS.DAT" AS #1 LEN=66 110 FIELD #1, 15 AS NA$, 15 AS ST$, 20 AS OT$, 16 AS TE$ 120 SN=LOF(1)/66 130 FOR I=1 TO SN 140 GET #1 150 PRINT "Record";LOC(1) 160 PRINT TAB(5);NA$ 170 PRINT TAB(5);ST$ 180 PRINT TAB(5);OT$ 190 NEXT 200 PRINT "Finished" 210 CLOSE

See also:

FIELD, GET, PUT, OPEN, CLOSE, EOF, LOF





LOF


(Disk-Basic, RS232-Basic)

Syntax: LOF( <filenumber> )

Function:

LOF returns the filesize (LengthOfFile) in bytes.

Example:



10 INPUT "Filename: "; FI$ 20 OPEN FI$ FOR INPUT AS #1 30 PRINT LOF(1) "Bytes" 40 CLOSE

See also:

OPEN, CLOSE, EOF, LOC





VDP(9)=VDP(9) OR &H20

VDP(9)=VDP(9) AND &HDF





10 SCREEN 8


20 FOR B=0 TO 3

30 FOR R=0 TO 7

40 FOR G=0 TO 7

50 C=4*R+32*G+B

60 LINE (X,0)-(X,211),C,BF

70 X=X+1:NEXT G,R,B

80 A$=INPUT$(1)

+--------+----------+----------+----------+----------+----------+----------+----------+----------+

| Byte 0 | brightn. | brightn. | brightn. | brightn. | Palette | green | green | green |

+--------+----------+----------+----------+----------+----------+----------+----------+----------+

| Byte 1 | brightn. | brightn. | brightn. | brightn. | Palette | blue | green | green |

+--------+----------+----------+----------+----------+----------+----------+----------+----------+

| Byte 2 | brightn. | brightn. | brightn. | brightn. | Palette | red | red | red |

+--------+----------+----------+----------+----------+----------+----------+----------+----------+

| Byte 3 | brightn. | brightn. | brightn. | brightn. | Palette | blue | red | red |

+--------+----------+----------+----------+----------+----------+----------+----------+----------+

+--------+----------+----------+----------+----------+----------+----------+----------+----------+

| Byte 0 | brightn. | brightn. | brightn. | brightn. | brightn. | green | green | green |

+--------+----------+----------+----------+----------+----------+----------+----------+----------+

| Byte 1 | brightn. | brightn. | brightn. | brightn. | brightn. | blue | green | green |

+--------+----------+----------+----------+----------+----------+----------+----------+----------+

| Byte 2 | brightn. | brightn. | brightn. | brightn. | brightn. | red | red | red |

+--------+----------+----------+----------+----------+----------+----------+----------+----------+

| Byte 3 | brightn. | brightn. | brightn. | brightn. | brightn. | blue | red | red |

+--------+----------+----------+----------+----------+----------+----------+----------+----------+





CALL CLS


(Kanji-Basic) Delete all the contents in the screen during Japanese input mode.

Syntax: CALL CLS

_CLS

Function:

You must use this command to clear away the screen once you enter Japanese input mode by using CALL KANJI command.

CLS statement may not wok properly in Japanese input mode.

Example:

See also:

CLS





Error-codes


(MSX-Basic, Disk-Basic)

The following error-codes are used by the ERROR statement and ERR function.





Error Message

1 NEXT without FOR

2 Syntax error

3 RETURN without GOSUB

4 Out of DATA

5 Illegal function call

6 Overflow

7 Out of memory

8 Undefined line number

9 Subscript out of range

10 Redimensioned array

11 Division by zero

12 Illegal direct

13 Type mismatch

14 Out of string space

15 String too long

16 String formular too complex

17 Can´t CONTINUE

18 Undefined user function

19 Device I/O error

20 Verify error

21 No RESUME

22 RESUME without error

23 Unprintable error

24 Missing operand

25 Line buffer overflow



Disk-Basic: following additional ERRORs are defined:



Error Message

50 FIELD overvlow

51 Internal error

52 Bad file number

53 File not found

54 File already open

55 Input past end

56 Bad file name

57 Direct statement in file

58 Sequential I/O only

59 File not OPEN

60 Bad FAT

61 Bad file mode

62 Bad drive name

63 Bad sector number

64 File still open

65 File already exists

66 Disk full

67 Too many files

68 Disk write protected

69 Disk I/O error

70 Disk offline

71 Rename across disk



See also: ERR,

ERROR





GET


(Disk-Basic) Syntax: GET #channel [, recordnumber]

Function:

Reads a record from a file. If recordnumber is not specified GET reads the next one from the file.

Example:



100 OPEN "ADRESS.DAT" AS #1 LEN=66 110 FIELD #1, 15 AS NA$, 15 AS ST$, 20 AS OT$, 16 AS TE$ 120 SN=LOF(1)/66 130 FOR I=1 TO SN 140 GET #1 150 PRINT 160 PRINT TAB(5);NA$ 170 PRINT TAB(5);ST$ 180 PRINT TAB(5);OT$ 190 NEXT 200 PRINT "Finished" 210 CLOSE

See also:

FIELD, PUT, LSET, RSET, OPEN





FILES


(Disk-Basic) Syntax: FILES ["pattern"][,L]

Function:

Lists the contents of (the current directory on) the diskette. If the disk is empty or the pattern does not match any existing file a "File not found error" is generated.

All files in the file-listing are using 8 characters for the filename, a dot (.) and 3 characters for the extension.

Disk-Basic 2: the Parameter "L" can be added to display the list of files in long format.

Example:



FILES

Shows all files on the standard-drive (usually A:) FILES "B:" Shows all files on drive B: FILES "*.BAS"

Shows all files with the extension ".BAS" FILES "*.*"

Works as FILES without pattern. See also:

LFILES, LOAD, BLOAD, CALL MFILES, DSKF





LSET


(Disk-Basic) Syntax: LSET <stringvariable> = <string-expression> Function:

Assigns a value to a variable, which is defined by the FIELD statement. Is the result of the string-expression shorter as specified in the FIELD statement the string will be stored left-aligned, the rest is filled with spaces. If the result is larger only the number of fitting characters is saved.

Example:



LSET NA$ = "Peter Pan" -> "Peter Pan " RSET NA$ = "Peter Pan" -> " Peter Pan" LSET NA$ = "Carlo Kautschuk" -> "Carlo Kautschuk" RSET NA$ = "Carlo Kautschuk" -> "Carlo Kautschuk" LSET NA$ = "Ludwig van Beethoven" -> "Ludwig van Beet" RSET NA$ = "Ludwig van Beethoven" -> "Ludwig van Beet"

See also:

RSET, MID$, FIELD, GET, PUT





RSET


(Disk-Basic) Syntax: RSET <stringvariable> = <string-expression> Function:

Assigns a value to a variable, which is defined by the FIELD statement. Is the result of the string-expression shorter as specified in the FIELD statement the string will be stored right-aligned, the rest is filled with spaces. If the result is larger only the number of fitting characters is saved.

Example:



LSET NA$ = "Peter Pan" -> "Peter Pan " RSET NA$ = "Peter Pan" -> " Peter Pan" LSET NA$ = "Carlo Kautschuk" -> "Carlo Kautschuk" RSET NA$ = "Carlo Kautschuk" -> "Carlo Kautschuk" LSET NA$ = "Ludwig van Beethoven" -> "Ludwig van Beet" RSET NA$ = "Ludwig van Beethoven" -> "Ludwig van Beet"

See also:

LSET, MID$, FIELD, GET, PUT





PLAY #2, "CD", "EF", "GA"

PLAY#2,"","","","BSH8H8H8S!H!8H8"

Bass, snare,hihat and wait an 8th note. Hi hat and wait an 8th note. snare, hi hat plays accented and waits an 8th note. Hi hat and wait an 8Th note. See also:

PLAY (MSX-Basic), CALL PLAY, CALL VOICE, CALL VOICE COPY, CALL BGM, MSX-Music Voices





USING


(MSX-Basic)





The syntax of the USING clause in the MSX-Basic PRINT/LPRINT statement

may differ between various implementations:



Generic / all versions

"!" Indicates that only the 1st character of the expression will be printed

10 A$="Europe"

20 PRINT USING "!";A$

30 END

RUN

E

Ok

"#" Numerical expressions can be printed as following:

USING "#" indicates how many characters of the expression should be printed.

If the expression has less numbers than the number of positions MSX-Basic

inserts preceding spaces.

If the expression has more characters as the number of positions the expression

is preceded by a percent (%) character.

If necessary MSX-Basic rounds the value.



10 A=109:B=7:C=1198

20 PRINT USING "###";A,B,C

30 END

RUN

109 7%1198

Ok

"." Indicates where the decimal point should be printed.

Only one decimal point is allowed.



10 A=10.21:B=5.5:C=.245:D=3

20 PRINT USING "##.##";A,B,C,D

30 END

RUN

10.21 5.50 0.25 3.00

Ok

"," If a comma is placed on the left side of the decimal point

then every 3rd character will be preceded by a comma (e.g. thousands place).

If a comma is placed on the end of the format then the command is printed

immediately after the output.



10 B=1234.5

20 PRINT USING "####,.##";

30 PRINT USING "####.##,";

40 END

RUN

1,234.50

1234.50,

Ok

"+" Indicates that a positive expression should be indicated by a plus (+) character

and negative expression should be indicated by a minus (-) character.

If the plus character is the first element in the print format,

then the character is printed first. If the plus is placed on the end of the

format then it's printed immediately after the value.



10 A=1.25:B=-1.25

20 PRINT USING "+#.##";A,B

30 PRINT USING "#.##+";A,B

40 END

RUN

+1.25-1.25

1.25+1.25-

Ok

"-" This symbol can only be used at the end of the print-format.

It results in a space after a positive expression and a minus (-)

after a negative expression.



10 A=1.25:B=-1.25

20 PRINT USING "#.##-";A,B

30 END

RUN

1.25 1.25-

Ok

"**" The both asteriks can only be used on the start of the print-format.

It replaces leading zeros by asterisks.



10 A=10.25:B=1.25:C=-1.25

20 PRINT USING "**#.##";A,B

30 END

RUN

*10.25**1.25*-1.25

Ok

"^^^^" This symbol can only be used on the end of a print-format.

It results in an exponential display of the expression.

The decimal point can be placed somewhere. The first position

is the space, except a plus or minus is specified in the format.



10 A=12.35

20 PRINT USING "##.##^^^^";A

30 PRINT USING "#.##^^^^-";C

40 PRINT USING "+#.##^^^^";B,C

50 END

RUN

2.35E+02

1.23E+01-

+1.23E+01-1.23E+01

Ok

Japanese



"& &" Indicates that the number of characters to be printed is 2 plus the number

of spaces between & and &.

Note: International machines are supporting "\ \" instead.



10 A$="Japanese"

20 PRINT USING "& &";A$

30 END

RUN

Japan

Ok

"@" Indicates that instead of the "@" symbol the value of

the variable should be printed.

Note: International machines are supporting "&" instead.



10 A$="I":B$="MSX"

20 PRINT USING "@ love @";A$,B$

30 END

RUN

I love MSX

Ok

"¥¥" The both yen (¥) signs can only be used on the start of the print-format.

It results in a leading yen-character of the output.

Note: Interational machines are supporting "$$" to display the dollar ($) sign instead.



10 A=12.35:B=-12.35

20 PRINT USING "¥¥###.##";A,B

30 PRINT USING "¥¥###.##-";A,B

40 END

RUN

¥12.35 -¥12.35

¥12.35 ¥12.35-

Ok

"**¥" This symbol can only be used on the start of the print-format.

It is a combination of the prior formats.

Note: Interational machines are supporting "**$" to use the dollar ($) sign instead.



10 A=12.35

20 PRINT USING "**¥#.##";A

30 END

RUN

*¥12.35

Ok

International



"\ \" Indicates that the number of characters to be printed is 2 plus the number

of spaces between \ and \.

Note: Japanese machines are supporting "& &" instead.



10 A$="Europe"

20 PRINT USING "\ \";A$

30 END

RUN

Euro

Ok

"&" Indicates that instead of the "&" symbol the value of

the variable should be printed.

Note: Japanese machines are supporting "@" instead.



10 A$="I":B$="MSX"

20 PRINT USING "& love &";A$,B$

30 END

RUN

I love MSX

Ok

"$$" The both dollar ($) signs can only be used on the start of the print-format.

It results in a leading dollar-character of the output.

Note: Japanese machines are supporting"¥¥" to display the yen (¥) sign instead.



10 A=12.35:B=-12.35

20 PRINT USING "$$###.##";A,B

30 PRINT USING "$$###.##-";A,B

40 END

RUN

$12.35 -$12.35

$12.35 $12.35-

Ok

"**$" This symbol can only be used on the start of the print-format.

It is a combination of the prior formats.

Note: Japanese machines are supporting "**¥" to use the yen (¥) sign instead.



10 A=12.35

20 PRINT USING "**$#.##";A

30 END

RUN

*$12.35

Ok

See also:

PRINT,

LPRINT





PUT


(Disk-Basic)

Syntax: PUT #channel [, recordnumber]

Function:

Writes a record into a file. If recordnumber is not specified PUT writes the next one into the file.

Example:



10 OPEN SUPERDAT.DAT" as #1 LEN=66 20 PUT#1, 2000 30 PRINT "The file has now a size of";LOF(1);"Bytes" 40 CLOSE

These records can be read with GET, even if no data was inserted. Which bytes are really read depends on the history of the disk. Unused records on new formatted disks are filled with CHR$(229). They may also contain parts of already deleted files. To initialize all records the following code is recommended: 10 OPEN "SUPERDAT.DAT" AS #1 LEN=66 20 FIELD #1, 66 AS X$ 30 LSET X$=STRING$(66,229) 50 FOR I=1 TO 2000 60 PUT #1, I 70 NEXT 80 CLOSE

See also:

FIELD, GET, LSET, RSET, OPEN





CALL RUN


(Turbo-Basic compiler)

Syntax: CALL RUN

Function:

This command compiles and executes the entire program on memory. If it finds an error it will stop and yield the message.

Example:



CALL RUN

See also:

CALL TURBO ON, CALL TURBO OFF, RUN





Screen-modes


Correspondances of BASIC screen (SCREEN) modes and VDP screen modes





BASIC

mode VDP

mode Meaning



Dots or characters Display colours at a time Screen format

SCREEN 0 (1) TEXT 1 40 x 24 chars 2 from 512 Text

SCREEN 0 (2) TEXT 2 80 x 24 chars 2 from 512 Text

SCREEN 1 GRAPHIC 1 32 x 24 chars 16 from 512 Text

SCREEN 2 GRAPHIC 2 256 x 192 dots 16 from 512 High res. graphics

SCREEN 3 MULTICOLOUR 64 x 48 dots 16 from 512 Low res. graphics

SCREEN 4 GRAPHIC 3 256 x 192 dots 16 from 512 High res. graphics

SCREEN 5 GRAPHIC 4 256 x 212 dots 16 from 512 Bit map graphics

SCREEN 6 GRAPHIC 5 512 x 212 dots 4 from 512 Bit map graphics

SCREEN 7 GRAPHIC 6 512 x 212 dots 16 from 512 Bit map graphics

SCREEN 8 GRAPHIC 7 256 x 212 dots 256 Bit map graphics

SCREEN 9* GRAPHIC 5 80 x 24 chars 4 from 512 Text

SCREEN 10 Graphic 8 256 x 212 dots A lot + 16 from 512 Bit map graphics

SCREEN 11 Graphic 8 256 x 212 dots A lot + 16 from 512 Bit map graphics

SCREEN 12 Graphic 9 256 x 212 dots 19268 Bit map graphics





*SCREEN 9: only implemented in Korean MSX2 computers to display Korean KANJI characters.

This mode is not implemented in the normal MSX-BIOS but part of the Hangul-ROM.

This screen-mode is quite curious, but available in the normal MSX2 Video-processor (V9938) too.

The effective VDP-mode is GRAPHIC 5 (SCREEN 6) with some specific settings (see table below).

The only difference to other MSX-machines is the support of this mode by BIOS routines.

In fact SCREEN 9 has the following properties:



Property Value Notes

Resolution 80 x 24 characters can be adjusted by the WIDTH statement

512 x 384 dots interlaced (2*192 lines)

Characters 6*16 pixels are read from the Kanji-ROM, which (may?) need to be present

Text color green (3) Text color is effectively set to 15 (white), but GRAPHIC 5 mode uses only the

lower 2 bits therefore the value of the displayed color is 3.



Background color black (1)

Border color black (1)

Sprites disabled

Note: when activating SCREEN 9 the system automatically changes the used colors. When leaving SCREEN 9 and

returning to another screen-mode the changed colors remain valid.





Interlace-mode


Differences of display function in the interlace mode

Interlace mode Display function

0

Normal non-interlaced display (default)

1

Interlaced display

2

Non interlaced, Even/Odd alternate display

3

Interlaced, Even/Odd alternate display

See also: SCREEN, SET PAGE





CALL KANJI


(Kanji-Basic)

Activates the Kanji text-mode.

This mode supports high-resolution Kanji-characters and is provided by MSX-DOS 2.20 and the Kanji-Basic.

Once the Kanji-mode is activated you can use also graphic-modes to output/input text as in all other text-modes. The SCREEN-command switches between all modes as normal, but does not deactivate the Kanji-mode.

Due to this some Basic-statements/functions are not working properly and will return an error. These statements/functions have new equivalents in Kanji-Basic which must be used instead. Use CALL ANK to deactivate the Kanji-mode.

By executing this command, certain memory domain will be allocated for Japanese processing. At this point, himem address setting specified by CLEAR statement will be negated, and all variables and stacks (for FOR-NEXT and GOSUB/RETURN statements) will return to default.

You can use single-kanji conversion option if MSX-JE is not installed, renbunsetsu (sequential segments) conversion option if installed. See MSX-JE section for details.

Press Ctrl+Space simultaneously to activate input of extended characters. In this mode the lower bar in bottom of screen is displayed in reverse colors, entered characters are displayed in double width. This mode can be exited by pressing Ctrl+Space again.

CALL KANJI or _KANJI

CALL KANJI0 or _KANJI0 32x13

CALL KANJI1 or _KANJI1 40x13

CALL KANJI2 or _KANJI2 32x24

CALL KANJI3 or _KANJI3 34x24

In case of CALL KANJI (or CALL KANJI0), the font is taken from the standard kanji ROM of the MSX and is displayed.

In case of CALL KANJI1, the font is taken from the standard kanji ROM of the MSX then the horizontal 16 dots are compressed to 12 dots then are displayed. Note if the Matsushita specification 12 dot font ROM exists in the system, this font is displayed.

In the case of CALL KANJI2, it is same with CALL KANJI (or CALL KANJI0) but the interlace mode is used and the number of characters displayed vertically increases.

If the MSX standard Japanese front end processor (hereafter “MSX-JE”) exits, it is either installed when the CALL KANJI statement is executed or when the system is started. The direct entry mode (ANK) and the indirect entry mode (kanji) can be toggled by CTRL + SPCAE or GRAPH + SELECT. If the MSX-JE does not exist, you can use single kanji conversion function.

You must be careful when the CALL KANJI is executed for the first time after starting the MSX. The HIMEM setting (set by a CLEAR command) at that time becomes canceled and all variables and software stacks (for FOX/NEXT, GOSUB/RETURN) become cleared. This occurs before a process that allocates th work area of the kanji driver (and of the MSX-JE if existent) is executed. No problem occurs when CALL KANJI is executed second time and latr.

The mode where the CALL KANJI statement or similar has been is executed and kanjis may be displayed is called the “kanji mode”. To be more precise, the condition when the kanji mode is set and also SCREEN command has set 0 or 1 is called the “kanji text mode”, while the condition when the kanji mode is set and also SCREEN command has set a 2 or higher screen mode is called the “kanji graphic mode”.

The BASIC command prompt condition is in the kanji text mode and kanjis can be entered and outputted. Under the kanji graphic mode, kanjis can be only outputted.



WIDTH under kanji mode

- Kanji text mode

The WIDTH after executing CALL KANJI is decided as follows based on the WIDTH under the ANK mode. You can directly specify using SCREEN command and WIDTH command after executing CALL KANJI.

- KANJI0 or KANJI2

4/5 of the WIDTH value under the ANK mode becomes the WIDTH under the kanji text mode.

- KANJI1 or KANJI3

The WIDTH value under the ANK mode becomes the WIDTH under the kanji text mode as is.



2. If SCREEN 1 ws used under the ANK mode

- KANJI0 or KANJI2

The WIDTH value under the ANK mode becomes the WIDTH under the kanji text mode as is.

- KANJI1 or KANJI3

5/4 of the WIDTH value under the ANK mode becomes the WIDTH under the kanji text mode.

- Kanji graphic mode

Maximum displayable number is always set.





SCREEN mode selection by WIDTH

- KANJI0 or KANJI2

The 256 dot mode (GRAPHIC 4 mode of the VDP) is selected if WIDTH is between 26 and 32, while the 512 dot mode (GRAPHIC 6 mode of the VDP) is selected if between 33 and 64.

- KANJI1 or KANJI3

The 256 dot mode (GRAPHIC 4 mode of the VDP) is selected if WIDTH is between 26 and 40, while the 512 dot mode (GRAPHIC 6 mode of the VDP) is selected if between 41 and 80.

See also:

MSX-JE





CALL ANK


(Kanji-Basic)

Quit Japanese input mode.

Syntax: CALL ANK

_ ANK

Function:

Deactivates the Kanji text-mode activated by CALL KANJI. However, execution of this command does not release memory which was allocated for kanji driver through CALL KANJI statement.

See also:

MSX-JE





CALL AUDREG


(MSX-Music) Syntax: CALL AUDREG( register, data ) Function:

This command writes data directly into the registers of the FM-chip. register is the register-number. Valid values are 0 to 7, 14 to 24, 32 to 40 and 48 to 56. data is the data of 8 bit size and has a valid range from 0 to 255.

Example:



CALL AUDREG(3, 15)

See also:

SOUND (MSX-Basic), CALL MUSIC





CALL PALETTE


(Kanji-Basic) Specify display color to a palette during Japanese input mode.

Syntax:

CALL PALETTE(palette no.,red lumincance,green luminance,blue luminance) _PALETTE(palette no.,red lumincance,green lumincance,blue luminance) Palette no.: 0 to 15. Numerical constant, variable, array variable or expression.

Red/green/blue luminance: 0 to 7. Integer constant.

Function:

You must use this command to specify colors in Japansese input mode. COLOR= statement is disabled in Japanese input mode.

If you omit all parameters (execute simply CALL PALETTE), all palettes return to default.

Example:

CALL PALETTE(15,4,4,4)

See also:

COLOR=





CALL RAMDISK


(Disk-Basic 2)

Syntax: CALL RAMDISK[([number][, variable name])]

Function:

Set size of RAM disk or assign it into a variable.

The number, if given, specifies the maximum size for the new RAM disk, and is specified in kilobytes. The range is 0 to 4064. If the number is 0 the RAM disk will be deleted. This number will be rounded up to the nearest multiple of 16K since the RAM disk is always a multiple of 16K. A RAM disk smaller then the specified maximum size may be created if there is not enough free memory for the full size, although a 'not enough memory' error will be given if there is no memory at all available for the RAM disk. Note that the number specified is the maximum amount of RAM to use for the RAM disk, which is not the same as the maximum amount of free space available on the newly-created RAM disk since the system needs to use some for FAT or directories.

Having created a RAM disk, it can be referred to as drive H:.

Example:



CALL RAMDISK(32) CALL RAMDISK(1000, A)

See also:

CALL MEMINI





RAM-Disk


(Disk-Basic 2)

CALL RAMDISK



See also: RAM-Disk in MSX-Basic 2, RAM-Disk in MSX-DOS 2





KILL


(Disk-Basic)

Syntax: KILL <pattern>

Function:

Deletes the file(s) specified in pattern.

Example:



KILL "TEST.$$$

KILL "*.$$$"

KILL "B:*.BAK"

See also:

CALL RMDIR, CALL MKILL, COPY, NAME





NAME


(Disk-Basic) Syntax: NAME "oldname" AS "newname"

Function:

Renames the file named oldname to newname. If a file named newname already exists a "File already exists" error occurs.

oldname and newname can be fully qualified filenames, including drive-letter. Wildcards can be included too.

Example:



NAME "TEST.BAS" AS "TEST.BAK"

See also:

CALL MNAME, COPY, KILL





COPY


(MSX-Basic 2)

Syntax:

COPY (X1,Y1) - (X2,Y2)[, <source page>] TO (X3,Y3)[, <destination page> [, <logical operation>]] COPY (X1,Y1) - (X2,Y2)[, <source page>] TO {<array variable name> | <filename>} COPY {<array variable name> | <filename>}[, <direction>] TO (X3,Y3) [, <destination page>[, <logical operation>]] COPY <filename> TO <array variable name> COPY <array variable name> TO <filename>

Function:

Example:

See also:

COPY (Disk-Basic), COPY SCREEN, SET PAGE





COPY SCREEN


(MSX-Basic 2)

Syntax: COPY SCREEN [<mode>]

Function:

This instruction is used to specify that a general signal must be digitized. mode indicates the mode of digitization.

This statement is used for writing data from the colour bus to VRAM, for example, after digitising. This is valid for screen modes 5 to 8.

Attention: This statement is for the superimposer or the digitiser which are optional, so it can be used only for machines which are equipped with this the 'superimpose' capability.

In mode 0, one field of signals [=1 frame] is digitised and written to the display page (that is the page reproduced on screen).

In mode 1, two successive fields (that is, one frame) of signals [=2 frames] are written to (display page - 1)th page and the display page, so the display page should be an odd page when the mode is 1.

The default mode is 0.

Example:



COPY SCREEN

COPY SCREEN 1

110 ON STOP GOSUB 210 120 STOP ON 130 SCREEN 8 140 COLOR,,255 150 SET VIDEO 1 160 COPY SCREEN 170 TIME=0 180 IF INKEY$="" GOTO160 190 IF TIME<4 GOTO 190 200 IF INKEY$="" GOTO 200 ELSE 140 210 '**STOP** 220 SET VIDEO 0,0 230 END

This program requires to push 'audio/video' button on the MSX-console. See also:

SET VIDEO, SET PAGE, COPY (MSX2-Basic), COPY (Disk-Basic)





Alarm


Since the alarm feature is optional, the action taken at the specified time depends on the machine (ordinarily nothing happens).

When the alarm is to be set in both "SET DATE" and "SET TIME", "SET TIME " should be done first (when "SET TIME" is done, date of the alarm set by "SET DATE" will be erased).

The minimum setting for alarm is in minutes (setting in seconds is ignored).





CALL GREG


(Arabic-Basic)

Syntax:

CALL GREG( <string-variable> )

Function:

Example:

GET DATE D$ PRINT D$ 12/31/99 CALL DATE(D$) PRINT D$ 31/12/1999.5

See also:

GET DATE





CALL TIME


(Arabic-Basic)

Syntax:

CALL TIME( <string-variable> )

Function:

Example:

CALL TIME(T$) PRINT T$

See also:

GET TIME





COPY


(Disk-Basic) Syntax: COPY <sourcefile> [TO <targetfile>]

Function:

COPY duplicates a file, which can also be created on a different disk.

If targetfile is not specified the sourcefile is copied to the default-drive, where the filename is not changed.

Users of a single floppy-disk drive cannot take full advantage because the COPY operation copies files sector by sector. This means that a sector on the source-disk is read, the user is prompted for a disk-change, the sector on the target-disk is written, the user is prompted again, ...

Also interesting for single users is the possibility to use pseudo-files such as "CON" and "PRN".

Example:



COPY "TEST.BAS" TO "TEST.$$$"

COPY "*.*" TO "B:"

COPY "B:*.*"

COPY "TEST.TXT" TO "PRN"

See also:

COPY (MSX2-Basic), COPY SCREEN, KILL, NAME





CVI


(Disk-Basic)

Syntax: CVI( <string> )

Function:

Converts a 2 Byte string into an integer value.

Type Length -> String -> Number

0...255 1 CHR$() ASC

INT 2 MKI$() CVI

SNG 4 MKS$() CVS

DBL 8 MKD$() CVD

Example:



I=CVI(I$)

See also:

ASC, CVS, CVD, CHR$, MKI$, MKS$, MKD$





CVS


(Disk-Basic)

Syntax: CVS( <string> )

Function:

Converts a 4 Byte string into a single-precision value.

Type Length -> String -> Number

0...255 1 CHR$() ASC

INT 2 MKI$() CVI

SNG 4 MKS$() CVS

DBL 8 MKD$() CVD

Example:



S=CVS(S$)

See also:

ASC, CVI, CVD, CHR$, MKI$, MKS$, MKD$





CVD


(Disk-Basic)

Syntax: CVD( <string> )

Function:

Converts a 8 Byte string into a double-precision value.

Type Length -> String -> Number

0...255 1 CHR$() ASC

INT 2 MKI$() CVI

SNG 4 MKS$() CVS

DBL 8 MKD$() CVD

Example:



D=CVD(D$)

See also:

ASC, CVI, CVS, CHR$, MKI$, MKS$, MKD$





DSKF


(Disk-Basic) Syntax: DSKF( drivenumber ) Function:

DSKF returns the number of free clusters on the specified drivenumber, where 1=A:, 2=B:, 3=C: and so on. If 0 is specified the free space on the default-drive is returned.

Example:



? DSKF(0)

IF DSKF(1)<100 THEN PRINT "Please insert a new disk!"

See also:

FILES, LFILES





DSKI$


(Disk-Basic)

Syntax: <stringvar> = DSKI$( <drivenumber>, <sectornumber> )

Function:

DSKI$ reads the sector sectornumber from the disk-drive specified in drivenumber (0=default, 1=A:, 2=B:, ...).

DSKI$ returns an empty string (which is historical, because sector-sizes were smaller in the past and really returned the read sector). In MSX-Basic the bytes of the read sector can be found on address:

PEEK(&HF351) + PEEK(&HF352)*256

Note: the contents of this buffer are lost as soon as another command accesses the disk again.

Example:



10 X$ = DSKI$(0,0) 20 AD = PEEK(&HF351)+PEEK(&HF352)*256 30 FOR I=0 TO 511:PRINT PEEK(AD+I);:NEXT

See also:

DSKO$





DSKO$


(Disk-Basic) Syntax: DSKO$( <drivenumber>, <sectornumber> ) Function:

DSKO$ writes the sector sectornumber on the disk-drive specified in drivenumber (0=default, 1=A:, 2=B:, ...). The sector data to be written is located on:

PEEK(&HF351) + PEEK(&HF352)*256

Note: the contents of this buffer are lost as soon as another command accesses the disk again.

Important: because DSKO$ modifies sectors on the physical disk this command should be used very careful!

Example:



See also:

DSKI$





FIELD


(Disk-Basic)

Syntax: FIELD #channel, length AS stringvariable, length2 AS stringvariable2, ...

Function:

After a file is opened and the recordlength has been specified FIELD can be used how a record is separated into single fields. Every datafield requires one entry specifying length and the name of a stringvariable. The number of fields is not limited but must not exceed the recordlength as specified in the OPEN statement.

Example:



FIELD #1, 15 AS NA$, 15 AS ST$, 20 AS OT$, 16 AS TE$

See also:

LSET, RSET, OPEN, GET, PUT





LFILES


(Disk-Basic) Syntax: LFILES ["pattern"][,L]

Function:

Prints the contents of (the current directory on) the diskette. If the disk is empty or the pattern does not match any existing file a "File not found error" is generated.

All files in the file-listing are using 8 characters for the filename, a dot (.) and 3 characters for the extension.

Disk-Basic 2: the Parameter "L" can be added to print the list of files in long format.

Example:



LFILES

Prints all files on the standard-drive (usually A:) LFILES "B:" Prints all files on drive B: LFILES "*.BAS"

Prints all files with the extension ".BAS" LFILES "*.*"

Works as LFILES without pattern. See also:

FILES, LOAD, BLOAD, CALL MFILES, DSKF





CALL FORMAT


(Disk-Basic) Syntax: CALL FORMAT

Function:

Formats a disk. The CALL FORMAT statement prompts for the drive, that contains the disk to be formatted.

If the disk-drive supports multiple disk formats the CALL FORMAT statement pompts for the disk-format to be choosen (can be e.g. single sided or double-sided disk).

Notes:

A disk must be formatted before it can be used

Formatting irreversibly destroys prior contents of the disk



Harddisk: CALL FORMAT write-protects and write-enables the selected partition of a harddisk. To create/delete and format partitions the corresponding FDISK utility (on MSX-DOS disk) has to be used. Example:



CALL FORMAT Drive name? (A,B) a 1 - Single sided, 9 sectors 2 - Double sided, 9 sectors ? 1 Strike a key when ready Format complete Ok

Note: the printed prompts might be different, depending on the used disk-controller and connected drives. CALL FORMAT Drive name? (A,B,C) A 1 - Write protect partition 2 - Write enable partition ?

See also:





CALL SYSTEM


(Disk-Basic) Syntax: CALL SYSTEM

CALL SYSTEM[("DOS command name")]

Function:

CALL SYSTEM passes the control back to MSX-DOS. The command name may be given to specify the operation to be executed after the control returns to DOS. MSX-DOS 2: If no command name is specified, REBOOT.BAT in the root directory on the boot drive, if any, will be executed.

Note: this command is only available if the computer was started in MSX-DOS mode and MSX-Basic has been entered with the BASIC command.

Example:



CALL SYSTEM

See also:

MSX-DOS





CALL CHDRV


(Disk-Basic 2)

Syntax: CALL CHDRV("driveletter")

Function:

Switch default drive.

Example:



CALL CHDRV("H:")

See also:

CALL CHDIR





CALL CHDIR


(Disk-Basic 2) Syntax: CALL CHDIR("[drive+]path") Function:

Set current directory.

Each drive has it's own current directory. This remains at the directory specified by the last CHDIR command for that drive (or at the root directory initially) until another CHDIR command is given or it cannot be found on the disk when it is accessed (because the disk has been changed, for example). It is then returned to the root directory.

Example:



CALL CHDIR("WORK")

See also:

CALL MKDIR, CALL RMDIR, CALL CHDRV





CALL MKDIR


(Disk-Basic 2) Syntax: CALL MKDIR("[drive+]path") Function:

Create new subdirectory.

The last item in the path is the name of the new sub-directory which is to be created on the current or specified drive. Thus if this is the only item in the path, the new directory is created in the current directory.

When a new directory is created, it is empty except for two special sub-directories called '.' and '..'. These are automatically created in the directory and it is these that allow '.' and '..' to be given in path names to signify the current and parent directories respectively (see chapter 3 on Notation for a description of paths).

Example:



CALL MKDIR("WORK")

See also:

CALL CHDIR, CALL RMDIR





CALL RMDIR


(Disk-Basic 2) Syntax: CALL RMDIR("[drive+]path") Function:

Remove one or more subdirectories.

In order to delete a directory, it must contain no other files or other directories except for the special '.' and '..' directories which are always contained in a directory. These are put in a new directory when it is created and cannot be removed. It is these that allow '.' and '..' to be used in path names to specify the current and parent directories respectively.

Example:



CALL RMDIR("WORK")

See also:

CALL CHDIR, CALL MKDIR, CALL MKILL





CALL MUSICBOX




(Firmware) CALL MUSICBOX activates the firmware of the Philips Music Module if bypassed by pressing ESC during startup.

Lex Lechz: the CALL MUSICBOX command is not documented in any manual and can therefore be used as "hidden" feature.





CALL MUSIC


(MSX-Music)

Syntax: CALL MUSIC[( <drum> [,0 [,n1 [,n2 [... [,n9]]]]]]]]])]

Function:

Initializes the FM-Basic. If drum is 0 then no drums will be used and 9 channels are available. If drum is 1 then drums will be used and 6 channels are available. n1 to n9 are the voices available to MSX-Music. If drums are used then only voices n1 to n6 can be used.

Examples:



CALL MUSIC( 1, 0, 2, 1, 1, 1, 1, )

Initializes the FM-Basic and requests the use of drums. The 6 channels will be assigned to the 1st 5 voices. The 1st voice gets two channels, all other voices will be assigned to one channel. This example makes use of drum (1) and therefore the maximum number of channels is 6.

If you want to use no drums or 9 voices, the used command is: CALL MUSIC( 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 )

Now it's possible to use different channels per voice. The maximum number of channels is 9.

See also:

CALL BGM, PLAY (MSX-Music)





CALL BGM


(MSX-Music) Syntax: CALL BGM( number )

Function:

Specifies, if music should be played in foreground- or background-mode.



The Extended MSX-Basic makes it possible to play music, while other Basic-commands are about to be processed. If n is 0, then it's not possible to execute other Basic-commands while music is played. But using 1 (default) this is enabled.

Examples:



10 CALL MUSIC(0, 0, 1) 20 CALL BGM(1) 30 PLAY #2,"CDEFGAB" 40 PRINT "BASIC is ready" 50 END

10 CALL MUSIC(0, 0, 1) 20 CALL BGM(0) 30 PLAY #2,"CDEFGAB" 40 PRINT "BASIC is ready now" 50 END

See also:

CALL MUSIC, PLAY (MSX-Music)





CALL PITCH


(MSX-Music) Syntax: CALL PITCH( number ) - where number is between 410 and 459

Function:

Is used to adjust the base-sound "A" to the frequency of 440Hz. Normally the frequency of "A" is 440Hz, but can be changed within a range of 410 and 459Hz by specifying n. All other notes will be adjusted accordingly.

Example:



10 CALL MUSIC(0,0,1) 20 CALL VOICE(@2) 30 PLAY #2,"A1B1" 40 CALL PITCH(459) 50 PLAY #2,"A1B1" 60 END

See also:

CALL MUSIC





10 CALL MUSIC(0,0,1) 20 CALL BGM(0) 30 CALL VOICE(@1) 40 FOR N=0 TO 21 : PRINT"Atmospere";N

50 CALL TEMPER(N) 60 PLAY #2,"CDEFGAB>C<"

70 NEXT N





80 END


See also:

CALL MUSIC





CALL TRANSPOSE


(MSX-Music) Syntax: CALL TRANSPOSE( number ) Function:

Will tranpose in units of half tones 1/100 units.

number can have values from -12799 to 12799 or a variable. However, some voices have a limited setting even through within the +-12799 range.

Default setting is 0

Examples:



CALL TRANSPOSE (100)

tranposes a half tone. See also:

CALL MUSIC





CALL PLAY


(MSX-Music)

Syntax: CALL PLAY( number, var )

number is the channel to check

var is the name of the variable to store the value in



Function:

This detimes if music is being played and returns the result as a value.

Example:



CALL PLAY(0,A):PRINT A

When number=0 if any channels are playing, the value -1 will be stored in A and 0 if no channels are playing. See also:

PLAY (MSX-Music), CALL MUSIC





CALL STOPM


(MSX-Music)

Syntax:

CALL STOPM

Function:

Stop play of BGM.

Example:



CALL STOPM

See also:

PLAY (MSX-Music), CALL BGM, CALL MUSIC





CALL VOICE


(MSX-Music)

Syntax: CALL VOICE( [@n1], [@n2], ..., [@n9] )

n1-n9 can be values from 0-63 (voice nr) or variables.

Default setting is @0

Function:

Stes what instrument is to be played by the FM sound channels. However, values without * mark and array values (refer to MSX-Music Voices) are limited to 2 when used together.

Note: The voice number can be selected from the table MSX-Music Voices table of voices numbers.

Example:



CALL VOICE(@0,@31,@32)

CALL VOICE(@0,@6,@25,@24)

CALL VOICE(,,@48)

See also:

CALL VOICE COPY, CALL MUSIC





CALL VOICE COPY


(MSX-Music)

Syntax: CALL VOICE COPY( @n1, @n2 )

n1 can be voices from 0-63 that have no * mark or array variables.

n2 can be 63 or an array variable name.

Function:

This command copies the voice data to number 63 or an array variable.

Note: choose the voice from the table MSX-Music Voices.

Example:



DIM A%(16) CALL VOICE COPY (@7,A%)

Pipe organ 1 is copied to array variable A. 10 CALL MUSIC 20 DIM K(15) 30 CALL VOICE COPY(@31, K) 40 CALL VOICE COPY(K, @63)

Copies the software-instrument BASSDRUM from the ROM into free space. On first view this does not have any useful effect. It is also possible to use CALL VOICE to copy instrument 31 from the computer directly.

More interesting is the possibility to manipulate data in the array K, which enables creation of new instruments. See also:

CALL VOICE, CALL MUSIC





CALL COMINI


(RS232-Basic)

Syntax: CALL COMINI [([<string exp.>][,[<Rx baud rate>][,[<Tx baud rate>][,[<timeout>]]]])]



<string exp.>

A string specifies the channel control parameters as described below:



"[0:][8[N[1[X[H[N[N[N]]]]]]]]" | | | | | | | | | +----------------------- Channel no. | | | | | | | | When there is more than one | | | | | | | | channel, this parameter specifies | | | | | | | | the channel number. May be omitted | | | | | | | | if the system has only one channel. | | | | | | | | The default value is "0". +------------------- Character length | | | | | | | "5" - 5 bits | | | | | | | "6" - 6 bits | | | | | | | "7" - 7 bits | | | | | | | "8" - 8 bits +----------------- Parity flag | | | | | | "E" - Even parity | | | | | | "O" - Odd parity | | | | | | "I" - Ignore | | | | | | "N" - No parity +--------------- Stop bits length | | | | | "1" - 1 bit | | | | | "2" - 1.5 bits | | | | | "3" - 2 bits +------------- XON/XOFF control | | | | "X" - do control | | | | "N" - do not control +----------- XTS/RTS handshake | | | "H" - do handshake | | | "N" - do not handshake +--------- Automatic Line Feed (Rx) | | Insert LF after CR received | | "A" - insert Line Feed in buffer | | "N" - do not insert Line Feed +------- Automatic Line Feed (Tx) | Insert LF after CR transmitted | "A" - insert Line Feed | "N" - do not insert Line Feed +----- Shift-in/Shift-out control Illegal when data length is other than 7 bits. "S" - do control "N" - do not control

<baud rate>

It is possible to set different baud rates for transmitter and receiver. The eighteen values for the baud rate are as follows:

50 75 110 134 150 300 600 1050 1200 1800 2000 2400 3600 4800 7200 9600 19200 38400

Baud rate 134 is actually 134.5. When only the receiver baud rate is specified, the baud rate for the transmitter takes the same speed as the receiver. When only the transmitter baud rate is specified, the baud rate for the receiver takes the default value.

<time out>

If CTS-RTS handshake is selected, the device driver will wait for CTS (Clear To Send) and DCD signals before sending the character. If XON/XOFF protocol is selected and an XOFF has been received, the device driver will wait for XON before sending the character (unless the character is XON/XOFF - hex 11 or hex 13). The waiting time is specified in increments of 10ms. If the time elapses, an error is returned. If the time is specified as 0, the driver waits until the correct signals are received, or <CTRL+STOP> keys are pressed.

Function:

Setup communication parameters.

Example:



CALL COMINI("0:7E1XHNNN", 600,1200,30) CALL COMINI("8N1",9600)

The fixed default values for initialisation are as follows: CALL COMINI("0:8E3XHNNN",1200,1200,0)

See also:

OPEN, CLOSE, INPUT, LINE INPUT, SAVE, LOAD, MERGE, RUN, EOF, LOC, LOF, VARPTR





CALL COMDTR


(RS232-Basic) Syntax: CALL COMDTR(["<n>:"],<expression>) Function:

Turn off DTR signal when the <expression> is zero, otherwise turn on the DTR signal.

An OPEN must be executed before this statement. The default channel number is 0.

Note: DTR signal is affected by CALL COMDTR and CALL COMINI statements.

Example:



See also:

OPEN, CALL COMINI





CALL COMSTAT


(RS232-Basic) Syntax: CALL COMSTAT(["<n>:"],<name of variable>) Function:

Read the status of the communication channel. The status returned is assigned to the varaible. Bits 0 to 7 represent the current channel status and bits 8 to 15 represent the status of the last character read from the buffer. The assignment of each of the bits is as follows:

Bit no. Description

15 Receive buffer overflow error

0 - no buffer overflow

1 - buffer overflow ... lost character

14 Time out error

0 - no time out error

1 - time out error ... no character

13 Framing error

0 - no framing error

1 - framing error ... bad character

12 Overrun error

0 - no overrun error

1 - overrung error ... lost character

11 Parity error

0 - no parity error

1 - parity error ... bad character

10 <CTRL+STOP> keys

0 - keys were not pressed

1 - keys were pressed ... no character

9 Not used, reserved

8 Not used, reserved

7 Clear To Send

0 - can send

1 - cannot send

6 Rx XON/XOFF control

0 - XON

1 - XOFF

5 Tx XON/XOFF control

0 - XON

1 - XOFF

4 Not used, reverved

3 Data Set Ready

0 - ready

1 - not ready

2 Break detect

0 - not detected

1 - detected

1 Ring indicator

0 - ringing

1 - not ringing

0 Carrier detect

0 - detected

1 - not detected

An OPEN must be executed before this statement. The default channel number is 0.



Example:



See also:

OPEN





CALL COMBREAK


(RS232-Basic) Syntax: CALL COMBREAK(["<n>:"],<expression>) Function:

Send break characters specified by <expression> to the channel specified by <n>. The range of the <expression> should be between 0 and 32767. If 0 is specified, a long break is sent (forever).

An OPEN must be executed before this statement. The default channel number is 0.

Example:



See also:

OPEN





CALL COMTERM


(RS232-Basic)

Syntax: CALL COMTERM[("<n>:")]

Function:

Enter terminal emulator mode. The channel should be closed when this statement is invoked. The following function keys have a special function in the terminal mode:



F-6: Turn on/off literal mode. In the literal mode, control characters are displayed with upper arrow and the character offset by #40H. For example character whose code is 01H is displayed as "A".

Initial mode: Literal mode off.

F-7: Toggle Half/Full duplex mode. In the Half duplex mode, characters keyed in are echoed to the screen as well as sent to the communication channel.

Initial mode: Full duplex.

F-8: Turn on/off printer echo. When the printer echo is on, all the characters sent to the screen are also sent to the printer.

Initial mode: Printer echo off.

The terminal emulator supports the MSX VT52 protocol subset.

Intel hexfiles can be downloaded with the terminal emulator. This mode is entered by two successive <ESCAPE> characters. The file format and handshaking follow the rules for these files. The machine code will be placed in memory at the addresses specified in the hexfile. In general, only download hexfiles that will be placed at addresses between hex 8000 and BASIC's top of memory.

To exit terminal emulator mode, press <CTRL+STOP> keys.

Example:



CALL COMTERM

See also:





CALL COM


(RS232-Basic) Syntax: CALL COM([<n>:],GOSUB <line number>) Function:

Set up a line number for BASIC to trap when a character is received on the communication channel.

When a trap occurs an automatic CALL COMSTOP is executed so further reception traps can not take place. The RETURN from the trap routine will automatically do a CALL COMON, unless an explicit CALL COMOFF has been performed inside the trap routine.

Even trapping only takes place when BASIC is executing a program. When an error trap (resulting from an ON ERROR statement) occurs, this automatically disables all trapping (including ERROR, STRIG, STOP, SPRITE, INTERVAL and KEY).

Example:



See also:

RETURN, CALL COMON, CALL COMOFF, CALL COMSTOP





CALL COMON


(RS232-Basic)

Syntax: CALL COMON("[<n>:]")

Function:

Enable event trapping caused by an incoming character on the communication channel.

Example:



See also:

CALL COM, CALL COMOFF, CALL COMSTOP





CALL COMOFF


(RS232-Basic)

Syntax: CALL COMOFF("[<n>:]")

Function:

Disable event trapping caused by an incoming character on the communication channel. The communication buffer is flushed.

Example:



See also:

CALL COM, CALL COMON, CALL COMSTOP





CALL COMSTOP


(RS232-Basic)

Syntax: CALL COMSTOP("[<n>:]")

Function:

Suspend event trapping caused by an incoming character on the communication channel.

Example:



See also:

CALL COM, CALL COMON, CALL COMOFF





CALL COMHELP


(RS232-Basic) Syntax: CALL COMHELP

Function:

Prints out a brief description of the parameters set by the COMINI statement on the screen.

Example:



CALL COMHELP Initialize statement options: CALL COMINI (" <device# {0,1,2...9}>: <character length {5,6,7,8}> <parity {E,O,I,N}> <stop bits {1,2,3}> <XON/XOFF {X,N}> <CTS hand-shake {H,N}> <auto LF on receive {A,N}> <auto LF on transmit {A,N}> <SI/SO {S,N}>" ,<receiver baud rate> ,<transmitter baud rate> ,<time out count> ) Default: CALL COMINI("0:8N1XHNNN",1200,1200,0)

See also:

CALL COMINI





RTS/DTR control





RTS DTR

Reset inactive active

CALL COMINI no effect active

OPEN active no effect

CLOSE inactive no effect



The RTS signal is changed in the following cases:

OPEN statement is executed - activated.





CLOSE statement is executed - inactivated.





The available space in the communication buffer is less than nn bytes and CTS-RTS handshake is enabled - inactivated.





When RTS is inactive and available space in the communication buffer becomes more than NN bytes, and CTS-RTS handshake is enabled - activated.





nn represents the minimum and NN represents the maximum buffer space occupied by data.

The DTR signal is affected by CALL COMDTR and CALL COMINI statements.





See also:

CALL COMINI, CALL COMDTR, OPEN, CLOSE,

RS232-Basic, XON/XOFF control





XON/XOFF control




XON/XOFF control protocol is implemented in a full duplex manner: that is, both equipments can be sending data simultaneously to each other, each direction is independently controlled by XON/XOFF characters.

When active, XON/XOFF control protocol filters received XON/XOFF characters (hex 11 or hex 13). When XON/XOFF are transmitted, they are also acted upon by the sender.

The condition in which XON/XOFF are sent are as follows:

XOFF sent by user - can only be cleared by XON sent by user.

XOFF sent when buffer usage is larger than NN bytes - XON sent when buffer usage falls below nn bytes.

XOFF sent when disk is active (or similar device) - XON sent when buffer usage falls below nn bytes.

XON sent when a file is opened in the channel.



Note that the XOFF mentioned in 3 above is always sent, even if already XOFF, to ensure transmission is halted, because any chracters received during disk I/O may be lost. A character successfully received whilst a file is open is always processed regardless of the XON/XOFF control state. A user XON always clears any other XOFF control state.

See also: RTS/DTR control, RS232-Basic





CALL AKCNV


(Kanji-Basic) Convert all character data to zenkaku characters, and substitue them into a character string.

Syntax:

CALL AKCNV(character variable,X$) _ AKCNV(character variable,X$) Character variable: Variable of character type.

X$: Character constant, variable, array variable or expression.

Function:

If any characters which are not zenkaku are containted in X$, this command converts them into zenkaku characters, and substitute the whole string into a character variable.

Example:



CALL AKCNV(A$,"ABC漢字ｱｲｳｴｵ"):PRINT A$ ＡＢＣ漢字アイウエオ

Among the character string given to this CALL AKCNV statement, "ABC" and "ｱｲｳｴｵ" were converted, since they were hankaku.

See also:

Zenkaku and Hankaku





CALL JIS


(Kanji-Basic) Substitue a JIS code which corresponds to first character in a character data to a numeric variable.

Syntax:

CALL JIS(character variable,X$) _ JIS(character variable,X$) Character variable: Variable of character type.

X$: Character constant, variable, array variable or expression.

Function:

If a first character in X$ is a 2-byte character, this command substitutes the JIS code (hex, 4 digits) of that character into a numeric variable.

Example:

CALL JIS(A$,"漢字"):PRINT A$ 3441

See also:

About how to access Kanji-ROM





CALL SJIS


(Kanji-Basic) Substitue a shift-JIS code which corresponds to first character in a character data to a numeric variable.

Syntax:

CALL SJIS(character variable,X$) _ SJIS(character variable,X$) Character variable: Variable of character type.

X$: Character constant, variable, array variable or expression.

Function:

If a first character in X$ is a 2-byte character, this command substitutes the SJIS code (hex, 4 digits) of that character into a numeric variable.

Example:

CALL SJIS(A$,"漢字"):PRINT A$ 8ABF

See also:

About how to access Kanji-ROM





CALL KACNV


(Kanji-Basic) Convert any character that can be converted into hankaku characters as hankaku characters, and substitue them into a character string.

Syntax:

CALL KACNV(character variable,X$) _ KACNV(character variable,X$) Character variable: Variable of character type.

X$: Character constant, variable, array variable or expression.

Function:

Characters contained in X$ will be converted as follows.

Before Conversion After Conversion

Zenkaku alphabets and numerics Hankaku alphabets and numerics

Zenkaku hiraganas Hankaku katakanas

Zenkaku katakanas Hankaku katakanas

Kanji Kanji (no conversion)

Example:

CALL KACNV(A$,"本琵のお薦めメニュー"):PRINT A$ 本琵ﾉｵ薦ﾒﾒﾆｭｰ

See also:

Zenkaku and Hankaku





CALL KEXT


(Kanji-Basic)

Extract zenkaku or hankaku characters exclusively out of a character data, and substitue them into a character string.

Syntax:

CALL KEXT(character variable,X$,option)

_ KEXT(character variable,X$,option)

Character variable: Variable of character type.

X$: Character constant, variable, array variable or expression.

Option: 0 or 1.

Function:

This command extracts only hankaku characters out of a character data if value of option is 0; only zenkaku characters if value option is 1, and substitute them into a character string.

Example:

CALL KEXT(A$,"最初はｸﾞｰ",0):PRINT A$ ｸﾞｰ

CALL KEXT(A$,"最初はｸﾞｰ",1):PRINT A$ 最初は

See also:

Zenkaku and Hankaku





CALL KINSTR


(Kanji-Basic)

Search for a certain character data among a character data, and substitute found position into a numeric variable.

Syntax:

CALL KINSTR(numeric variable,[,N],X$,Y$)

_ KINSTR(numeric variable,[,N],X$,Y$)

Numeric variable: Variable of numeric type.

N: 1 to 256. Numeric constant, variable, array variable or expression. Default=1.

X$, Y$: Character constant, variable, array variable or expression.

Function:

This command checks from which position the Y$ starts in relation to beginning of a character string X$, and substitutes the found value into a numeric variable. If you state a value for N, the search takes place from Nth character in X$.

You must use this CALL KINSTR command instead of INSTR function if the character in question is of Japanese input type.

Example:



CALL KINSTR(A,"TOKYO伯京ﾄｳｷｮｳ","ﾄ"):PRINT A 8

* If value of N is greater than length of X$, if X$ is a null string, or if Y$ is not found, then this command substitutes 0 to the numeric variable. And if Y$ is a null string, then this command substitutes 1 to the numeric variable. (However, it substitutes 0 if X$ is also a null string)





CALL KLEN


(Kanji-Basic)

Substitute number of all characters (length)/hankaku characters only/zenkaku characters only in a character data to a numeric variable.

Syntax:

CALL KLEN(numeric variable,X$[,option])

_ KLEN(numeric variable,X$[,option])

Numeric variable: Variable of numeric type.

X$: Character constant, variable, array variable or expression.

Option: 0 to 2. Default=0.

Function:

Substitute number of all characters in (length of) a character data if a value of the option is 0 or omitted, number of hankaku characters if 1, and number of zenkaku characters if 2.

You must use this CALL KLEN command instead of LEN function if the character in question is of Japanese input type.

Example:

CALL KLEN(A,"雨ﾆﾓﾏｹｽﾞ"):PRINT A 7

CALL KLEN(A,"雨ﾆﾓﾏｹｽﾞ",1):PRINT A 6

CALL KLEN(A,"雨ﾆﾓﾏｹｽﾞ",2):PRINT A 1

* A hankaku accent will be counted as an independent character too.

See also:

Zenkaku and Hankaku





CALL KMID


(Kanji-Basic) Choose a part of a character data and substitute it to a character variable.

Syntax:

CALL KMID(character variable,X$,M[,N])

_ KMID(character variable,X$,M[,N])

Character variable: Variable of character type.

X$: Character constant, variable, array variable or expression.

M: 1 to 256. Numeric constant, variable, array variable or expression.

N: 0 to 256. Numeric constant, variable, array variable or expression. Default= all characters from M to last.

Function:

Choose N characters from Mth character in a character data, and substitute them into a chracter variable.

You must use this CALL KMID command instead of MID function if the character in question is of Japanese input type.

Example:

CALL KMID(A$,"今琵は暑いですか",4,2):PRINT A$ 暑い

* A hankaku accent will be counted as an independent character too.

See also:

Zenkaku and Hankaku





CALL KNJ


(Kanji-Basic) Substitute a character that stands for a specified kanji code to a character variable.

Syntax:

CALL KNJ(character variable,X$) _ KNJ(character variable,X$) Character variable: Variable of character type.

X$: Character variable, variable, array variable or expression which stands for a 4-digits kanji code.

Function:

Specify a hexadecimal 4-digits kanji code to X$. The kanji code will be treated as a JIS code is lower than 8000, or as a Shift-JIS code if it is 8000 or more.

Example:

CALL KNJ(A$,"3441"):PRINT A$ 漢

See also:

About how to access Kanji-ROM





CALL KTYPE


(Kanji-Basic) Check whether a character in a specified position in a character data is hankaku or zenkaku.

Syntax:

CALL KTYPE(numeric variable,X$,N) _ KTYPE(numeric variable,X$,N)

Numeric variable: Variable of numeric type.

X$: Character constant, variable, array variable or expression.

N: 1 to 255. Numeric constant, variable, array variable or expression.

Function:

This command substitutes 0 to a variable if a Nth character in X$ is hankaku, 1 if zenkaku.

If you specify N larger than number of characters in X$, you will get "Illegal function call" error.

Example:

CALL KTYPE(A,"ﾊﾝｶｸ全角",1):PRINT A 0

CALL KTYPE(A,"ﾊﾝｶｸ全角",5):PRINT A 1

* A hankaku accent will be counted as an independent character too.

See also:

Zenkaku and Hankaku





CALL HANON


(Hangul-Basic)

Syntax:

Function:

Example:

CALL HANON

See also:

CALL HANOFF





CALL HANOFF


(Hangul-Basic)

Syntax:

Function:

Example:

CALL HANOFF

See also:

CALL HANON





CALL ADJUST


(Hangul-Basic 2)

Syntax:

Function:

Example:

CALL ADJUST

See also:

CALL HANON, CALL HANOFF





CALL OPTIONS


(Arabic-Basic)

Syntax:

CALL OPTIONS [ ( [<number1> [, <number2>]] ) ]

Function:

(?) Select printer-options. This command displays a selection-screen to choose printer-options. Confirmation returns to the calling (Basic-)program.

Example:

CALL OPTIONS

See also:

CALL HCOPY, CALL CHCOPY





CALL CALENDAR


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL GPRINT


(Arabic-Basic)

Syntax:

CALL GPRINT( <arg1> [, <arg2> [, ...]] )

Function:

Prints specified argument(s) in graphic mode.

Example:

10 SCREEN 5 20 CALL GPRINT( "Sqrt of 27 is", SQR(27) )

See also:





CALL ARB


(Arabic-Basic)

Syntax:

CALL ARB0

CALL ARB1

CALL ARB2

Function:

(?) Changes the system-font to arabic layout. Already in textmode displayed characters will be redefined accordingly.

Example:

CALL ARB0 CALL ARB1 CALL ARB2

See also:





CALL ENGL


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL LATIN


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL RECON


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL NOCON


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL INDVAL


(Arabic-Basic)

Syntax:

CALL INDVAL

Function:

(?) Changes the digits in the font to arabic layout.

Example:

CALL INDVAL

See also:





CALL ARBVAL


(Arabic-Basic)

Syntax:

CALL ARBVAL

Function:

(?) Changes the digits in the font to international layout.

Example:

CALL ARBVAL

See also:





CALL DCOLOR


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL PRESORT


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL PRESEND


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL COMPRESS


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL ASTR


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL ESTR


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL FNKEY


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL HCOPY


(Arabic-Basic)

Syntax:

CALL HCOPY

Function:

Prints a hardcopy

Example:

CALL HCOPY

See also:

CALL OPTIONS, CALL CHCOPY





CALL CHCOPY


(Arabic-Basic)

Syntax:

CALL CHCOPY

Function:

Prints a hardcopy

Example:

CALL CHCOPY

See also:

CALL OPTIONS, CALL HCOPY





CALL SPAINT


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL VPRINT


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL HIJRI


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL TOHIJRI


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL TOGREG


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL ARABIC


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL ARABON


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL ARABOFF


(Arabic-Basic)

Syntax:

Function:

Example:

See also:





CALL MENU


(Firmware) This function is available in japanese A1-WX/WSX and arabic machines.

Syntax: CALL MENU

Function:

Boots up the MSX-computers main-menu (firmware). Any unsaved data will be lost.

This is similar to CALL MWP in the MSX A1-GT (Turbo-R) and CALL HIRO in the A1-ST.

Takamichi Suzukawa: These CALL commands are not written in any manual, but were notified in a magazine (MSX-FAN) as late as in 1994.

Example:



CALL MENU

See also:

CALL MWP, CALL HIRO, Arabic-Basic





ATTR$


(MSX-Basic)

This keyword is reserved for future use.

Syntax:

Function:



Example:



See also:

Reserved keywords





CMD


(MSX-Basic)

This keyword is reserved for future use.

Syntax:

Function:



Example:



See also:

Reserved keywords





IPL


(MSX-Basic)

This keyword is reserved for future use.

Syntax:

Function:



Example:



See also:

Reserved keywords





FPOS


(MSX-Basic)

This keyword is reserved for future use.

Syntax: FPOS( channel )

Function:



Example:



See also:

Reserved keywords, OPEN, CLOSE





CALL TURBO ON


(Turbo-Basic compiler)

Syntax: CALL TURBO ON

Function:

Defines the beginning of the turbo block. The turbo block is the part of the program you want to execute fast. When the entire program contains some uncompilable statements, you can define the block to be compiled using this set.



The following statements, commands and functions that can not be compiled:

AUTO, BASE, BLOAD, BSAVE, CALL, CDBL, CINT, CLEAR, CLOAD, CLOAD?, CLOSE, CONT, CSAVE, CSNG, CVD, CVI, CVS, DEFFN, DELETE, DRAW, DSKF, EOF, ERASE, ERL, ERR, ERROR, EQV, FIELD, FILES, FPOS, FRE, GET, IMP, INPUT#, KEY LIST, LFILES, LINEINPUT#, LIST, LLIST, LOAD, LOC, LOF, LPRINT USING, LSET, MAXFILES, MERGE, MOTOR, MKD$, MKI$, MKS$, NAME, NEW, ON ERROR GOTO, ON INTERVAL GOSUB (due to a bug), OPEN, PLAY, PRINT#, PRINT USING, PUT KANJI, RENUM, RESUME, RSET, SAVE, SPC, TAB, TRON, TROFF, WIDTH.

List of those with limits.

CIRCLE: Start, end angles and aspect ratio can't be specified.

COPY: Only graphic COPY is available.

DEFDBL: Same as DEFSNG.

DIM: Must come first in the program or in the turbo block.

INPUT: Can handle only one variable at the time.

KEY: ON KEY GOSUB, KEY(n) ON/OFF only.

LOCATE: x,y must be given in as a set. No cursor switch parameter.

NEXT: Variable names after the NEXT can not be omitted.

ON: ON STOP GOSUB, ON INTERVAL GOSUB not available.

PRINT: Commas work in a different way. No wrapping for digits.

PUT: PUT SPRITE only.

RUN: Variables won't be initialized.

SCREEN: Screen mode and sprite size only.

SET: SET PAGE only.

STOP: Same as END.

USR: Parameter type must be integer only.

VARPTR: File number can not be given as the parameter.

Otherwise there is no significant difference.



In general, I/O commands & functions, and editing commands can not be compiled. Of course they are available in the direct mode, and outside of the turbo block. You can edit, debug and save a program in MSX-BASIC and execute it by _RUN.

If you want to use PRINT# to write characters on GRP:, use it outside of turbo block. Otherwise study the sample, "PRINT.TRB".

If you want to use PLAY, use BGM compiler, and get the sound by USR(n).

Example:



100 SCREEN 8:DEFINT A-Z 110 BLOAD"PICTURE",S 120 _TURBO ON 130 FOR X=0 TO 255 140 LINE(X,0)-(X,211),0 150 NEXT X 160 _TURBO OFF 170 GOTO 170

See also:

CALL TURBO OFF, CALL RUN





CALL TURBO OFF


(Turbo-Basic compiler) Syntax: CALL TURBO OFF

Function:

The end of a turbo-block started with CALL TURBO ON.

Example:



100 SCREEN 8:DEFINT A-Z 110 BLOAD"PICTURE",S 120 _TURBO ON 130 FOR X=0 TO 255 140 LINE(X,0)-(X,211),0 150 NEXT X 160 _TURBO OFF 170 GOTO 170

See also:

CALL TURBO ON, CALL RUN





CALL BC


(Firmware) This function is available in the Sanyo MSX 2+ only!

Syntax: CALL BC

Function:

This command turn on the BASIC COMPILER options. X-BASIC must first initialized with CALL BC before using CALL RUN.

Example:



See also:

Turbo-Basic compiler





MSX-Music Voices


This is a list of the voices available for use with Voice command or the MML @ statement.





Voice No. Name Voice No. Name

0 * Piano 1 32 Piano 3

1 Piano 2 33 * Wood Bass

2 * Violin 34 Santule 2

3 * Flute 1 35 Brass

4 * Clarinet 36 Flute 2

5 * Oboe 37 Clavicord 2

6 * Trumpet 38 Clavicord 3

7 Pipe Organ 39 Koto 2

8 Xylophone 40 Pipe Organ 2

9 * Organ 41 P0hdsPLA

10 * Guitar 42 P0hdsPRA

11 Santule 1 43 Church Organ L

12 * Electric bass 44 Church Organ R

13 Clavicord 1 45 Synth Violin

14 * Hapsicord 46 Synth Organ

15 Hapsicord 47 Synth Brass

16 * Vibraphone 48 * Horn

17 Koto 1 49 Shamisen

18 Taiko 50 Magical

19 Engine 1 51 Fuwawa

20 UFO 52 Wonderflat

21 Synth Bell 53 Hard Rock

22 Chime 54 Machine

23 * Synth Bass 55 Machine V

24 * Synthesizer 56 Comic

25 Synth drum 57 SE comic

26 Synth rhythm 58 SE laser

27 Harmo drum 59 SE noise

28 Cow Bell 60 SE star 1

29 Hi Hat 61 SE star 2

30 Snare drum 62 Engine 2

31 Bass drum 63 no sound

* are sounds that are build in the FM sound chip.



See also: CALL VOICE, CALL VOICE COPY, PLAY (MSX-Music)





Firmware




Firmware is particular to the specific model of a MSX-computer.

Availability of implemented commands, parameters and behavior are changing with the computer-model or extension-ROM. Therefore MSX-programs should not assume Firmware extensions to be present on (almost) every MSX computer!





Zenkaku and Hankaku

"Zen" means whole, "han" means "half", "kaku" stands for "square" in Japanese. In MSX or in any word processing related with computers, hankaku is an adjective to describe 1-byte characters (English alphabets, numbers, western punctuation, unaccented katakanas, Japanese punctuation, Japanese accents; MSX supports unaccented hiraganas, unlike PC) while zenkaku, "2-byte" characters, include all hiraganas and katakanas, both accented and unaccented, English alphabets, special pictograms like large circles and measurement terms, Greek and Russian fonts, and thousands of kanjis.





CALL MWP




(Firmware) CALL MWP boots up the Word Processor in the MSX A1-GT (Turbo-R).

This is similar to CALL HIRO in the A1-ST. In case of A1-WX/WSX machines the corresponding command is CALL MENU.



Takamichi Suzukawa: These CALL commands are not written in any manual, but were notified in a magazine (MSX-FAN) as late as in 1994.





CALL HIRO




(Firmware) CALL HIRO boots up the Word Processor in the MSX A1-ST (Turbo-R).

This is similar to CALL MWP in the A1-GT. In case of A1-WX/WSX machines the corresponding command is CALL MENU.



Takamichi Suzukawa: These CALL commands are not written in any manual, but were notified in a magazine (MSX-FAN) as late as in 1994.





