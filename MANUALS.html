<!DOCTYPE html>
<html>
<head>
    <title>MSX: Manuals</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/5/w3.css">
</head>
<body>
<div class="w3-container w3-blue">
  <h1>Manuals</h1>
</div>

<h2>This page contains references to original documents:</h2>

<ul class="w3-ul w3-card-4" style="width:50%">
<li>MSX-DOS 2 Reference</li>
<li>MSX-DOS 2 Program Interface Specifications</li>
<li>MSX-DOS 2 Function Codes Specifications</li>
<li>RS232C Extended BIOS Call specification</li>
<li>MSX RS232C interface hardware specification</li>
<li>Z80</li>
<li>R800</li>
<li>Turbo-Basic compiler</li>
<li>FM-PAC</li>
<li>MSX2 Technical Handbook</li>
<li>System overview</li>
<li>Basic</li>
<li>MSX-DOS, System Call Usage</li>
<li>VDP and Display Screen (parts 1 to 5)</li>
<li>VDP and Display Screen (part 6)</li>
<li>Access to Peripherals through BIOS (parts 1 to 6)</li>
<li>Access to Peripherals through BIOS (part 7)</li>
<li>Appendix - BIOS listing, Math-pack, Bit Block Transfer, Work Area Listing, VRAM map, I/O map, Control codes, Escape sequences</li>
<li>MSXtra</li>
</ul>




M S X -- D O S v e r s i o n 2

=================================



</b> The advanced disk operating system

for MSX 2 computers

CONTENTS Page



1. Introduction ......................... 3

2. Editing command lines ................ 3

3. Notation ............................. 6

4. Description of Commands .............. 10

5. Redirection and Piping ............... 70

6. Batch files, AUTOEXEC and REBOOT ..... 72

7. Environment Items .................... 75

8. Errors and Messages .................. 79

9. Command Summary ...................... 94

10. DISK-BASIC 2.0 ....................... 100



This manual describes the user interface and commands provided by MSX-DOS 2 version 2.20.



<b>1. INTRODUCTION</b>

<b>=================</b>



MSX-DOS 2, like its predecessor MSX-DOS 1, is provided in a cartridge and in some disk files. The disk files are MSXDOS2.SYS, COMMAND2.COM, help files and transient commands.



MSXDOS2.SYS has the ability to load and execute programs in an enhanced CP/M-compatible environment. COMMAND2.COM is a special program which, when loaded and executed, provides the user with many sophisticated commands and features generally compatible with and in many cases better than those found in MS-DOS and MSX-DOS 1, such as extended memory management.



It also has the ability to load and execute specially written MSX-DOS 1

programs and most standard CP/M programs, and can execute batch files with parameter substitution and other features similar to those found in MS-DOS.



An APPEND facility is provided to increase the ease of use of directories with CP/M programs which were not written to handle them.



Throughout the rest of this manual the term MSX-DOS is used to mean MSX-DOS version 2.xx unless otherwise stated.



<b>2. EDITING COMMAND LINES</b> <b>========================</b>

When typing in a command line to MSX-DOS, a simple editing facility is available for correction of mistakes or the re-entering and editing of previous commands.



Typing ordinary characters at the keyboard cause the characters to appear on the screen as would be expected. Typing most control characters cause them to be represented by a '^' symbol followed by the control letter.

Exceptions are carriage return (RET or CTRL-M), back space (BS or CTRL-H), tab (TAB or CTRL-I), insert (INS or CTRL-R), escape (ESC or CTRL-[), home (HOME or CTRL-K), CTRL-C, CTRL-J, CTRL-N, CTRL-P, CTRL-S, CTRL-U and CTRL-X

(SELECT). These perform the following functions:

CTRL-C - this acts as a 'break' key. A more drastic and preferred 'break' key is CTRL-STOP.



CTRL-J - line feed; nothing happens if this was given in the command line.



CTRL-K - home cursor (HOME).



CTRL-N - this turns the printer off after being turned on by CTRL-P.



CTRL-P - this turns the printer on. When on, all characters printed on the screen are also printed on the printer.



CTRL-S - this suspends all character output until another key is pressed.



CTRL-U - this erases the line currently being entered.



CTRL-X - this erases the line currently being entered (SELECT).



The line is entered when the 'enter' key is pressed.



At any point whilst typing in a command line, the backspace key (marked BS or BACK SPACE on most MSX machines) can be used to delete the character immediately to the left of the cursor in the normal way.



The cursor left and right keys will move the cursor left and right along the line. Typing a character at this point will overwrite the character currently underneath the cursor.



Pressing the insert key (marked INS on most MSX machines) will toggle to 'insert mode', and the cursor will change to an underline cursor to indicate this. Instead of the characters being typed overwriting the characters under the cursor, they will instead be inserted before the cursor character, the remaining characters to the end of the line being moved one position to the right.



The delete key (marked DEL on most MSX machines) will delete the character under the cursor and move the remaining characters to the end of the line one position to the left.



The home key (marked 'HOME' on most MSX machines) will move the cursor to the start of the line.



Pressing ESC, CTRL-U or CTRL-X will clear the line to allow a new one to be entered.



The command editor also keeps a list of previous commands entered, up to a limit of 256 characters. Pressing the cursor up key will move up the list and display the previous command line entered, allowing this old command line to be edited and re-entered. Pressing the cursor down key will similarly move to the next old command line that was entered.



If a previous command line is changed, then it will be used as the new command line and added to the bottom of the list. If it was not changed, then it will not be added to the list and the current command line will be the next one which was originally entered. This allows a whole sequence of previous commands to be entered easily.



The list of previous commands is in fact circular and moving off the top or bottom will move to the last or first command in the list respectively.

The previous command can be called to be re-entered or edited from this command history list.



The features described here are in fact available to many programs that MSX-DOS can execute. In any program that does 'line inputs', each line can be edited as described above. Previous lines can be recalled for re-entering and editing, although the list of previous lines will of course include previous commands.



<b>3. NOTATION</b>

<b>===========</b>



The syntax of the commands available from MSX-DOS are described in





chapter 4 using the following notation:




Words in upper case



These are keywords and must be entered as shown in any mixture of upper or lower case.



Items in lower case



These are parameters which must be supplied to the command at this point in the command line.



Items in square brackets ('[' and ']')

These are optional items. The brackets themselves should not be included in the command line.



Items separated by a vertical bar ('|')

This indicates that only one of the items is required. The vertical bar itself should not be included in the command line.



The following is a list of items which can appear on a command line:

d:



This indicates that a drive name is required (A:, B: etc.).



If d: is shown as optional and is not specified, then the currently logged-on drive, as indicated by the command prompt, is assumed.



path



This indicates that a directory path is required, the syntax of which is similar to MS-DOS. Each directory in the path is separated by a backslash '\'. A backslash at the start of the path indicates that the path starts at the root directory, otherwise the path starts at the current directory as indicated by the CHDIR command. Frequently a filename follows a path, in which case the two must be separated by a backslash.



Two consecutive dots '..' signify the immediate parent directory in the path. A single dot '.' signifies the current directory in the path and therefore usually has no value in a path specification.



On non-English MSX machines, the backslash character '\' may be replaced by some other character. In particular, on Japanese MSX machines the Yen character is used.



If a path is shown as optional and is not specified, then the current directory as indicated by the CHDIR command is assumed.



The syntax of the directory names that make up a path name follows that for filenames given below.



filename



This indicates that the name of a file is required, the syntax of which is similar to MS-DOS and MSX-DOS 1. An ambiguous filename is one that contains '*' and '?' characters and may match more that one file on disk, whilst one that does not contain these is an unambiguous filename.



A filename has the following syntax:-



mainname[.suf]



where mainname is a sequence of up to 8 characters and suf is a sequence of up to 3 characters inclusive. Any characters beyond these fields are ignored. A '*' in the main name or suffix is equivalent to filling from that character position to the end of the field with '?'. If the suffix is given then it must be separated from the main part of the filename by a single dot '.'.



The following characters cannot be used in filenames:-



Control codes and SPACE (in the range 0 to 20h, and 7FH and FFH)

: ; . , = + \ < > ( ) | / " [ ]



All characters are converted to upper case where appropriate and therefore lower and upper case characters have the same meaning. Note that extended two-character Japanese characters(SHIFT-JIS code) are allowed.



If a filename is shown as optional and is not specified, then a filename of *.* is assumed.



filespec



This is used to identify a file or several files in the same directory on a disk. It's syntax is:-



[d:][path][filename]



where at least one of the three optional items must be given. Where this is used to specify existing files, /H may be given to allow hidden files to be found.



Generally, d: if not given defaults to the currently logged on drive, path if not given defaults to the current directory of that drive and filename if not given defaults to a filename of *.*.



compound-filespec



This is used in many commands to specify the files or directories to which the command is applied. It's syntax is:-



filespec [+ filespec [+ filespec ...]]



Thus several filespecs (see above) can be given, separated by '+'

symbols, with spaces etc. allowed either side of the +. The effect of this in commands is exactly the same as if all the matched files could have been matched by a single filespec.



Where a compound-filespec is used to specify existing files, /H may be given after each filespec (see above), in which case it will take effect only for the files matched by that single filespec. If a /H is given before the compound-filespec, then it will apply over all the filespecs.



volname



This indicates that a volume name is required. A volume name is a sequence of up to 11 characters, which can include the characters not valid for filenames with the exception of control codes and '/', although leading spaces will be deleted.



device



This indicates one of the five standard MSX-DOS devices is required.

These and their meaning are:



CON - screen/keyboard I/O

NUL - 'null' device, does nothing AUX - auxiliary I/O (eg. RS232 serial) LST - printer output PRN - printer output

Unlike on some other systems, a colon is not required after the device name.



Device names can generally be used wherever filenames can be used. For example, the command COPY MYFILE PRN will read the file MYFILE and write it to the printer.



When using the CON device as an input filename, lines can be typed in and edited in the same way as command lines (see chapter 2 on Editing Command Lines). To end the operation, control-Z (^Z) must be typed at the start of a line. For example, a small text file called MYFILE can be created with the command COPY CON MYFILE:



A>COPY CON MYFILE

All work and no play makes Jack a dull boy.

Can you hear me?

^Z

A>



Lines of text can then be typed in, and they will be written to the file MYFILE. The command will then complete when a line containing a single control-Z is entered.



If the NUL device is written to by the command COPY CON NUL, then the characters written are simply ignored. If read from, then an end-of-file condition is returned straight away (which is equivalent to typing the control-Z in the example above).



For most commands, it is not sensible to specify a device (the CON

device cannot be deleted using the ERASE command, for example). The commands that devices are likely to be used with are those that read and write data from and to files, such as CONCAT, COPY and TYPE.



number



This indicates that a number is required. This may be in the range 0 to 255 or 0 to 65535 depending on the command.



<b>4. COMMANDS</b>

<b>===========</b>



This chapter describes in detail all the commands available from the MSX-DOS CLI. Each command is described using the notation described in chapter 3. Where two or more parameters are described using this notation, they must be separated by separators. Separators consist of zero or more leading spaces, a separator character, and zero or more trailing spaces.

Valid separator characters are:



space tab ; , =



Option letters introduced by '/' characters are an exception to this and need not be preceded by a separator.



A transient MSX-DOS or CP/M-80 program can be loaded and executed by typing the main name of the filename plus an optional extension of .COM.

Batch files can similarly be executed except that the extension is .BAT.

Where COM and BAT files exist in the same directory and with the same name, the COM file is found and executed in preference to the BAT file. The exact location on disk of the command can be specified by including its drive and/or path with its name.



When looking for a COM or BAT file, the specified directory of the specified drive is searched. If not found and a drive or path was given with the command, then an 'unrecognized command' error results.



If just the filename and optional extension were given, the current directory is searched first. If not found, then a list of directories is searched. This list can be specified and changed using the PATH command. If still not found then an 'unrecognized command' error again results.



No CP/M program will be able to specify directories or path names since these do not exist in CP/M, only the current directory of the appropriate drive being accessible from these programs. An APPEND environment item is available which increases the usability of these programs by allowing an alternative directory to be searched by the program as well as the current one (see chapter 7 on Environment Items).



Many commands and programs perform input or output using the 'standard input' and 'standard output'. The standard input normally refers to the keyboard, and the standard output normally refers to the screen. These can be changed, however, to refer to other devices or to disk files for the duration of the command by including the redirection symbols <, > and >> on the command line, followed by a device or file name. The standard output of one command can also be sent to the standard input of the next command by including the piping symbol | on the command line between the two commands.

See chapter 5 on Redirection and Piping for more details of these facilities.



When a transient command is executed, that command may overwrite some of the memory that COMMAND2.COM was using. Thus when the command terminates, COMMAND2.COM may need to re-load itself from disk into memory from the COMMAND2.COM file that it was originally loaded from. This file is located by looking at the SHELL environment item (see chapter 7 on Environment Items), or the root directory of the boot drive if it is not found there. If it is still not found, then a prompt is issued. For example, if MSX-DOS was booted from drive A:, then the prompt will be:

Insert COMMAND2.COM disk in drive A: Press any key to continue...



After inserting into drive A: a disk containing COMMAND2.COM in the root directory and pressing a key, COMMAND2.COM will be re-loaded and the system will continue as normal.



Although not a command as such, the currently logged on drive can be changed by giving the command:



d:



which causes the drive d: to become the current drive. This should be shown by the prompt letter.



In the command examples that follow, underlined text is an example response to a command, and the other text consists of the example command given by the user. In most examples a single space is shown as the parameter separator, although other separator characters can be used as specified above.



<b>ASSIGN</b>



Format



ASSIGN [d: [d:]]



Purpose



Sets up the logical to physical translation of drives.



Use



If no drives are given, then all current drive assignments are cancelled.



If only one drive is given, then the physical drive to which this refers is printed.



If both drives are given, then the subsequent access to the first drive (logical drive) will be done to the second drive (physical drive) by MSX-DOS.



Examples



ASSIGN



Un-assigns all previous drive assignments.



ASSIGN A: B:



Assigns drive A: to drive B:, so that all accesses that previously would go to drive A: go instead to drive B:



ASSIGN A:

A:=B:



Displays the drive to which A: is currently assigned, which in this case is B:.



<b>ATDIR</b>



Format



ATDIR +|-H [/H] [/P] compound-filespec

Purpose



Changes the attributes of directories to make them hidden/not hidden.



Use



The compound-filespec specifies the directories whose attributes are to be changed.



If +H is given, then the selected directories are marked as hidden, and will not be affected by other directory commands or shown by a DIR command unless a /H option is given with those commands. The -H option marks the selected directories as not hidden, and will not have any effect unless the /H option is given.



Unlike files, directories cannot be made read only.



When an error occurs, the erroneous directory name is printed followed by an error message, and the command will continue with the next directory.

If many errors occur, then the /P option can be used to cause the output to pause at the end of the screen.



The DIR /H command can be used to indicate the current attributes of directories.



Examples



ATDIR +H DIR1



Marks the directory called DIR1 as hidden.



ATDIR -H DIR1/H

Marks the hidden directory DIR1 as not hidden.



ATDIR +H DIR?



Marks all directories matching DIR? as hidden (for example DIR1, DIR2 and DIR3).



ATDIR +H \DIR1+\DIR2



Marks the DIR1 directory and the DIR2 directory as hidden.



<b>ATTRIB</b>



Format



ATTRIB +|-R|H [/H] [/P] compound-filespec

Purpose



Changes the attributes of files to make them hidden/not hidden and read only/not read only.



Use



The compound-filespec specifies the files whose attributes are to be changed, and /H allows hidden files to also have their attributes changed.



If +H is given, then the selected files are marked as hidden, and will not be affected by most commands or be shown by the DIR command unless a /H

option is given with those commands. -H marks the selected files as not hidden, and will not have any effect unless the files are hidden.



If +R is given, then the selected files are marked as read only. -R

marks the selected files as not read only (read/write). Read only files cannot be written to or changed.



When an error occurs, the erroneous filename is printed followed by an error message, and the command will continue with the next file. If many errors occur, then the /P option can be used to cause the output to pause at the end of the screen.



The DIR command can be used to indicate the current attributes of files.



Examples



ATTRIB +R FILE1



The file FILE1 is marked as read only, and will not subsequently be modifiable or deletable.



ATTRIB +HB:\DIR1\*.COM



Marks all *.COM files in the directory B:DIR1 as hidden, and will not be displayed by the DIR command.



ATTRIB -R -H \DIR1/H/P



All the files in DIR1 are marked as not read only and not hidden. The output, if any, will pause at the bottom of the screen.



ATTRIB +R \DIR1 + \DIR2 + FILE1



All files in the directories DIR1 and DIR2 and the file FILE1 are marked as read only.



<b>BASIC</b>



Format



BASIC [program]



Purpose



Transfers control to MSX disk BASIC.



Use



[Program] is the name of a BASIC program on disk.



Control is passed to the built-in MSX BASIC, which will load and execute the BASIC program if specified. If a RAM disk has been set up, then it can still be used from BASIC.



The BASIC command CALL SYSTEM("command") can be used to return to MSX-DOS, and the optional command, which can be any command executable on MSX-DOS, will be executed. If the command is not given, then a batch file called REBOOT.BAT will be searched for and executed if found (see chapter 6

on Batch Files).



Examples



BASIC



MSX disk BASIC is entered.



BASIC MYPROG.BAS



MSX disk BASIC is entered, and the BASIC program MYPROG.BAS loaded and RUN.



<b>BUFFERS</b>



Format



BUFFERS [number]



Purpose



Displays or changes the number of disk buffers in the system.



Use



If the number is not given, then the number of disk buffers currently in the system will be displayed, otherwise the number of buffers will be changed to the specified number, the now unused memory being freed for other purposes if the new number is less than the previous. If there is not enough memory for the specified number of buffers, then as many as possible are created and no error is given.



Increasing the number of disk buffers may speed up some applications, particularly those that perform random accesses to files. Setting the number above 10 is unlikely to improve performance much, and unnecessarily uses up memory.



The memory area used for disk buffers is also used for environment items and for opening files. Thus keeping buffers set to the maximum possible may prevent some commands from working, particularly SET, COPY and CONCAT. If any of these commands give a 'not enough memory' error then it may help to reduce the number of buffers. Reducing them below about three however will impair performance considerably.



The default number of buffers in the system is 5, which will be adequate for most purposes.



Examples



BUFFERS

BUFFERS=5



The current number of disk buffers is printed, which in this case is 5.



BUFFERS 10

(or BUFFERS=10)



The number of buffers is increased to as many as possible up to a limit of 10.



BUFFERS = 5

(or BUFFERS 5)



The number of buffers is reduced again to 5.



<b>CD</b>



See CHDIR



<b>CHDIR</b>



Format



CHDIR [d:] [path]

or

CD [d:] [path]



Purpose



Displays or changes the current directory.



Use



If no path is specified, then the current directory path for the current or specified drive is printed. This is the directory path from the root directory to the current directory.



If a path is specified, then the current directory for the current or specified drive is changed to the directory specified by the path.



Each drive has it's own current directory. This remains at the directory specified by the last CHDIR command for that drive (or at the root directory initially) until another CHDIR command is given or it cannot be found on the disk when it is accessed (because the disk has been changed, for example). It is then returned to the root directory.



The CD command is an abbreviated form of the CHDIR command provided for convenience and MS-DOS compatibility.



Note that the command prompt can be changed to display the current directory with the command SET PROMPT ON (see chapter 7 on Environment Items).



Examples



CHDIR \DIR1



The current directory of the current drive is changed to DIR1.



CHDIR A:DIR2



The current directory of drive A: is changed to DIR2.



CD

E:\DIR1



The current directory of the current drive is displayed, which in this case is DIR1.



CHDIR A:

A:\DIR2



The current directory for drive A: is displayed, which is also DIR2.



<b>CHKDSK</b>



Format



CHKDSK [d:] [/F]



Purpose



Checks the integrity of the files on the disk.



Use



The integrity of the data structures on disk in the specified or current drive is checked and lost disk space is checked for. When errors are found on the disk, corrective action is taken. If lost clusters are found, a prompt is issued allowing the lost disk space to be either converted into usable disk space or into files. If the latter is chosen, then files of the form FILE0000.CHK, FILE0001.CHK etc. will be created.



If the /F option is not given, then CHKDSK will not actually write any corrections it makes to disk, but will behave as though it has. This allows CHKDSK to be executed to see what would be done to the disk if /F was given.



Disk space can become lost (ie. lost clusters created) when some programs are aborted. This applies particularly to CP/M programs. It is recommended that CHKDSK is used occasionally on all disks.



Note that this is a transient command, and must therefore be loaded off disk.



Examples



CHKDSK



The disk in the current drive is checked. A 'status report' will be printed. Any errors found will not be written to disk.



CHKDSK B:



The disk in drive B: is checked. Any errors found will not be written to disk.



CHKDSK/F





20 lost clusters found in 1 chain


Convert lost chains to files (Y/N) ?



The disk in the current drive was checked, and some lost disk space found. Since /F was given, the corrections will be written to disk and the lost space recovered.



<b>CLS</b>



Format



CLS



Purpose



Clears the screen.



Use



Simply clears the screen and homes the cursor.



Examples



CLS



The screen is cleared, and another command can be typed.



<b>COMMAND2</b>



Format



COMMAND2 [command]



Purpose



Invokes the command interpreter.



Use



command is any command that can normally be typed at the prompt (such as the commands in this manual).



COMMAND2 is simply the name of the command interpreter on disk, and can be executed as a normal transient program. In normal use it gets loaded and executed once by MSXDOS2.SYS at the boot time, and this provides the ability to perform all the commands in this manual.



Advanced users may, however, wish to invoke another command interpreter for a variety of reasons. The second COMMAND2.COM may, for example, be a later version and provide more facilities. If a transient program has the ability to load and execute programs, as some sophisticated programs do, then they can load the COMMAND2.COM program and any MSX-DOS command can then be given. When COMMAND2.COM exits by EXIT command, the original program will be returned to.



If no command is given as a parameter, then the second COMMAND2.COM will simply issue the normal prompt (without executing AUTOEXEC.BAT or REBOOT.BAT) and wait for commands in the normal way. It will terminate and exit back to the original command interpreter or program when the EXIT command is given (see the EXIT command). If an error code is given to this EXIT command, then the original command interpreter or program will receive it and, in the case of COMMAND2.COM and MSXDOS2.SYS, print an appropriate error message (see chapter 8 on Errors).



If a command is given as a parameter to COMMAND2.COM however, then it will be executed as though it had been typed in the normal way. The command may be an internal command or an external COM or BAT command. After executing the command, COMMAND2.COM will immediately exit back to the original command interpreter or program.



In this way, invoking a second COMMAND2.COM from the normal command interpreter with a batch file name as a command can be used to 'nest' batch files (see chapter 6 on Batch Files), instead of 'chaining'.



When COMMAND2.COM is executed, it saves the whole environment, and then restores it again when it exits. It only sets up the default environment items however if they are not already defined. Thus the second COMMAND2.COM

inherits the environment of the first. Any changes made whilst the second COMMAND2.COM is executing will only last as long it does, and will be lost when it exits.



Each incarnation of COMMAND2.COM uses up some memory which is freed again when it exits. This depends partly on the number of environment items, and is typically about 1.5K.



When COMMAND2.COM executes a transient program, it may have to re-load itself off disk since the program is allowed to use the memory occupied by COMMAND2.COM. In this case, it uses the SHELL environment item to locate the file that it must use to load itself (see chapter 7 on Environment Items).

When first loaded from the COMMAND2.COM file on disk, SHELL is set to refer to that file.



Examples



COMMAND2

A>



Another copy of COMMAND2 is loaded, and prints it's normal prompt. EXIT

will exit back to the original prompt.



COMMAND2 FILE.BAT



Normally in a batch file. The file FILE.BAT is executed, and when it ends the current batch file will be resumed with the command after this one.



<b>CONCAT</b>



Format



CONCAT [/H] [/P] [/B] [/V] compound-filespec filespec

Purpose



Concatenates (joins together) files.



Use



The compound-filespec specifies the files that are to be joined together, and /H allows hidden files to be joined.



The second parameter is a filespec that must be unambiguous and is created before the source files are read. Each source file is then read, joined onto the end of the previous one and written out to the destination.



As each source file is read, it's filename is printed. If for some reason the file cannot be read (eg. it is the file that has been created as the destination) then the filename is followed by an error message and the CONCAT operation continues with the next source file. If many files are being concatenated, then /P will cause the output to pause at the end of the screen until a key is pressed.



Normally, the concatenation is performed on ASCII files. Source files are read up to the first end-of-file character (CTRL-Z) and a single end-of-file character is appended to the destination after all data has been written out. If, however, /B (binary mode) is given, then no interpretation is given to the data read and no additional data is added.



It is also possible to give the /B to the destination or to any of the filespecs in the compound-filespec, and it will then refer only to those files. /A may also be given to reverse the effect of /B.



The /V option can be given to turn write verification on for the duration of the CONCAT command (see the VERIFY command). This will ensure that data is written correctly to disks if the device driver being used has the feature, but will slow the operation down for the verification.



If CONCAT gives a 'Not enough memory' error then probably reducing the number of buffers (see the BUFFERS command) or removing some environment items (see chapter 7 on Environment Items) will free up sufficient memory.



Examples



CONCAT *.DOC ALL.PRN



A new file called ALL.PRN is created, and all files matching *.DOC (for example FILE1.DOC, FILE2.DOC and FILE3.DOC) are joined together and written to the new file in the order that they are found on disk. Any existing file called ALL.PRN will be overwritten.



CONCAT /H /P *.DOC ALL.DOC

FILE1.DOC

FILE2.DOC

FILE3.DOC

ALL.DOC -- Destination file cannot be concatenated

A new file called ALL.DOC is created, and all files matching *.DOC are joined together and written to the new file in the order that they are found on disk. Since the destination file ALL.DOC also matched the source filename *.DOC, the message is printed and it is not included in the concatenation.

Since /H was given, hidden files are also concatenated and, since /P was given, the key input is waited after each screenful output if the number of the lines of the file list is larger than that of the screen.



CONCAT /B FILE2.DOC + FILE3.DOC + FILE1.DOC ALL.DOC



A new file ALL.DOC is created, and the files FILE2.DOC, FILE3.DOC and FILE1.DOC and joined together in that order and written to the new file. They are joined together in binary mode.



<b>COPY</b>



Format



COPY [/A] [/H] [/T] [/V] [/P] [/B] source dest

Purpose



Copies data from files or devices to other files or devices.



Use



The definition of the source is:

compound-filespec | device

The compound-filespec specifies the files that are to be copied. It may be the device specification. If /H is given then hidden files may be copied.



The definition of the dest is:

[d:] [path] [filename] | device

Where d: and path default to the current drive and directory respectively. If any part of the filename is ambiguous then the appropriate character from the source filename is substituted, thus allowing the files to be renamed in the process. If the filename is not given, then the entire source filename is used. If the dest is an unambiguous directory, then the files are copied into that directory with a filename of *.*.



COPY will read as many source files as possible into memory before writing any out. When it can read no more into memory (eg. when it has used all available memory) it will write out each file in the order that it read them. When it creates each destination file, it prints the source filename.

Then if it is unable to create the destination file, an error message is printed and the copy operation continues with the next file. /P can be given to make the output pause at the end of the screen.



Many reasons exist for COPY to be unable to create the destination, such as a read-only file already existing with the same name. Sometimes COPY will refuse to create the destination because the user may have made a mistake.

For example, a file cannot be copied onto itself, or several files cannot be copied onto one file. A 'Cannot create destination' error may be given if the destination of one file would delete a previous source file or a file already being used for something else (eg. the currently executing batch file). A 'Cannot overwrite previous destination file' error results if an attempt is made to copy many files to one file. This usually means that the intended destination was a directory, but that the name has been misspelled.



If /A is specified, then an ASCII copy is performed. This means that source files will only be read as far as the first end-of-file (EOF) character (CTRL-Z) and then each destination will have a single end-of-file character appended to it.



It is also possible to give a /A to the destination or to any of the filespecs in the compound-filespec separately, in which case it applies only to that source or dest specification.



The /B option can be given to copy in binary mode, that is, the file being read will be copied as it is and no data will be added.



The /V option can be given to turn write verification on for the duration of the COPY command (see the VERIFY command). This will ensure that data is written correctly to disks if the device driver being used has the feature, but will slow the operation down.



Normally, the destination files are given the same date and time as the source files. However, the /T option can be given to cause the destination files to have the current date and time. The destination files will not be hidden or read-only, regardless of the attributes of the source files. The ATTRIB command can be used to change these.



If COPY gives a 'Not enough memory' error then probably reducing the number of buffers (see the BUFFERS command) or removing some environment items (see chapter 7 on Environment Items) will free up sufficient work area.



Note that the COPY command is simpler than that in MS-DOS and MSX-DOS 1

because it cannot concatenate (join together) files. To do this, a CONCAT

command is available (see the CONCAT command).



Examples



COPY FILE1 B:



The file FILE1 is copied from the current directory of the current drive to the current directory of drive B:.



COPY /H MSXDOS2.SYS + COMMAND2.COM B:



The two hidden files MSXDOS2.SYS and COMMAND2.COM are copied to drive B:, thus making it a booting disk.



COPY A:\DIR1 B:\DIR1 /V



All files in the directory DIR1 from the root of drive A: are copied to a similar directory on drive B: with verify on to ensure that the files were written correctly.



COPY B:



All files in the current directory of drive B: are copied to the current directory of the current drive.



COPY /A AUX CON



Characters are read from the device AUX (which may be used for RS232

serial for example) to the device CON, which is the screen. The copy is done as far as the first end-of-file character. If /A was not given, then there may have been no way of stopping the COPY operation without pressing the CTRL-STOP key.



COPY A:*.DOC B:/T



All files matching *.DOC (for example FILE1.DOC, FILE2.DOC and FILE3.DOC) are copied to the current directory of drive B: and are given the current date and time instead of the dates and times of the *.DOC files.



COPY *.BAT

AUTOEXEC.BAT -- File cannot be copied onto itself REBOOT.BAT -- File cannot be copied onto itself

This command told COPY to copy all files matching *.BAT (in this case AUTOEXEC.BAT and REBOOT.BAT) from the current directory of the current drive to the same place, and COPY printed the messages to warn of this. No data in this case was actually copied.



COPY *.BAT DIR2

AUTOEXEC.BAT

REBOOT.BAT -- Cannot overwrite previous destination file

This command told COPY to copy all files matching *.BAT (in this case AUTOEXEC.BAT and REBOOT.BAT) to a directory called DIR2. DIR2, however, did not exist so AUTOEXEC.BAT was copied to a file called DIR2, and then an attempt was made to copy REBOOT.BAT also to a file called DIR2. The message was printed as a warning that a mistake was probably made (in this case DIR2 not existing). REBOOT.BAT was not actually copied anywhere.



<b>DATE</b>



Format



DATE [date]



Purpose



Displays or sets the current date.



Use



If the date is given after the command, then the date is set to this value (for the format see below). If the date is not given after the command, then the current day and date is printed and the new date is prompted for and input. If no input is given (ie. if the 'enter' key alone is pressed) then the current date is not altered. Otherwise the input is assumed to be a new date, and is interpreted as described below. If the date is invalid then an error message is displayed and the new date again prompted for and input.



The date is expected to consist of up to three numbers, separated by one of the following characters:



space tab , - . / :

with spaces allowed either side of the character. Any missing numbers will default to the current setting. The year may either be a full century and year, or may be just the year in which case the century defaults to 19 if the year is greater than 80 or 20 otherwise. The date and the year specifications may be substituted by '-' to be omitted.



The format in which the date is printed and input is flexible and can be changed. An environment item called DATE is set up by default to a format that is appropriate for the country of origin of the MSX machine (see chapter 7 on Environment Items). For example, on Japanese machines the default setting is YY-MM-DD. The command SET DATE DD-MM-YY will change the date format to the European format. The format also affects the dates printed by the DIR command.



If the DATE environment item is defined, then it will be printed by the DATE command to indicate the format in which the date is required to be input.



Examples



DATE 86-6-18



The current date is set to the 18th June 1986.



DATE

Current date is Wed 1986-06-18

Enter new date (yy-mm-dd): - -19



No parameter was given, so the current date of 18th June 1986 was printed and a new date prompted for. In the reply to the prompt, the date was updated to the next day by only specifying the 19th. Since the year and month were not given, they remained the same.



SET DATE = DD/MM/YY



The date format has been changed to the European format.



DATE

Current date is Thu 19-06-1986

Enter new date (DD/MM/YY):



No parameter was given, so the current date of 19th June 1986 was printed in the European format, and the prompt printed. The reply is expected in the European format.



Formats are:

ISO YY/MM/DD

American MM/DD/YY

European DD/MM/YY



<b>DEL</b>



See ERASE.



<b>DIR</b>



Format



DIR [/H] [/W] [/P] [compound-filespec]



Purpose



Displays the names of files on disk.



Use



The compound-filespec specifies which files are to be listed. If the /H

option is given, then hidden files will also be listed.



In the DIR command, unlike all other commands, it is permissible to not give the main filename or the filename extension, and both will default to '*'. Thus a filename of 'FRED' is equivalent to 'FRED.*' and a filename of '.COM' is equivalent to '*.COM'. Note that if the '.' at the end of a main filename is given, then the extension is also assumed to have been given, so that the filename 'FRED.' is not equivalent to 'FRED.*', unlike the example above.



There are two formats of the listing. If the /W option is given, then a 'wide' listing is printed, with several filenames output per line.

Sub-directory names, file attributes, and the date and time each file was created are not displayed.



If the /W option is not given, then the filenames are printed with one filename per line, together with the attributes, the file size and the date and time at which the file was last modified. The attributes are printed as an 'r' if the file is read-only and an 'h' if the file is hidden (and /H is given). If the time of a file is zero (ie. the file does not have an associated time) then the time field will not be printed. If the date of a file is zero, then neither the date nor the time fields will be printed. The formats in which the dates and times are printed can be changed (see the DATE

and TIME commands).



The non-/W display is designed to fit within a 40 column screen, but if fewer columns are available then some fields of the listing will not be shown so that the display will always fit on one line. The number of files per line that are printed when /W is specified is also adjusted according to the screen width. If the width of the display is less than 13 characters however, then in both cases the filenames will wrap to the next line.



At the top of the list of files, the volume name of the disk and the name of the directory being listed is displayed. At the bottom, the number of files listed, the total number of bytes in the files and the amount of remaining disk space is printed.



When the directory of a sub-directory is printed, the first two items listed will always be two special sub-directories called '.' and '..'. These are automatically created when a new directory is created, and it is these that allow '.' and '..' to be given in path names to signify the current and parent directories respectively (see chapter 3 on Notation for a description of paths).



When printing a number of bytes, the number is truncated and printed as the number of kilobytes if 1K or greater.



If the /P option is given, then the output will pause at the bottom of the screen until a key is pressed.



Examples



DIR



All filenames and directory names in the current directory of the current drive will be printed. This might be as follows:

Volume in drive A: is MSX-DOS 2

Directory of A:\

MSXDOS2 SYS r 4096 86-06-19 2:45p COMMAND2 COM r 10496 86-06-19 2:46p UTILS <dir> 86-06-19 2:50p HELP <dir> 86-06-19 2:50p





14K in 2 files 222K free




The disk thus contains the two MSX-DOS system files MSXDOS2.SYS and COMMAND2.COM, which are read only, and two directories called UTILS and HELP.



DIR B:\HELP/W



A 'wide' directory format has been requested of the HELP directory on drive B:. This might be as follows:



Volume in drive B: is MSX-DOS 2

Directory of B:\HELP



BUFFERS .HLP ATTRIB .HLP ASSIGN .HLP

ATDIR .HLP CHDIR .HLP CD .HLP

SYNTAX .HLP ENV .HLP BATCH .HLP

EDITING .HLP





25K in 10 files 222K free




DIR UTILS + HELP/P



This will list all the files in the UTILS directory and all the files in the HELP directory, and will pause at the end of every screen full.



DIR .COM



No main filename was given, and so defaults to *. Thus this command is equivalent to the command DIR *.COM.



DIR COMMAND2



No extension was given, so this defaults to .*. Thus this command is equivalent to the command DIR COMMAND2.*.



<b>DISKCOPY</b>



Format



DISKCOPY [d: [d:]] [/X]



Purpose



Copies one disk to another.



Use



The first drive is the source drive and the second the destination, which defaults to the current drive. If no drives are given, then DISKCOPY

will prompt for both the source and the destination.



Before DISKCOPY is used, the destination disk must be formatted with the same format as the source disk, and an error will be given if this is not the case.



If /X is given, then various messages printed during the disk copy operation will be suppressed.



Note that this is a transient command, and must therefore be loaded from disk.



Examples



DISKCOPY A: B:



Insert source disk in drive A:



Insert target disk in drive B:



Press any key to continue...



The command was given to copy the disk in drive A: to the disk in drive B:, thus destroying all existing data on the disk in drive B: The prompt is printed first.



DISKCOPY B:



The disk in drive B: is copied to the disk in the current drive.



DISKCOPY

Enter source drive:

Enter target drive:



The DISKCOPY command was given with no parameters, so the source and destination disks were prompted for. The reply to the prompts consists of just a single drive letter.



<b>ECHO</b>



Format



ECHO [text]



Purpose



Prints text.



Use



The text is simply displayed on the screen. If no text is given, then just a blank line is output.



This command should not be confused with the 'echo' state in batch files, which is controlled by an environment item called ECHO (see chapter 7

on Environment Items).



Examples



ECHO AUTOEXEC batch file executed

AUTOEXEC batch file executed



The specified text ('AUTOEXEC batch file executed') was printed on the screen.



ECHO



No parameters were given, so just a blank line was printed.



<b>ERA</b>



See ERASE.



<b>ERASE</b>



Format



ERASE [/H] [/P] compound-filespec or

DEL [/H] [/P] compound-filespec or

ERA [/H] [/P] compound-filespec

Purpose



Deletes one or more files.



Use



The compound-filespec specifies which files are to be deleted. The /H

option allows hidden files to also be deleted.



During the delete operation, if a file cannot be deleted for some reason (eg. it is set to 'read only') then the offending filename is printed along with an error message, and the delete operation continues with the next file.

If many such errors occur, then the /P option will cause the output to pause at the end of the screen.



If the filename is *.*, then the prompt:

Erase all files (Y/N) ?



is printed, and a reply is waited for. If the reply is anything other than 'Y' or 'y', then the file deletion does not take place. This is a safety feature designed to prevent accidental loss of all files in a directory.



If files are deleted unintentionally on a disk that was formatted under MSX-DOS 2, then the UNDEL command may be used immediately afterwards to restore them again.



Examples



ERASE FILE1.BAK



The file FILE1.BAK is deleted from the current directory of the current drive.



DEL *.COM/H



All files matching *.COM, both hidden and not hidden, are deleted.



DEL B:\UTIL\*.COM + B:\UTIL\*.BAT



All files matching *.COM or *.BAT are deleted from the directory called UTIL on drive B:.



DEL B:\UTIL

Erase all files (Y/N) ?



All files in the directory called UTIL on drive B: are deleted. Since so many files are being deleted, a prompt is printed first to prevent a catastrophe.



DEL *.BAT

AUTOEXEC.BAT -- Read only file

REBOOT.BAT -- Read only file



All files matching *.BAT are deleted except for AUTOEXEC.BAT and REBOOT.BAT which have been marked as read only.



<b>EXIT</b>



Format



EXIT [number]



Purpose



Exits COMMAND2.COM to the invoking program.



Use



The number is an error code and defaults to 0, which in MSX-DOS

indicates no error (see chapter 8 on Errors).



EXIT exits the command interpreter (COMMAND2.COM) and returns the error code to the program that originally loaded and executed it (see the COMMAND2

command). This may be another COMMAND2.COM, another program or, normally, MSXDOS2.SYS. In the latter case, an appropriate error message will be printed and COMMAND2.COM simply reloaded and executed.



COMMAND2.COM when loaded saves the current environment (see chapter 7 on Environment Items), and EXIT restores it. Thus, when EXIT exits back to MSXDOS2.SYS (that is, EXIT is executed at the primary level), the environment will be cleared. COMMAND2.COM will then be reloaded and will set up the default environment again, providing a method of resetting the environment to it's default values.



Examples



EXIT



The command interpreter is exited. What happens next depends on what loaded it.



EXIT 40

*** User error 40



The command interpreter is exited with an error code of 40. Since this does not correspond to an error that is known to the system, the error message is printed by whatever loaded the command interpreter in the first place (see chapter 8 on Errors).



<b>FIXDISK</b>



Format



FIXDISK [d:] [/S]



Purpose



Updates a disk to the full MSX-DOS 2 format.



Use



d: specifies the drive on which FIXDISK is to operate. If d: is not specified, the current drive will be assumed. /S option causes the disk to be updated to full MSX-DOS 2 disk.



This command is mainly used to update MSX-DOS 1 disks to full MSX-DOS 2

compatibility, but may also be useful for updating other disks of a similar format or reparing incorrect boot sector.



Although the disk format used by MSX-DOS 1 and MSX-DOS 2 is standardized, MSX-DOS 1 does not use the information stored on certain parts of the disk (the boot sector) and so this information is not necessarily correct on MSX-DOS 1 disks. This can cause problems when MSX-DOS 2 is used with these disks. Additionally, the MSX-DOS 2 UNDEL command will only work with disks that were formatted using MSX-DOS 2 (ie. disks that have a 'volume id' in the boot sector) and so will not work with MSX-DOS 1 disks or disks formatted on other systems.



The FIXDISK command will update a disk so that it is fully MSX-DOS 2

compatible, and it's use will allow full use of MSX-DOS 2 disk features. If /S option is specified, the boot program will be updated for MSX-DOS 2 so that the features of MSX-DOS 2 disk can fully work. When a disk has been updated in this way, however, it may no longer be fully compatible with the original system. For example, if /S option is specified against the disk of the application which uses non-standard boot program, such as some games, the application will no longer be booted, although it will still be able to start MSX-DOS 1 or MSX-DOS 2.



To help prevent accidental updates of boot disks from other systems, a prompt is issued before updating a disk.



Examples



FIXDISK B: /S

Disk in drive B: will only be able to boot MSX-DOS 2

Press any key to continue...



Drive B: will be updated to be fully MSX-DOS 2 compatible. Since the disk may have been a boot disk from another system, a prompt is issued before the disk is actually updated.



<b>FORMAT</b>



Format



FORMAT [d:]



Purpose



Formats (initializes) a disk.



Use



The specified or current drive is formatted, and all data on the disk will be destroyed.



After giving a FORMAT command, an option may be prompted for, allowing the required format of the disk (such as 1DD or 2DD) to be selected. The exact nature of these prompts depends on the manufacturer of the MSX machine, so obey the descriptions of the manual of the machine when you want to format the disk.



After formatting, there will be no files or directories on the disk, and the maximum amount of disk space will be free. The disk will not have a volume name, but can be given one with the VOL command. To turn the disk into a boot disk so that MSX-DOS can be started up from it, the files MSXDOS2.SYS

and COMMAND2.COM must be copied onto it with the COPY command.



Examples



FORMAT B:

1 - Single sided





2 - Double sided


? 2

All data on drive B: will be destroyed Press any key to continue...



The command was given to format the disk in drive B:. In this case, the options available were to select either double sided or single sided, and double sided was selected. The standard warning prompt was then printed.



FORMAT



This will format the current drive after the prompts given above.



<b>HELP</b>



Format



HELP [subject]



Purpose



Provides on-line help for an MSX-DOS feature.



Use



If no parameter is given, then a list of standard subjects on which help is available is printed. This includes all the commands and the major system features.



If a subject is specified, then help text on this subject is printed on the screen from a 'help file'. This will pause at the end of every screen until a key is pressed.



Help files have a filename of:

subject.HLP



and are located by default on the standard MSX-DOS boot disk in a directory called HELP.



An environment item called HELP is set up initially to refer to the HELP

directory (see chapter 7 on Environment Items). This can be changed with the SET command to refer to any other directory or disk if required.



Any HELP subject can be added by the user for his own use simply by adding the appropriate .HLP file in the HELP directory. The help file will be displayed very much like the TYPE command would display it.



Examples



HELP



A general help screen is printed. This lists all the subjects on which help is available, including the standard commands and main features of MSX-DOS. The user-supplied subjects are not available here.



HELP XCOPY



Help information on the XCOPY command is printed. This includes a description of how to use the command and what options are available.



HELP ME

*** File for HELP not found



This command caused HELP to look for a file called ME.HLP from which to get the help text, but did not find it so printed the error message. The files containing the help text are normally found in a directory called \HELP

on the drive from which MSX-DOS was booted, and any other help files may be added if required. If ME.HLP was added then HELP ME would print it on the screen.



<b>MD</b>



See MKDIR



<b>MKDIR</b>



Format



MKDIR [d:] path or

MD [d:] path



Purpose



Creates a new sub-directory.



Use



The last item in the path is the name of the new sub-directory which is to be created on the current or specified drive. Thus if this is the only item in the path, the new directory is created in the current directory. If the new directory is to be hidden, then it must be separately made hidden with the ATDIR command.



When a new directory is created, it is empty except for two special sub-directories called '.' and '..'. These are automatically created in the directory and it is these that allow '.' and '..' to be given in path names to signify the current and parent directories respectively (see chapter 3 on Notation for a description of paths).



The MD command is an abbreviated form of the MKDIR command provided for convenience and MS-DOS compatibility.



Examples



MKDIR UTIL



A directory called UTIL is created in the current directory of the current drive.



MKDIR A:\UTIL\RAM



A directory called RAM is created in the UTIL directory in the root directory of drive A:.



<b>MODE</b>



Format



MODE number



Purpose



Changes the number of characters/line on the screen.



Use



The number must be in the range 1 to 80 inclusive, and the number of characters per line on the screen will be set to this. The screen will be cleared and the cursor moved to the top left corner in the process.



Examples



MODE 80

(or MODE=80)



The screen is set to 80 column mode and is cleared in the process.



MODE 25

(or MODE=25)

The screen is set to 25 columns.



<b>MOVE</b>



Format



MOVE [/H] [/P] compound-filespec [path]



Purpose



Moves files from one place to another on a disk.



Use



The compound-filespec specifies which files are to be moved, and /H

allows hidden files to be included in the move.



The path specifies the directory to which the files are to be moved, the current directory being used if this is not given. The path must exist on each drive referenced by the filespecs in the compound-filespec.



If a particular file cannot be moved into the specified or current directory (eg. if a file of the same name already exists) then the offending filename is printed along with an error message, and the move operation continues with the next file. If many errors occur, then the /P option will cause the output to pause at the bottom of the screen.



Examples



MOVE FILE1 \



The file FILE1 is moved from the current directory of the current drive to the root directory of the current drive.



MOVE /H /P E:*.COM \

COMMAND2.COM -- File exists



All files matching *.COM, both hidden and not hidden, in the current directory of drive E: are moved to the root directory of that drive. The file COMMAND2.COM already existed in the root directory, so the error was printed.

Neither of the COMMAND2.COM files were moved or altered. If many such errors had occurred then a prompt would have been printed after a screen full.



MOVE \UTIL\*.COM + \UTIL\*.BAT



All files matching *.COM or *.BAT in a directory called UTIL on the current drive are moved to the current directory of that drive.



<b>MVDIR</b>



Format



MVDIR [/H] [/P] compound-filespec [path]



Purpose



Moves directories from one place to another on a disk.



Use



The compound-filespec specifies which directories are to be moved, and /H allows hidden directories to be included in the move.



The second parameter specifies the directory into which the directories are to be moved, the current directory being used if this is not given. The path must exist on each drive referenced by the filespecs in the compound filepecs.



If a particular directory cannot be moved into the specified or current directory (eg. if a directory of the same name already exists) then the offending directory name is printed along with an error message, and the move operation continues with the next directory. If many errors occur, then the /P option will cause the output to pause at the bottom of the screen.



Note that it is not possible to move a directory into one of it's own descendant directories, as this would produce an invalid sub-directory tree.

An error is given if this is attempted.



Examples



MVDIR COM UTIL



A directory called COM and all descendant directories and files are moved into a directory called UTIL, both directories being in the current directory of the current drive.



MVDIR \COM + \BAT \UTIL



A directory called COM and a directory called BAT, and both their contents, are moved into a directory called UTIL.



MVDIR E:DIR?/H/P ALL

DIR2 -- Duplicate filename



All directories in drive E matching DIR? (eg. DIR1, DIR2 and DIR3), which may be hidden, and the contents of the directories, are moved into a directory called ALL. A directory called DIR2 already existed in ALL so the error was printed. Neither of the DIR2 directories were affected at all.



<b>PATH</b>



Format



PATH [ [+|-] [d:]path [ [d:]path [ [d:]path ...]] ]



Purpose



Displays or sets the COM and BAT command search path.



Use



If no parameters are specified, then the search path currently set will be displayed, separated by semi-colons (';').



If + or - is not given, then the search path will be set to the list of path names given and any existing search path will be deleted.



If - is given before the list of paths, then each path in the list will be deleted from the currently set search path, and an error will be given if any of the given paths do not already exist.



If + is given before the list of paths, then each path specified will first be deleted from the currently set search path if it exists, and will then be added onto the end. This allows the order of the paths in the search path to be changed and allows new paths to be appended to the end of the current search path. The + syntax can also be used to set a search path longer than can be given in one command, the maximum length of the search path being 255 characters and the maximum length of a command 127 characters.



When searching for a COM or BAT file, the paths in the current search path will be used in order from left to right. It is recommended that the paths in the search path are specified as full paths starting at the root directory and with the drive specified. If this is not the case, then the meaning of the search path could change when the current drive or directory is changed.



The search path is stored as an environment item (see chapter 7 on Environment Items), and so can also be accessed with the SET command.



Examples



PATH E:\COM E:\BAT



When a COM or BAT command is next searched for, the directories searched will be the current directory of the current drive, the COM directory in the root directory of drive E: and the BAT directory in the root directory of drive E:, in that order.



PATH

; E:\COM; E:\BAT



No parameters were given so the current search path was printed.



PATH +A:\COM; A:\BAT



The directories A:\COM and A:\BAT are added to the end of the search path.



PATH

; E:\COM; E:\BAT; A:\COM; A:\BAT



The new search path is printed.



PATH -E:\COM, E:\BAT



The directories E:\COM and E:\BAT are deleted from the current search path.



PATH

; A:\COM; A:\BAT



The new search path is again printed.



<b>PAUSE</b>



Format



PAUSE [comment]



Purpose



Prompts and waits for a key press in a batch file.



Use



The comment consists of an arbitrary sequence of characters.



The comment, if given, is printed followed by the prompt 'Press any key to continue... ' on the next line. The system will then wait for a key to be pressed and will echo the key pressed if it is a printable character. If no comment is given as a parameter, then just the prompt will be printed.



The main use of this command is to issue prompts from within a batch file.



Examples



PAUSE

Press any key to continue...



No comment was given, so just the prompt was printed.



PAUSE Insert document disk in drive B: Insert document disk in drive B:

Press any key to continue...



The comment given was 'Insert document disk in drive B:' so this was printed followed by the prompt.



<b>RAMDISK</b>



Format



RAMDISK [number[K]] [/D]



Purpose



Displays or sets the RAM disk size.



Use



If no parameters are given, then the current RAMDISK size is displayed as the number of kilobytes.



The number, if given, specifies the maximum size for the new RAM disk, and is specified in kilobytes. The range is 0 to 4064. If the number is 0 or only /D is specified, the RAM disk will be deleted. This number will be rounded up to the nearest multiple of 16K since the RAM disk is always a multiple of 16K. A RAM disk smaller then the specified maximum size may be created if there is not enough free memory for the full size, although a 'not enough memory' error will be given if there is no memory at all available for the RAM disk. Note that the number specified is the maximum amount of RAM to use for the RAM disk, which is not the same as the maximum amount of free space available on the newly-created RAM disk since the system needs to use some for FAT or directories.



On MSX machines with 128K RAM, the maximum amount of RAM disk is 32K.



If a RAM disk already exists before a new one is created, then a 'Destroy all data on RAM disk (Y/N)?' prompt is printed to avoid accidental loss of data. /D can be given which will automatically delete any existing RAM disk first, thus suppressing the prompt.



Having created a RAM disk, it can be referred to as drive H:.



The RAMDISK command is normally only used in an AUTOEXEC.BAT batch file, with a large number specified so that as large a RAMDISK as possible is created. It is not advisable to keep any data on a RAM disk except for a short length of time that is not also kept on a floppy disk, since it will be lost if, for example, the power to the computer fails.



Examples



RAMDISK

RAMDISK=160K



No parameters were given, so the current size is printed, in this case 160K.



RAMDISK

*** RAM disk does not exist



No parameters were given but no RAM disk has been created, so the error is given.



RAMDISK = 300

Destroy all data on RAM disk (Y/N)? y



A RAM disk already existed, so the prompt was printed. In this case, the reply was 'y' so the current RAM disk was deleted and the new one set up with a maximum size of 300K.



<b>RD</b>



See RMDIR



<b>REM</b>



Format



REM [comment]



Purpose



Introduces a comment in a batch file.



Use



The comment is simply ignored, and the next command executed. The comment consists of a sequence of any characters up to the maximum length of a command line (127 characters).



Examples



REM This is my AUTOEXEC batch file



This command, either in a batch file or typed in, does nothing at all with it's parameters.



<b>REN</b>



See RENAME



<b>RENAME</b>



Format



RENAME [/H] [/P] compound-filespec filename or

REN [/H] [/P] compound-filespec filename

Purpose



Renames one or more files.



Use



The compound-filespec specifies the files that are to be renamed, and /H

allows hidden files to be included in the rename operation.



The second filename specifies the new name for the files. A '?' in the new name indicates that the corresponding character from the filename being renamed will be used, thus allowing an ambiguous rename. Thus '*' in the second filename, which is just equivalent to a series of '?'s, indicates that the whole of the filename or extension will remain unchanged.



If for some reason a particular file cannot be renamed (eg. if a file or directory with the new name already exists or they are read-only) then the offending filename will be printed along with an error message and the rename operation will continue with the next file. If many errors occur, then /P

will cause the output to pause at the end of the screen.



Examples



RENAME FILE1 FILE2



The file FILE1 in the current directory of the current drive is renamed to FILE2.



REN B:\DIR1\*.DOC/H/P *.OLD

FILE2.DOC -- Duplicate filename



All files matching *.DOC in the directory called DIR1 in the root directory of drive B:, including hidden files, are renamed with the same main name but with an extension of .OLD. The file FILE2.DOC could not be renamed because there was already a file called FILE2.OLD in the directory, so the error was printed. Neither FILE2.DOC nor FILE2.OLD was altered at all. If many such errors had been printed, then a prompt would have been printed at the bottom of every screen full, since /P was given.



REN DOC + FILE1 *.OLD



All files in the directory called DOC and the file FILE1, both in the current directory of the current drive, and renamed with an extension of .OLD.



<b>RMDIR</b>



Format



RMDIR [/H] [/P] compound-filespec or

RD [/H] [/P] compound-filespec

Purpose



Removes one or more sub-directories.



Use



The compound-filespec specifies which directories are to be deleted, and /H allows hidden directories to be included in the delete operation.



In order to delete a directory, it must contain no other files or other directories except for the special '.' and '..' directories which are always contained in a directory. These are put in a new directory when it is created and cannot be removed. It is these that allow '.' and '..' to be used in path names to specify the current and parent directories respectively (see chapter 3 on Notation for a description of paths).



If a directory cannot be deleted for some reason (eg. it is not empty) then the name of the offending directory is printed along with an error message, and the delete operation continues with the next directory. If many errors occur then /P will cause the output to pause at the end of the screen.



Examples



RMDIR DIR1



The directory called DIR1 in the current directory of the current drive is removed.



RD B:\COM + B:\BAT



The directories COM and BAT are removed from the root directory of drive B:.



RD \*.*

UTIL -- Directory not empty



An attempt was made to remove all directories from the root directory of the current drive, but a directory called UTIL was not empty and so the error was printed. UTIL and it's contents are not affected at all.



<b>RNDIR</b>



Format



RNDIR [/H] [/P] compound-filespec filename

Purpose



Renames one or more sub-directories.



Use



The compound-filespec specifies the directories that are to be renamed, and /H allows hidden directories to be included in the rename operation. The contents of the directories remain unchanged.



The second filename specifies the new name for the directories. A '?' in the new name indicates that the corresponding character from the name of the directory being renamed will be used, thus allowing an ambiguous rename. Thus '*' in the second filename, which is just equivalent to a series of '?'s, indicates that the whole of the filename or extension of the directory name will remain unchanged.



If for some reason a particular directory cannot be renamed (eg. if a file or directory of the new name already exists) then the offending directory name will be printed along with an error message and the rename operation will continue with the next directory. If many errors occur, then /P will cause the output to pause at the end of the screen.



Examples



RNDIR UTIL COM



The directory called UTIL in the current directory of the current drive is renamed COM.



RNDIR A:\*.*/H/P *.OLD

UTIL -- Duplicate filename



All directories, hidden and not hidden, in the root directory of drive A: are renamed with an extension of .OLD. The directory UTIL could not be renamed because a directory called UTIL.OLD already existed, so the error was printed. If many such errors were printed then /P would cause a prompt to be printed at the end of every screen full.



RNDIR COM + BAT *.OLD



The directories COM and BAT are renamed to COM.OLD and BAT.OLD

respectively.



<b>SET</b>



Format



SET [name] [separator] [value]



Purpose



Displays/sets environment items.



Use



If no parameters are given, then all currently defined environment items and their current values are displayed. Initially there are several items set up to default values (see chapter 7 on Environment Items).



If just a name is given as the parameter, then the current value of the specified environment item is printed.



If the name is followed by a separator, then the separator is ignored and the name is set to the following value. If the value is blank (ie. not given) then the environment item is deleted from the environment space.



The area of memory used for environment items is also used for disk buffers. Thus if a 'not enough memory' error occurs when using the SET

command, then it may help to reduce the number of disk buffers (see the BUFFERS command).



Chapter 7 contains more information about environment items and the items and values that are set up by default.



Examples



SET

ECHO=OFF

PROMPT=OFF

PATH=;

TIME=12

DATE=yy-mm-dd

HELP=A:\HELP

SHELL=A:\COMMAND2.COM



No parameters were given, so all the currently set environment items were printed, in this case typical default values.



SET HELP=A:\HELP



An item called HELP is set to the value A:\HELP.



SET HELP

A:\HELP



The current value of HELP is printed.



SET HELP=



The item HELP is set to a null value, thus removing it from the environment item list.



<b>TIME</b>



Format



TIME [time]



Purpose



Displays or sets the current time.



Use



If the time is given after the command, then the time is set to this value (for the format see below). If the time is not given after the command, then the current time is printed and the new time is prompted for and input.

If no input is given (ie. if the 'enter' key alone is pressed) then the current time is not altered. Otherwise the input is assumed to be a new time, and is interpreted as described below. If the time is invalid then an error message is displayed and the new time again prompted for and input.



The time is expected to consist of up to four numbers, separated by one of the following characters:



space tab , - . / :

with spaces allowed either side of the character. Any missing numbers will default to the current setting. The first number is the hour, the second is the minutes, the third is the seconds and the forth is the centi-seconds. The centi-seconds are not printed however since it is not very useful to know the current value, or indeed to enter a new one.



The format in which the time is printed is flexible and can be changed.

An environment item (see chapter 7 on Environment Items) called TIME is set up by default to the value '12', which indicates that the time will be printed in 12 hour format with a following 'a' or 'p' for am and pm. The command SET TIME 24 will cause the time to be printed in 24 hour mode. The time can be input unambiguously in either format. The time format also affects the times printed by the DIR command.



Examples



TIME 16:45



The current time is set to 4:45 pm.



TIME

Current time is 10:45:00a Enter new time:

No parameters were given, so the current time is printed (in this case in 12 hour mode) and the new time prompted for.



TIME 10-50-30-23



The time is set to 30.23 seconds after 10:50 am.



<b>TYPE</b>



Format



TYPE [/H] [/P] [/B] compound-filespec | device

Purpose



Displays data from a file or device.



Use



The compound-filespec specifies the files that are to be displayed, and /H allows hidden files to be typed. If the compound-filespec is ambiguous, then the filename is printed before each one is typed.



If /B is specified, then data is read from each file and displayed without modification on the screen, until the end of file is reached. This may have strange effect on the screen if the file contains control characters.



If /B is not given, then TYPE will look for the end-of-file character (CTRL-Z) and stop when it finds it. Also control characters except carriage return, line feed and tab will be converted into characters that can be printed, A for ^A, W for ^W, etc.



If /P is given, then the output will pause at the end of the screen until a key is pressed.



Examples



TYPE FILE1



Data is read from the file and printed on the screen, up to the first end-of-file character.



TYPE *.BAT/H/P



All batch files, including hidden ones, are read in and displayed. A prompt is printed at the end of every screen full.



TYPE AUTOEXEC.BAT + REBOOT.BAT



The files AUTOEXEC.BAT and REBOOT.BAT are displayed.



TYPE /B DIR1



All files in the directory DIR1 are printed on the screen and no interpretation is put on the data in the files.



<b>UNDEL</b>



Format



UNDEL [filespec]



Purpose



Recovers a previously deleted file.



Use



The filespec specifies which files are to be undeleted if possible, and defaults to *.*.



Files can only be undeleted if they have been deleted using MSX-DOS 2 on an MSX-DOS 2 formatted disk and if no disk allocation has taken place since the file was originally deleted, which usually means that they have to be undeleted immediately after they have been deleted.



Each deleted file and directory reference that is found in the directory specified by the filespec will be undeleted if it's name is matched by the filename in the filespec, and if undeletion is possible. UNDEL can therefore be used to restore a directory removed with the 'RD' or 'RMDIR' commands; to restore the contents of the directory a further UNDEL command is required specifying the now undeleted directory.



Note that UNDEL is a transient command, and therefore must be loaded from disk.



Examples



UNDEL B:HELP.MAC



Attempts to undelete the file HELP.MAC from the current directory of drive B:.



UNDEL A:\DIR1



All undeletable files and directories in DIR1 are undeleted.



<b>VER</b>



Format



VER



Purpose



Displays the system's version numbers.



Use



The version numbers of the three main components of the MSX-DOS disk system are displayed. Each version number consists of three digits. The first digit is the main MSX-DOS version number and for MSX-DOS 2 will always be 2.

The second digit is the version number and will change for future versions that have, for example, had extra major features added. The last digit is the release number and will change with different releases of the same version of the system which have had minor changes, improvements and corrections made.



Examples



VER

MSX-DOS kernel version 2.20

MSXDOS2.SYS version 2.20

COMMAND2.COM version 2.20

Copyright 1988 ASCII Corporation



The version numbers of all the components of the MSX-DOS disk system are printed out.



<b>VERIFY</b>



Format



VERIFY [ON | OFF]



Purpose



Displays/sets the current disk write verify state.



Use



If no parameters are given, then the current verify state is displayed on the screen.



If ON or OFF is given, then the verify state is changed appropriately.



The verify state affects all writes to disk. If OFF, the default state, then data is simply written. If ON, then after writing the data it is read back and compared with the original to ensure that it was written correctly.

The extra overhead of this means that writing is slower when verify is on.



This feature depends on the device driver, so this will have no effect if the driver does not have the feature.



Examples



VERIFY

VERIFY=OFF



No parameters were given, so the current verify state is printed, which in this case is off.



VERIFY ON



Disk write verification is turned on.



<b>VOL</b>



Format



VOL [d:] [volname]



Purpose



Displays or changes the volume name on a disk.



Use



If no parameters are given, or if only a drive name is given, then the volume name of the current or specified drive is printed.



If a volname is given, then the volume name of the specified or current drive is changed to the specified volume name.



Examples



VOL B:

Volume in drive B: has no name

Just a drive was given, so the volume name for the disk in that drive is printed. In this case there was no volume name defined.



VOL B:BACKUP



The volume name of the disk in drive B: is changed to BACKUP.



<b>XCOPY</b>



Format



XCOPY [filespec [filespec]] [options]



Purpose



Copies files and directories from one disk to another.



Use



The options available are:

[/A] [/E] [/H] [/M] [/P] [/S] [/T] [/W] [/V]



XCOPY is an extended file copying command (compare with the COPY

command) that can selectively copy both files and directories. The first filespec specifies the source filenames, and if /H is given then hidden files will also be copied. The second filespec is the destination filename. Thus files can be renamed during the copy (as in the standard COPY command).



/T (Time) will cause the copied files to have the current date and time rather than the source file's date and time.



If /A (Archive) is specified, then only files with the 'archive'

attribute set are copied. A file has an archive attribute in the same way as a 'hidden' attribute and a 'read only' attribute. It is set whenever a file is updated (written to).



/M is similar to /A, but resets the archive bit after copying the file.

Thus, using this option, files can be regularly copied onto another disk only if they have been updated, providing a file backup facility.



/S causes XCOPY to copy directories as well as files. Within each directory, all files are copied and then any matching files within each directory are copied, with the directory being created on the destination if it does not already exist. Normally, these directories will not be created if no files are to be copied into them.



/E can be given to cause the /S option to create all directories, even if they are empty.



The /P (Pause) option will cause XCOPY to pause and prompt before copying each file, which allows files to be selectively copied.



/W (Wait) causes XCOPY to pause and prompt before copying any files, so that disks can be changed.



/V option can be given to turn write verification on for the duration of the XCOPY command (see the VERIFY command). This will ensure that data is written correctly to disks if the device driver being used has the feature, but will slow the operation down.



Note that XCOPY is a transient command, and so must be loaded off disk.



Examples



XCOPY B:\



All files in the root directory of drive B: are copied to the current directory of the current drive. There is no advantage in this case over using the standard built-in COPY command.



XCOPY *.* B: /H/S/M



All files, including hidden files, are copied to drive B: only if they have been modified since a similar command was last given. The archive attributes are then reset so that the files are marked as unmodified. Not only are all the files in the current directory copied, but so are directories and all their descendant directories and files.



<b>XDIR</b>



Format



XDIR [filespec] [/H]



Purpose



Lists all files within directories.



Use



The filespec specifies which files are to be listed, and /H allows hidden files to be included.



XDIR is similar to the DIR command, but does not print the files' dates and times.



After all files in the specified directory have been listed, then files within descendant directories are also listed, and are shown indented. This allows a DIR of a complete directory tree or disk to be obtained.



Note that XDIR is a transient command, and so must be loaded off disk.



Examples



XDIR



The directory of the entire disk in or descending from the current directory of the current drive is printed.



Volume in drive A: is MSX-DOS 2

X-Directory of A:\



MSXDOS2.SYS r 4480

COMMAND2.COM r 14976

AUTOEXEC.BAT 57

REBOOT.BAT 57



\UTILS

CHKDSK.COM 7680

DISKCOPY.COM 7168

FIXDISK.COM 768

UNDEL.COM 3968

XCOPY.COM 10112

XDIR.COM 7168

MKSYS.BAT 569

AUTOEXEC.BAT 47

REBOOT.BAT 90

\HELP

ASSIGN.HLP 819

ATDIR.HLP 1527

ATTRIB.HLP 1828

.

.

.





292K in 117 files 530K free




XDIR B:\DIR1



All the files and directories and their contents are printed from the directory DIR1.



XDIR \*.COM/H



The names of all files, including hidden files, matching *.COM are displayed.



<b>5. Redirection and Piping</b> <b>=========================</b>

COMMAND2.COM offers the redirection and piping features as described below. They may be bypassed by setting the environment item "REDIR" to "OFF"

("SET REDIR=OFF"), so the compatibility to MSX-DOS 1 or CP/M can be achieved.



Redirection



Most commands, CP/M programs and MSX-DOS programs output text to the screen by writing to the 'standard output', and read from the keyboard by reading from the 'standard input'. COMMAND2.COM, however, provides facilities for changing the standard input and standard output for the duration of the command to refer to other MSX-DOS devices or to files on disk by including one or more of the redirection symbols <, > and >> on the command line, followed by a filename.



For example, the ECHO command normally just outputs it's parameters to the screen by writing the characters to the standard output. It can be made to output to the printer instead by redirecting it's output, as follows:

ECHO text >PRN



which changes the standard output to refer to the device PRN for the duration of the ECHO command. Similarly, the command:

ECHO text >file1



will cause the specified file ("file1") to be created, and the output of the ECHO command written to the file. To append the output of a command to the end of an existing file, the >> symbol can be used instead of the > symbol, and the file will only be created if it does not already exist.



To change the standard input, the < symbol is used in a similar manner to the > symbol. In this case, the file must already exist, and must contain adequate input for the command. If the command attempts to read input beyond the end of the file, then it will be aborted since it cannot continue.



When redirection information is given on the command line, it is used by COMMAND2.COM to set up the redirection and then removed from the command line. Thus in the examples above, the ECHO command will not echo the redirection symbols or the filename.



If the input or output of a batch file is redirected, then that redirection is applied to all commands within the batch file. Individual commands within the batch file may still be redirected, however, which will override the batch file redirection. See chapter 6 on Batch Files for more information on commands in batch files.



Piping



As well as redirecting the input and output of a command or program to another device or a disk file, it is possible to redirect or 'pipe' the standard output of one command into the standard input of another. Typically the second command will be a program which reads from it's standard input, modifies the data, and writes it to it's standard output. Such a program is called a 'filter'. For example, a filter could be produced which read data from it's standard input, sorted it into alphabetical order, and wrote it to it's standard output. Thus the output of the DIR command could be sorted.



Piping is indicated on the command line by separating the two commands by the | symbol. The command to the left of the | symbol will be performed first, and it's output will be redirected to a temporary file created by COMMAND2.COM. Then the second command will be performed, with it's standard input redirected from the same temporary file. When the second command ends, the temporary file will be deleted. The standard output of the second command may of course have been piped into the standard input of a third command, and so on.



If any input redirection occurs on a command line involving a pipe, then the redirection is applied to the first command in the pipe, as all the other commands receive their standard input from the standard output of the previous command in the pipe. Similarly, if any output redirection occurs on a command line involving a pipe, then the redirection will apply to the last command on the command line.



It is not possible to use pipes on either the input or the output of batch files directly. It is, however, possible to use piping with batch files if they are executed with the COMMAND2 command (see chapter 4) since it is then the COMMAND2 command that is being redirected and not the batch file.



As mentioned above, in order to pipe the output of one command into the input of another, temporary files will be created and deleted by COMMAND2.COM. The location of these temporary files is specified by the TEMP

environment item (see chapter 7 on Environment Items), and this may be changed to refer to any drive and directory (for example piping will be speeded up considerably if TEMP refers to a directory on a RAM disk). By default, TEMP refers to the root directory of the boot disk. The filename used for the temporary file is created by COMMAND2.COM, so TEMP should specify just the drive and directory. The filename is of the form:

%PIPExxx.$$$



where xxx is a three digit number chosen by COMMAND2.COM to avoid clashes with any other files in the TEMP directory.



<b>6. Batch Files</b>

<b>==============</b>



When a command is given to MSX-DOS and it is not one of the internal commands, a file of that name is searched for with an extension of COM or BAT. If not found in the current directory then the current search path is searched (see the PATH command). If a COM file is found, then it is loaded and executed. If a BAT file is found, then MSX-DOS starts execution of the batch file.



A batch file is a text file that contains a list of commands, and these commands are read from the file a line at a time and executed as though they were typed at the keyboard. Several of the commands described in chapter 4

are in fact provided mainly for use in batch files, such as ECHO and PAUSE.



As each command is read, normally it is executed immediately. An environment item ECHO exists, however, that can be set to ON (with the command SET ECHO ON) to cause each command line to be printed on the screen before it is executed (see chapter 7 for Environment Items). The command line is echoed in this way after % parameter substitution (see below) has taken place. The command SET ECHO OFF will restore the normal state.



In the command line that invoked the batch file, parameters may follow the name of the batch file just like any other command or transient program name. These parameters may be accessed anywhere in the batch file by specifying %0 to %9. %1 is the first parameter specified in the command line, %2 is the second and so on. %0 is the name of the batch file itself. The %

number will be replaced by the parameter on the original command line, and may appear anywhere on a batch file command line. To actually use a % symbol on a command line a double % must be given ('%%') which will then be replaced by a single one.



If the execution of any command in a batch file is terminated prematurely for some reason (typically the control-STOP or control-C key being pressed) then the following prompt is issued:

Terminate batch file (Y/N)?



If the response to this is 'Y', then execution of the whole batch file is stopped. If the response is 'N', then batch file execution continues with the next command in the batch file.



After MSX-DOS has executed a command in batch file, it may need to read the next command in the batch file off disk. If the correct disk is not in the drive when it comes to do this, then a prompt is issued. For example, the following prompt will be issued if the batch file was originally executed from drive A::



Insert disk for batch file in drive A: Press any key to continue...



When the correct disk has been inserted and a key pressed, batch file execution will continue normally.



Below is a very simple batch file, which just prints the first few parameters.



ECHO Parameter 0 = %0

ECHO Parameter 1 = %1

ECHO Parameter 2 = %2

ECHO Parameter 3 = %3



If this is called MYBAT.BAT then the command MYBAT a b c will output

Parameter 0 = MYBAT

Parameter 1 = a Parameter 2 = b Parameter 3 = c

When MSX-DOS starts up for the first time, a special batch file called AUTOEXEC.BAT is looked for and is executed if found. This may contain any MSX-DOS command, and usually contains once-only initialization commands, such as a RAMDISK command to set up a RAM disk.



One % parameter is passed to AUTOEXEC.BAT as %1. This the drive that MSX-DOS booted from and is in the form of a normal drive letter followed by a colon.



Another special batch file is REBOOT.BAT. This is executed when MSX-DOS

is re-booted after using DISK-BASIC. As with AUTOEXEC.BAT files, the single %1 parameter passed is the drive from which MSX-DOS was re-booted.



Usually some commands need to be performed whenever MSX-DOS is booted, whether for the first time or sometime later, and these are put in the REBOOT

batch file. They can then be executed from the AUTOEXEC batch file by ending it with the command REBOOT %1. An example of a command that might be put in the REBOOT batch file is the PATH command to set up the transient command search path. When setting up the search path using the command, %1 can be used to set up the path on whatever drive was booted from.



When a command in a batch file is the name of another batch file, then that second batch file is executed in the normal way. When it ends, control passes back to the interactive command interpreter, and not to the first batch file. Batch file commands thus 'chain' together.



If it is desired to 'nest' batch files ie. to pass control back to the first batch file above, then this can be done with the COMMAND2 command (see chapter 4), passing the name of the second batch file as the parameter. Then when the second batch file ends, the first one will be continued with the command after the COMMAND2 command.



A typical AUTOEXEC batch file is as follows:

ECHO AUTOEXEC executing RAMDISK 100

RAMDISK

COPY COMMAND2.COM H:\ REBOOT %1



A typical REBOOT batch file is as follows:

ECHO REBOOT executing PATH H:\, %1\UTILS, %1\BATCH

SET SHELL=H:\COMMAND2.COM

SET TEMP=H:\

SET PROMPT ON

H:



When the AUTOEXEC batch file executes, the message "AUTOEXEC executing"

is printed, and then a RAM disk is set up with a maximum size of 100K.

Another RAMDISK command is then given which will print out the actual size of RAM disk created. The COPY command then copies COMMAND2.COM onto the RAM disk so that it can load and re-load quickly. Finally the REBOOT batch file is executed, with the %1 parameter (the boot drive) passed to it.



The REBOOT batch file prints a message and then sets a PATH. The first item in the path refers to the RAM disk that was created by the AUTOEXEC

batch file, and the other items refer to directories on the disk from which MSX-DOS was booted (ie. %1). The SHELL environment item is set up so that COMMAND2.COM can re-load quickly off the RAM disk, and the TEMP environment item is set up so that temporary piping files are created on the RAM disk.

The prompt is set ON so that the current directory is printed as the prompt and, finally, the RAM disk is made the default drive.



<b>7. Environment Items</b> <b>====================</b>

MSX-DOS maintains a list of 'environment items' in its work area. An environment item is a named item that has a value associated with it.



An environment item can have any name chosen by the user, and can consist of the same characters that are valid in a filename. The maximum length of an environment item name is 255 characters. MSX-DOS provides several environment items set up by default.



The value of an environment item is simply a string of arbitrary characters up to a maximum length of 255. No processing is performed on the characters and so the casing of characters is preserved. Any environment item that does not exist has a null value (ie. no characters).



An environment item can be changed or set up by the SET command, which can also display currently set environment items.



The environment items set up by default and the manner in which their value is interpreted are as follows:



ECHO



This controls the echoing of lines read from a batch file (see chapter 6

on Batch Files). Any value except 'ON' (lowercase also allowed) is interpreted as 'OFF'.



PROMPT



This controls the displaying of the prompt at command level. Any value except 'ON' is interpreted as 'OFF'.



When PROMPT is OFF, as it is by default, then the prompt consists of the current drive followed by '>' eg. A>.



When PROMPT is ON, then the prompt consists of the current drive and the current directory of that drive followed by '>' eg. A:\COM>. In order to do this, the current drive must be accessed to read the current directory and so may take a little longer to appear.



PATH



The current search path by which COMMAND2.COM searches the command given is maintained as an environment item PATH, and it is this that the PATH

command manipulates.



SHELL



The SHELL environment item indicates where the command interpreter (COMMAND2.COM) exists, and is set up by default to where it was loaded from.

When the command interpreter needs to re-load itself from disk (after running a transient command) it looks at the SHELL environment item and attempts to load itself from the file that it specifies. If this gives an error then it attempts to load itself from the root directory of the drive that it was originally loaded from.



To cause the command interpreter to re-load itself from another drive or directory, COMMAND2.COM can be copied there and SHELL set to refer to it. For example, it might be copied to the RAMDISK with the command COPY COMMAND2.COM

H:\ and then SHELL set with the command SET SHELL=H:\COMMAND2.COM.



TIME



TIME specifies the format the time is displayed by MSX-DOS. If not '24', which indicates that it is displayed as a 24-hour time, then '12' is assumed, which indicates that it is displayed as a 12-hour time with an am. or pm.

indication. The TIME environment item does not apply when the time is input because it can be input in either format unambiguously.



DATE



DATE specifies the format the date is displayed and input by MSX-DOS. It defaults to a format appropriate for the country of origin of the MSX

machine. It takes the form of three letters or three letter pairs separated by date/time separators (see the DATE command). To set the American format, for example, the command SET DATE=MM/DD/YY could be given.



HELP



When the HELP command is given the name of command for which help is required, then it reads the information displayed from a file on disk. This file is in the directory specified by the HELP environment item. It defaults to a directory called HELP in the root directory of the drive that MSX-DOS

was booted from.



APPEND



APPEND is not actually defined by default, but when set up is an environment item that has a special meaning to the system. It is used only with standard CP/M programs.



CP/M programs do not know how to use sub-directories because CP/M does not have sub-directories, but instead just has the equivalent of the current directory. When such a program opens a file, it searches for it only within this single directory and thus only has drives and filenames, not paths.



When a CP/M program is run under MSX-DOS and attempts to open a file, it only searches for the filename in the current directory of the appropriate drive. Similarly, when the user types in a filename to a CP/M program it may only contain a drive and filename, and thus also refers only to files in the current directory.



When this search is performed through MSX-DOS, if the file is not found in the current directory, then the APPEND environment item is looked at. If it is not set up then the file has not been found. If set up, then it is assumed to be a path name, and specifies a single alternative directory in which the search for the file continues.



This will only be of use if the CP/M program opens a file and then reads or writes to it. If it attempts to, for example, delete a file or create a file, then APPEND will not be used. Indeed, it may have undesirable effects and for this reason it is recommended that APPEND is used normally only in a batch file which sets it up, executes the CP/M program, and then unsets it again.



Typical uses for APPEND include specifying the directory in which large programs (such as word processors and database programs) find 'overlay' or messages files, and specifying the directory in which compilers, assemblers and linkers find their source and working files. Typical cases for which APPEND is not suitable and may have undesirable effects include editing a file with a wordprocessor when the file to be edited probably cannot be in a directory other than the current one, even if APPEND is set up.



PROGRAM and PARAMETERS



These special environment items are set up by COMMAND2.COM when a transient command is executed and removed when it finishes, and should thus be avoided for general use.



TEMP



When piping is performed (see chapter 5 on Redirection and Piping) it is necessary for COMMAND2.COM to create one or more temporary files, and the TEMP environment item indicates the drive and directory in which these temporary files are to be created. By default, it refers to the root directory of the boot drive, and typically may be changed to refer to a RAM

disk since this increases the speed of piping.



Although the standard MSX-DOS system only uses TEMP for piping, any other programs and utilities that need to create temporary files may also use the TEMP environment item.



UPPER



UPPER controls whether the command line from 80h to be passed to the transient program be converted to uppercase. Any value except 'ON' is interpreted as 'OFF'.



When UPPER is 'OFF' (default), no conversion will be done and the values will be passed to the transient program as they are typed.



When UPPER is 'ON', each character in the command line will be converted to its associated uppercase character and then passed to the transient program. This is compatible to CP/M environment.



REDIR



REDIR controls whether the redirection or piping characters in the command line be processed by COMMAND2.COM. Any value except 'ON' is interpreted as 'OFF'.



When REDIR is 'OFF', the redirection or piping characters will be passed to the transient program as they are typed, and the transient program may process them.



When REDIR is 'ON' (default), the redirection or piping characters will be interpreted and executed by COMMAND2.COM, so they will not be passed to the transient program.



<b>8. ERRORS AND MESSAGES</b> <b>======================</b>

Disk errors



Disk errors occur when a command or program is attempting to access a disk and fails for some reason, such as a disk not being in the drive. When this happens, message and prompt appears which allows the user the either retry the operation which may now work (eg. if a disk has been inserted into the drive), to ignore the operation or to abort the entire command.



An example disk error message and prompt is as follows, and may be given if the disk was taken out whilst drive A: was being accessed:

Not ready reading drive A: Abort, Retry or Ignore (A/R/I)?



The 'not ready' part of the message indicates why the disk operation failed, and other possibilities exist (see below). 'reading' indicates that the command was trying to read the disk, and may be replaced by 'writing' if that is what it was doing. 'drive A:' is the drive in which the disk was attempted to be accessed.



The 'Abort, Retry or Ignore' part indicates the possible actions that can be taken by the user, and these are selected by pressing the 'A', 'R' or 'I' key.



If Abort is selected, then the entire command is aborted and the message 'Disk operation aborted' is printed before another command can be typed.



If Retry is selected then the failed disk operation will simply be retried and may fail again or may work, particularly if some corrective action has been taken such as inserting a missing disk.



Ignore causes the failed disk operation to be ignored by the command. In many cases, ignoring an error may not be recommended and in these cases the Ignore option will not even be displayed, although it may still be selected.

Doing so may however cause serious system malfunction and could destroy data on the disk. Even if the Ignore option is displayed, it should be used with extreme caution, and only when all else fails. Normally Ignore is only used when the data on a disk has got corrupted and ignoring the disk error offers the only possibility of recovering all or part of the data.



A few serious errors which generally mean the disk has been corrupted beyond possible use are automatically aborted, and just the appropriate error message is printed (eg. 'Bad file allocation table').



The possible errors that can occur as disk errors and their meanings are, in alphabetical order, as follows:

Bad file allocation table



The disk contains an invalid file allocation table (FAT). The FAT is an area on disk in which the system keeps information to tell it where on the disk the data in each file is stored. Thus if the FAT is invalid, it cannot read any data at all. This message usually means that the disk has been corrupted beyond possible use.



Cannot format this drive



An attempt was made to format a disk in a drive that does not support disk formatting. This probably means that a FORMAT command was given specifying the RAM disk.



Data error



The data was read or written without error, but the CRC check failed.

This usually means the disk has been corrupted.



Disk error



The data could not be read or written to the disk.



Incompatible disk



An attempt was made to access 2D or 1D disk or a double sided disk in a single sided drive.



Not a DOS disk



The disk is not a format that MSX-DOS can read. For example, although MSX-DOS can execute CP/M programs it cannot access CP/M disks.



Not ready



The disk is not in the drive being accessed. The disk should be inserted into the drive and 'Retry' selected.



Sector not found



MSX-DOS tried to read or write to a non-existent sector. May indicate that the disk has been corrupted.



Seek error



The requested track on the disk could not be found. Could mean a corrupted disk or faulty disk drive.



Unformatted disk



The disk has not been formatted. Use the FORMAT command on the disk before accessing it.



Verify error



Only occurs when verify is on, and means that data appeared to be written to disk successfully but when read back was found to be different to that written.



Write error



Data was not written correctly.



Write protected disk



The disk is write protected and an attempt was made to write data to it.

The disk should be made unprotected and 'Retry' selected.



Wrong disk and Wrong disk for file



MSX-DOS accessed a disk once and subsequently needed to access it again, but found that the drive contained a different one. The correct disk should be inserted and 'Retry' selected.



Command Errors



Command errors occur when a command cannot perform it's intended function for some reason.



If an error occurs in a command and it is unlikely to be able to continue, then an appropriate error message is printed, and the next command is read at the prompt.



An example error message is:

*** File not found

The three asterisks *** are printed first to indicate that an error has occurred. The message is then printed, followed by the normal command prompt on the next line. The possible errors that can occur are listed below.



When a command error occurs in a specific situation, an 'error type'

message may also be printed. For example, generally when a required file cannot be found on disk, the 'File not found' message is printed as in the above example. However, if the file required is a file specified by the redirection symbol < (see chapter 5 on Redirection and Piping) then the message printed will be:



*** Redirection error: File not found

The possible error types are:

Batch file error:



An error occurred whilst attempting to read from a batch file, for example a disk error occurred and 'abort' was selected.



Piping error:



The error occurred during a piping operation, probably in connection with the temporary files that COMMAND2.COM creates (see chapter 5 on Redirection and Piping). For example, the TEMP environment item did not refer to a valid drive or directory (see chapter 7 on Environment Items).



Redirection error:



The error occurred during a redirection operation. For example, an invalid filename was specified after a redirection symbol <, > or >>, or the specified input file was not found (see chapter 5 on Redirection and Piping).



Standard input error:



An error occurred on the standard input to a command or program after redirection or piping has been set up, for example the standard input has been redirected from a file and the end of the file has been reached.



Standard output error:



An error occurred on the standard output of a command or program after redirection or piping has been set up, for example the standard output has been redirected to a file and the disk is full.



Many commands operate on files or directories, and if an ambiguous filename is given then the command operates on several files or directories (for example the RENAME command or the COPY command). Often an error occurs when it is trying to perform the command on one of the files, but which may be successful on one of the other files. In this case, the filename is printed followed by the error message and the command then continues. For example:



COMMAND2.COM -- File cannot be copied onto itself

The possible command errors that can be given are, in alphabetical order, as follows:



Cannot concatenate destination file



This error is given by CONCAT and means that one of the filenames matched by the source file specification is the destination file. This is not necessarily wrong but may indicate a mistake in the command.



Cannot create destination file



This is given by COPY, and usually means that the destination file for the file it is copying would, if it was created, overwrite a file that was already in use. This is likely to be a previously copied source file but may be some other file such as the currently executing batch file.



Cannot overwrite previous destination file

This is given by COPY, and means that the destination file for the file it is copying would, if it was created, overwrite the destination file of the file that was previously copied. This usually means that the intended destination was a directory but that it's name was misspelled.



Cannot transfer above 64K



This should not normally occur from commands.



Command too long



A command that was given is too long. This will not occur when typing commands from the keyboard, but may occur from a batch file. The maximum length of a command is 127 characters after % parameter substitution.



Ctrl-C pressed



The command was interrupted by pressing CTRL-C.



Ctrl-STOP pressed



The command was interrupted by pressing CTRL-STOP.



Directory exists



A command attempted to create a new file or directory on disk with the same name as an existing directory.



Directory not empty



The RMDIR (RD) command tried to remove a directory that contains files or other directories. These must be deleted first with the ERASE and RMDIR

commands since directories must be empty before they can be removed.



Directory not found



A directory command (eg. RNDIR) could not find the specified directory.



Disk full



There is no more room on the disk and files will have to be deleted and the command given again.



Disk operation aborted



A disk error occurred and the 'Abort' option was chosen, thus aborting the whole command.



Duplicate filename



RENAME (REN) or RNDIR cannot perform the specified rename because the new filename is the same as a filename that already exists. Also occurs from MOVE

or MVDIR because a filename already exists in the destination directory with the same name as the file or directory being moved.



End of file



This should not normally occur from commands.



Environment string too long



This should not normally occur from commands.



Error on standard input



This should not normally occur from commands, and means that an error occurred while a command was attempting to read from the keyboard.



Error on standard output



This should not normally occur from commands, and means that an error occurred while a command was attempting to write to the screen.



File access violation



This should not normally occur from commands.



File allocation error



This should not normally occur from commands.



File cannot be copied onto itself



The destination file when trying to do a COPY is the same file as the source.



File exists



MKDIR (MD) tried to create a new directory but a file with the same name already exists in the specified directory.



File for HELP not found



The HELP command looked for a file to get the help text from but could not find it. Help files are usually kept in a directory called \HELP on the boot disk.



File handle not open



This should not normally occur from commands.



File is already in use



A command tried to modify a file that is already being used for some other purpose, such as the currently executing batch file.



File not found



A command could not find the specified file or files.



Internal error



This should not normally occur from commands.



Invalid MSX-DOS call



This should not normally occur from commands.



Invalid attributes



Usually means an invalid +/- attribute was specified in ATTRIB or ATDIR.



Invalid date



The date typed into the DATE command is not a valid date or was typed in in an invalid format.



Invalid device operation



A command cannot perform it's function on one of the built-in system devices eg. a file cannot be renamed CON.



Invalid directory move



MVDIR attempted to move a directory into one of it's own descendant directories, which cannot be done.



Invalid drive



A drive that does not exist was specified.



Invalid environment string



The name of an environment item contains invalid characters. Only those characters valid in filenames are valid in environment item names.



Invalid file handle



This should not normally occur from commands.



Invalid filename



A filename contains invalid characters. This may be a filename explicitly given, or may be the result of attempting to rename a file with an ambiguous new name.



Invalid number



A number given in a command contained non-digit characters.



Invalid option



An invalid letter was given after a / on a command line.



Invalid . or .. operation



A command cannot perform it's function on the special '.' and '..'

directories that are present at the start of all sub-directories.



Invalid parameter



The parameter to a command is generally not valid for that command in some way.



Invalid pathname



A path specified on a command line does not exist or is syntactically incorrect.



Invalid process id



This should not normally occur from commands.



Invalid time



The time typed into the TIME command is not a valid time or was typed in in an invalid format.



Missing parameter



A command expected a parameter but did not find one.



No spare file handles



Should not normally occur from commands.



Not enough memory



Not enough memory is available for the given command. For example, a large program to large to fit into memory or not enough memory for a new environment string.



Not enough memory, system halted



This special error message is printed when MSX-DOS attempts to start up and finds that there is not enough memory to continue. As the message suggests, the computer must then be reset. This should normally occur.



Pathname too long



A path is too long. Either the length of the pathname given exceeds 100

characters, or the total length of a path from the root directory to a file is more than 63 characters.



RAM disk already exists



Should not normally occur from commands.



RAM disk does not exist



The RAMDISK command was used to display the current size of the RAM

disk, but no RAM disk exists.



Read only file



An attempt was made to modify or overwrite a file marked as read only.

The DIR command shows this, and the ATTRIB command can make it not read only.



Root directory full



The fixed maximum number of files in the root directory (often 64 or 112) has been reached. Directories do not have this limitation.



System file exists



An attempt was made to create a file which would, if it was created, overwrite a file that is marked as a system file. System files are not used in MSX-DOS, and are not shown by the DIR command or accessible from any other commands, and so this error should not normally occur with commands.



Too many parameters



All the parameters a command expected were found on a command line, but there were still more parameters left on the end of the line.



Unrecognized command



A given command was not an internal command or an external COM or BAT

command found along the current search path as set by the PATH command.



Wrong version of command



After executing a program, COMMAND2.COM tried to re-load itself from the COMMAND2.COM file on disk, and found it was not the same version. A prompt is then printed and COMMAND2.COM will attempt to re-load itself again.



Wrong version of MSX-DOS, system halted

This special error message is printed when MSX-DOS attempts to starts up and finds that some other part of the MSX-DOS system has a version number earlier than required. As the message suggests, the computer must then be reset. This should not normally occur.



Internally, errors are represented as error numbers. The numbers corresponding to the errors above start at 255 and decrease. If an error number is received for which there is no message, then it is printed. Numbers above 64 are reserved for future version of MSX-DOS and so are called 'system errors' and numbers below 63 can be used by external commercially available programs and are called 'user errors'. User errors below 32 never print a message. The two default error messages (which will not normally occur from commands) are thus:



System error 64



and



User error 63



where the 64 and 63 are example error numbers. The only command which uses error numbers is the EXIT command. A list of the actual numbers for the above messages is available in the Program Interface specification.



Prompt Messages



There are several situations in which user interaction is required before the system can continue with what it was doing, typically inserting a disk. Also many potentially dangerous commands require confirmation prompts to be answered before they perform their operation. These various system prompts are given below.



All data on drive A: will be destroyed Press any key to continue...



This prompt is given by the FORMAT command, and is issued to reduce the risk of accidentally formatting the wrong disk. To abort the FORMAT command, control-STOP or control-C can be pressed.



Destroy all data on RAM disk (Y/N)?



A RAMDISK command was given to set up a RAM disk, but a RAM disk already existed. If the response to the prompt is 'Y', then any files on this existing RAM disk will be destroyed. A response of 'N' or control-STOP or control-C will abort the command.



Disk in drive A: will only be able to boot MSX-DOS

Press any key to continue...



This prompt is given by the FIXDISK command, and is issued to reduce the risk of accidentally updating a non-MSX-DOS 2 disk. To abort the FIXDISK

command, control-STOP or control-C can be pressed.



Erase all files (Y/N)?



This prompt occurs when a DEL (or ERA or ERASE) command is given specifying all the files in a directory, and is issued to reduce the risk of accidentally deleting a lot of files.



Insert COMMAND2.COM disk in drive A:

Press any key to continue...



This may occur after running a program, and requires a disk containing COMMAND2.COM in the root directory to be present in the specified drive.

After inserting the disk in the drive (which is the drive from which MSX-DOS

was originally booted) and pressing a key, the system will continue as normal. If COMMAND2.COM has been copied somewhere else (eg. a RAM disk) then the SHELL environment item can be set up to make COMMAND2.COM re-load from there instead (see chapter 7 on Environment Items).



Insert batch file disk in drive A:

Press any key to continue...



This may occur during the execution of a batch file, and means that the system needed to read the next command from the batch file but found that the wrong disk was in the drive. After inserting the disk in the specified drive (which will be the drive from which the batch file was originally started) and pressing a key, execution of the batch file will continue as normal.



Press any key to continue...



This prompt is generally issued when some user interaction is required, and is normally printed after some other message which describes the action required. It is also printed by the PAUSE command. To abort the command that issued the prompt, control-STOP or control-C can be pressed.



Terminate batch file (Y/N)?



When MSX-DOS aborts a command prematurely (such as when the control-STOP or control-C key is pressed) and the command was executing in a batch file, this prompt is issued. If the response is 'Y' then the batch file will also be aborted. If 'N' is the response then the batch file will continue with the command that follows the aborted command.



<b>9. COMMAND SUMMARY</b>

<b>==================</b>



The following is a list of all the standard commands available in MSX-DOS, together with their syntax and purpose.



ASSIGN [d: [d:]]



Sets up the logical to physical translation of drives.



ATDIR +|-H [/H] [/P] compound-filespec

Changes the attributes of directories to make them hidden/not hidden.



ATTRIB +|- R|H [/H] [/P] compound-filespec

Changes the attributes of files to make them hidden/not hidden and read only/not read only.



BASIC [program]



Transfers control to MSX disk BASIC.



BUFFERS [number]



Displays or changes the number of disk buffers in the system.



CD [d:] [path]



Displays or changes the current directory.



CHDIR [d:] [path]



Displays or changes the current directory.



CHKDSK [d:] [/F]



Checks the integrity of the files on the disk.



CLS



Clears the screen.



COMMAND2 [command]



Invokes the command interpreter.



CONCAT [/H] [/P] [/B] [/V] compound-filespec filespec

Concatenates (joins together) files.



COPY [/A] [/H] [/T] [/V] [/P] compound-filespec [filespec]



Copies data from files or devices to other files or devices.



DATE [date]



Displays or sets the current date.



DEL [/H] [/P] compound-filespec



Deletes one or more files.



DIR [/H] [/W] [/P] [compound-filespec]



Displays the names of files on disk.



DISKCOPY [d: [d:]] [/X]



Copies one disk to another.



ECHO [text]



Prints text in a batch file.



ERA [/H] [/P] compound-filespec



Deletes one or more files.



ERASE [/H] [/P] compound-filespec



Deletes one or more files.



EXIT [number]



Exits COMMAND2.COM to the invoking program.



FIXDISK [d:] [/S]



Updates a disk to the full MSX-DOS 2 format.



FORMAT [d:]



Formats (initializes) a disk.



HELP [subject]



Provides on-line help for an MSX-DOS feature.



MD [d:] path



Creates a new sub-directory.



MKDIR [d:] path



Creates a new sub-directory.



MODE number



Changes the number of characters/line on the screen.



MOVE [/H] [/P] compound-filespec [path]



Moves files from one place to another on a disk.



MVDIR [/H] [/P] compound-filespec [path]



Moves directories from one place to another on a disk.



PATH [ [+|-] [d:]path [ [d:]path [ [d:]path ...]] ]



Displays or sets the COM and BAT command search path.



PAUSE [comment]



Prompts and waits for a key press in a batch file.



RAMDISK [number[K]] [/D]



Displays or sets the RAM disk size.



RD [/H] [/P] compound-filespec



Removes one or more sub-directories.



REM [comment]



Introduces a comment in a batch file.



REN [/H] [/P] compound-filespec filename

Renames one or more files.



RENAME [/H] [/P] compound-filespec filename

Renames one or more files.



RMDIR [/H] [/P] compound-filespec



Removes one or more sub-directories.



RNDIR [/H] [/P] compound-filespec filename

Renames one or more sub-directories.



SET [name] [separator] [value]



Displays or sets environment items.



TIME [time]



Displays or sets the current time.



TYPE [/H] [/P] [/B] compound-filespec | device

Displays data from a file or device.



UNDEL filespec



Recovers a previously deleted file.



VER



Displays the system's version numbers.



VERIFY [ON | OFF]



Displays/sets the current disk write verify state.



VOL [d:] [volname]



Displays or changes the volume name on a disk.



XCOPY [filespec [filespec]] [/A][/E][/H][/M][/P][/S][/T][/V][/W]



Copies files and directories from one disk to another.



XDIR [filespec] [/H]



Lists all files within directories.



<b>10. DISK-BASIC 2.0</b>

<b>==================</b>



Overview



When the system disk (the one which contains MSXDOS2.SYS and COMMAND2.COM) does not exist at the system startup, or when MSX-DOS BASIC

command is executed, DISK-BASIC 2.0 will be started.



DISK-BASIC 2.0 is the extended version of previous DISK-BASIC 1.0.

Instructions to operate with the RAM disk or the directory has been added or extended.



Description of Commands



<b>CALL CHDIR</b>



Format CALL CHDIR("[d:][path]")



Purpose Set or display current directory

Example CALL CHDIR("WORK")



Description The function is the same as MSX-DOS CHDIR. See CHDIR.



<b>CALL CHDRV</b>



Format CALL CHDRV("[d:]")



Purpose Switch default drive



Example CALL CHDRV("H:")



Description The same action is taken as when the drive name is given at MSX-DOS prompt.



<b>CALL MKDIR</b>



Format CALL MKDIR("[d:][path]")



Purpose Create new subdirectory



Example CALL MKDIR("WORK")



Description The function is the same as MSX-DOS MKDIR. See MKDIR.



<b>CALL RMDIR</b>



Format CALL RMDIR("[d:][path]")



Purpose Remove one or more subdirectories

Example CALL RMDIR("WORK")



Description The function is the same as MSX-DOS RMDIR. See RMDIR.



<b>CALL RAMDISK</b>



Format CALL RAMDISK[([number][, variable name])]



Purpose Set size of RAM disk or assign it into a variable

Example CALL RAMDISK(32)

CALL RAMDISK(1000, A)

Description The function is the same as MSX-DOS RAMDISK. See RAMDISK.



<b>CALL SYSTEM</b>



Format CALL SYSTEM

or

CALL SYSTEM[("DOS command name")]



Purpose Pass control back to MSX-DOS



Example CALL SYSTEM("WORK")



Description CALL SYSTEM passes the control back to MSX-DOS. The command name may be given to specify the operation to be executed after the control returns to DOS. If no command name is specified, REBOOT.BAT in the root directory on the boot drive, if any, will be executed.



<b>FILES</b>



Format FILES["filename"][, L]



Purpose Display names of files and directories on disk

Example FILES"W*.*"



Description The function is the same as MSX-DOS DIR. See DIR. "FILES, L"

displays the names in the long format.



</code>

* * * * *





<code><b> M S X -- D O S v e r s i o n 2

=================================



</b> The advanced disk operating system



for MSX 2 computers



This document is not complete yet:



<b>1. INTRODUCTION</b>

This manual describes the environment which MSX-DOS 2 provides for transient programs on MSX 2 computers. It is intended as a guide for writing new programs to run under MSX-DOS 2 and also to assist in converting existing CP/M and MSX-DOS 1 programs to take advantage of the advanced features.



MSX-DOS 2 provides many enhancements to the standard CP/M and MSX-DOS 1 environment, but is largely compatible with existing programs.

The main features include:



MS-DOS style tree structured directories File handles

Environment strings

Proper error handling



Many extra DOS calls are implemented, and these are accessed via the DOS entry jump at address 5 (the 'BDOS' jump in CP/M). The descrip-tions of the individual functions can be found in the "Function Codes specification".



----



<b>5. MAPPER SUPPORT ROUTINES</b>



MSX-DOS 2 contains routines to provide support for the memory mapper. This allows MSX application programs or MSX-DOS transient programs to utilize more than the basic 64k of memory, without conflicting with the RAM disk or any other system software.



<b> 5.1 MAPPER INITIALISATION</b>



When the DOS kernel is initialized it checks that there is the memory mapper in the system, and that there is at least 128k of RAM available. If the kernel has found at least one slot which contains 128k of the mapper RAM, it selects the slot which contains the largest amount of RAM (or the slot with the smallest slot number, if there are two or more mapper slots which have the same amount of RAM) and makes that slot usable as the system RAM.

When there is not enough memory on the memory mapper, MSX-DOS 2

won't start.



Next the kernel builds up a table of all the 16k RAM segments available to this slot (primary mapper slot). The first four segments (64k) for the user and the two highest numbered segments are allocated to the system, one for the DOS kernel code and one for the DOS kernel workspace. All other segments (at least two) are marked as free initially. Then the kernel builds up the similar tables for other RAM slots, if any. All of these segments are marked as free initially.



<b> 5.2 MAPPER VARIABLES AND ROUTINES</b>

The mapper support routines use some variables in the DOS system area. These tables may be referred and used by the user programs for the various purposes, but must not be altered. The contents of the tables are as follows:

address function





+0 Slot address of the mapper slot


+1 Total number of 16k RAM segments. 1...255

(8...255 for the primary)





+2 Number of free 16k RAM segments


+3 Number of 16k RAM segments allocated to the system (at least 6 of the primary) +4 Number of 16k RAM segments allocated to the user.

+5...+7 Unused. Always zero.

+8... Entries for other mapper slots. If there is none, +8 will be zero.



A program uses the mapper support code by calling various subroutines. These are accessed through a jump table which is located in the MSX-DOS system area. The consists of the jump table are as follows:



address entry name function

+0H ALL_SEG Allocate a 16k segment.

+3H FRE_SEG Free a 16k segment.

+6H RD_SEG Read byte from address A:HL to A.

+9H WR_SEG Write byte from E to address A:HL.

+CH CAL_SEG Inter-segment call. Address in Iyh:IX

+FH CALLS Inter-segment call. Address in line after the call instruction.

+12H PUT_PH Put segment into page (HL).

+15H GET_PH Get current segment for page (HL) +18H PUT_P0 Put segment into page 0.

+1BH GET_P0 Get current segment for page 0.

+1EH PUT_P1 Put segment into page 1.

+21H GET_P1 Get current segment for page 1.

+24H PUT_P2 Put segment into page 2.

+27H GET_P2 Get current segment for page 2.

+2AH PUT_P3 Not supported since page-3 must never be changed. Acts like a "NOP" if called.

+2DH GET_P3 Get current segment for page 3.



A program can use the extended BIOS calls for the mapper support to obtain these addresses. The calls are provided because these addresses may be changed in the future version, or to use mapper routines other than MSX-DOS mapper support routines.



To use the extended BIOS, the program should test "HOKVLD" flag at FB20h in page-3. If bit-0 (LSB) is 0, there is no extended BIOS nor the mapper support. Otherwise, "EXTBIO" entry (see below) has been set up and it can be called with various parameters. Note that this test is unnecessary for the applications which are based on MSX-DOS (such as the program which is loaded from the disk), and the program may proceed to the next step.



Next, the program sets the device number of the selected BIOS in register D, the function number in register E, and required parameters in other registers, and then calls "EXTBIO" at FFCAh in page-3. In this case, the stack pointer must be in page-3.

If there is the extended BIOS for the specified device number, the contents of the registers AF, BC, and HL are modified according to the function; otherwise, they are preserved.

Register DE is always preserved. Note that in any cases the contents of the alternative registers (AF', BC', DE' and HL') and the index registers (IX and IY) are corrupted.



The functions available in the mapper support extended BIOS are:

* Get mapper variable table

Parameter: A = 0

D = 4 (device number of mapper support) E = 1

Result: A = slot address of primary mapper DE = reserved

HL = start address of mapper variable table

* Get mapper support routine address

Parameter: A = 0

D = 4

E = 2

Result: A = total number of memory mapper segments B = slot number of primary mapper C = number of free segments in primary mapper DE = reserved

HL = start address of jump table

In these mapper support extended BIOS, register A is not required to be zero. Note that, however, if there is no mapper support routine, the contents of registers will not be modified, and the value which is not zero will be returned in A otherwise. Thus, the existence of the mapper support routine can be determined by setting zero in A at the calling and examining the returned value of A.



The slot address of the primary mapper returned by the extended BIOS is the same as the current RAM slot address in page-3, and, in the ordinary environment (DISK-BASIC and MSX-DOS), the same RAM slot is also selected in page-2. In MSX-DOS, this is also true in page-0 and page-1.



<b> 5.3 USING MAPPER ROUTINES</b>



A program can request a 16k RAM segment at any time by calling the "ALL_SEG" routine. This either returns an error if there are no free segments, or the segment number of a new segment which the program can use. A program must not use any segment which it has not explicitly allocated, except for the four segments which make up the basic 64k of RAM.



A segment can be allocated either as a user segment or as a system segment. User segments will be automatically freed, when the program terminates, whereas system segments are never freed unless the program frees them explicitly. Normally, programs should allocate user segments.



RAM segments can be accessed by the "RD_SEG" and "WR_SEG"

routines which read and write bytes to specified segments. The routines "CAL_SEG" and "CALLS" allow inter-segment calls to be done in much the same way as inter-slot calls in the current MSX

system.



Routines are provided to explicitly page a segment in, or to find out which segment is in a particular page. There are routines in which the page (0...3) is specified by the top two bits of an address in HL ("PUT_PH" and "GET_PH"). And there are also specific routines for accessing each page ("GET_Pn" and "PUT_Pn"). These routines are very fast so a program should not suffer in performance by using them.



Note that page-3 should never be altered since this contains the mapper support routines and all the other system variables. Also great care must be taken if page-0 is altered since this contains the interrupt and the slot-switching entry-points. Pages 1 and 2

can be altered in any way.



None of the mapper support routines will disturb the slot selection mechanism at all. For example when "PUT_P1" is called, the specified RAM segment will only appear at address 4000h...7FFFh if the mapper slot is selected in page-1. The "RD_SEG" and "WR_SEG" routines will always access the RAM segment regardless of the current slot selection in the specified page, but the mapper RAM slot must be selected in page-2.



<b> 5.4 ALLOCATING and FREEING SEGMENTS</b>

The following two routines can be called to allocate or free segments. All registers apart from AF and BC are preserved. An error is indicated by the carry flag being set on return. The slot selection and RAM paging may be in any state when these routines are called and both will be preserved. The stack must not be in page-0 or page-2 when either of these routines are called.



A program must not use any segment (apart from the four which make up the basic 64k) unless it has specifically allocated it, and must not continue to use a segment after it has been freed.



A segment may be allocated either as a user or a system segment.

The only difference is that user segments will be automatically freed when the program terminates whereas system segments will not be. In general a program should allocate a user segment unless it needs the data in the segment to outlast the program itself. User segments are always allocated from the lowest numbered free segment and system segments from the highest numbered one.



An error from "allocate segment" usually indicates that there are no free segments, although it can also mean that an invalid parameter was passed in register A and B. An error from "free segment" indicates that the specified segment number does not exist or is already free.



ALL_SEG - Parameters: A=0 => allocate user segment A=1 => allocate system segment B=0 => allocate primary mapper B!=0 => allocate

FxxxSSPP slot address (primary mapper, if 0) xxx=000 allocate specified slot only xxx=001 try to allocate specified slot and, if it failed, try another slot (if any) xxx=011 try to allocate other slots than specified and, if it failed, try specified slot

Results: Carry set => no free segments Carry clear => segment allocated A=new segment number

B=slot address of mapper slot (0 if called as B=0)



FRE_SEG - Parameters: A=segment number to free B=0 primary mapper

B!=0 mapper other than primary Returns: Carry set => error Carry clear => segment freed OK



<b> 5.5 INTER-SEGMENT READ AND WRITE</b>

The following two routines can be called to read or write a single byte from any mapper RAM segment. The calling sequence is very similar to the inter-slot read and write routines provided by the MSX system ROM. All registers apart from AF are preserved and no checking is done to ensure that the segment number is valid.



The top two bits of the address are ignored and the data will be always read or written via page-2, since the segment number specifies a 16k segment which could appear in any of the four pages. The data will be read or written from the correct segment regardless of the current paging or slot selection in page-0 or page-1, but note that the mapper RAM slot must be selected in page-2 when either of these routines are called. This is so that the routines do not have to do any slot-switching and so can be fast. Also the stack must not be in page-2. These routines will return disabling interrupts.



RD_SEG - Parameters: A = segment number to read from HL = address within this segment Results: A = value of byte at address All other registers preserved

WR_SEG - Parameters: A = segment number to write to HL = address within this segment Returns: A = corrupted

All other registers preserved

<b> 5.6 INTER-SEGMENT CALLS</b>



Two routines are provided for doing inter-segment calls. These are modelled very closely on the two inter-slot call routines provided by the MSX system ROM, and the specification of their usage is very similar.



No check is done that the called segment actually exists so it is the user's responsibility to ensure this. The called segment will be paged into the specified address page, but it is the user's responsibility to ensure that the mapper slot is enabled in this page, since neither of these routines will alter the slot selection at all. This is to ensure that they can be fast.



The routine cannot be used to do an inter-segment call into page-3. If this is attempted then the specified address in page-3

will be simply called without any paging, since page-3 must never be altered. Calling into page-0 must be done with some care because of the interrupt and other entry point. Also care must be taken that the stack is not paged out by these calls.



These routines, unlike inter-slot calls, do not disable interrupts before passing control to the called routine. So they return to the caller in the same state as before, unless the interrupt flag was modified by the called routine.



Interrupts.



Parameters cannot be passed in registers IX, IY, AF', BC', DE' or HL' since these are used internally in the routine. These registers will be corrupted by the inter-segment call and may also be corrupted by the called routine. All other registers (AF, BC, DE and HL) will be passed intact to the called routine and returned from it to the caller.



CAL_SEG - Parameters: IY = segment number to be called IX = address to call

AF, BC, DE, HL passed to called routine Other registers corrupted

Results: AF, BC, DE, HL, IX and IY returned from called routine. All others corrupted.



CALLS - Parameters: AF, BC, DE, HL passed to called routine Other registers corrupted

Calling sequence: CALL CALLS

DB SEGMENT

DW ADDRESS

Results: AF, BC, DE, HL, IX and IY returned from called routine. All others corrupted.



<b> 5.7 DIRECT PAGING ROUTINES</b>



The following routines are provided to allow programs to directly manipulate the current paging state without having to access the hardware. Using these routines ensures compatibility with any changes to the details of the hardware. The routines are very fast and so using them will not compromise the performance of programs.



Routines are provided to directly read or write to any of the four page registers. No checking of the validity of the segment number is done so this is the user's responsibility. Note that the value written in the register is also written in memory and, if the register value is requested, the value stored in memory will be returned and the one in the register will never be read directly. This is done to avoid errors from hardware conflicts when there are two or more mapper registers in the system. The user should always manipulate the memory mapper through these routines.



The "GET" routines return values from internal images of the registers without actually reading the registers themselves.

This ensures that if a segment is enabled by, for example, "PUT_P1" then a subsequent "GET_P1" call will return the actual value. Reading the mapper register may produce a different value because the top bits of the segment numbers are generally not recorded.



Although a "PUT_P3" routine is provided, it is in fact a dummy routine and will not alter the page-3 register. This is because the contents of the page-3 register should never be altered. The "GET_P3" routine does behave as expected to allow the user to determin what segment is in page-3.



Another pair of routines ("GET_PH" and "PUT_PH") is provided which are identical in function except that the page is specified by the top two bits of register H. This is useful when register HL contains an address, and these routines do not corrupt register HL. "PUT_PH" will never alter the page-3 register.



PUT_Pn - Parameters: n = 0,1,2 or 3 to select page A = segment number

Results: None

All registers preserved



GET_Pn - Parameters: n = 0,1,2 or 3 to select page Results: A = segment number All other registers preserved

PUT_PH - Parameters: H = high byte of address A = segment number

Results: None

All registers preserved



GET_PH - Parameters: H = high byte of address Results: A = segment number All other registers preserved

Before using these direct paging routines to alter the paging state, a program should first use the "GET_Pn" routines to determine the initial four segments for when it needs to restore these. No program should assume fixed values for these initial segments since they are likely to change in future versions of the systems.



</code>





<code><b> M S X -- D O S v e r s i o n 2

=================================



</b> The advanced disk operating system

for MSX 2 computers

CONTENTS Page



1. Introduction ............................ 3

2. List of functions ....................... 4

3. Function By Function Definitions ........ 7

3.1 \

. . \ Definitions of each function . . /

3.90 /



This manual describes in detail the MSX-DOS function calls provided by MSX-DOS version 2.20



<b>1. INTRODUCTION</b>



This document describes in detail each of the MSX-DOS 2 function calls. It should be read in conjunction with the "Program Interface specification"

which describes system features such as file handles, fileinfo blocks and environment strings in general terms.



There are two ways of doing MSX-DOS function calls, reflecting the two different environments (MSX-DOS and disk BASIC) in which the system can run.

Transient programs running in the MSX-DOS environment must access the functions with a "CALL 00005h" instruction. Disk BASIC and other MSX programs running in the disk BASIC environment (usually executing from ROM) must access the system via a "CALL 0F37Dh" instruction.



There are some limitations when calling the system via 0F37Dh, particularly to do with error handling and abort routines. Also no parameters may be passed in page-1, unless they are in the master disk ROM (as they will be for disk BASIC) since the master disk ROM will be paged into page-1 when such a function call is made. The individual function descriptions mention the differences for particular functions.



<b>2. LIST OF FUNCTIONS</b>

Below there is a complete list of the functions calls. "CPM" indicates that the function is compatible with the equivalent CP/M 2.2 function, "MSX1"

indicates compatibility with MSX-DOS version 1, and "NEW" indicates a function which is new to this system. An asterisk ("*") indicates that the function may be safely called from a user disk error routine (see function 64h and function 70h).



List of MSX-DOS 2 Function Calls



CPM MSX1 00h - Program terminate

CPM MSX1* 01h - Console input CPM MSX1* 02h - Console output CPM MSX1* 03h - Auxiliary input CPM MSX1* 04h - Auxiliary output CPM MSX1* 05h - Printer output CPM MSX1* 06h - Direct console I/O

MSX1* 07h - Direct console input MSX1* 08h - Console input without echo CPM MSX1* 09h - String output CPM MSX1* 0Ah - Buffered line input CPM MSX1* 0Bh - Console status

CPM MSX1* 0Ch - Return version number CPM MSX1 0Dh - Disk reset CPM MSX1 0Eh - Select disk

CPM MSX1 0Fh - Open file (FCB) CPM MSX1 10h - Close file (FCB) CPM MSX1 11h - Search for first entry (FCB) CPM MSX1 12h - Search for next entry (FCB) CPM MSX1 13h - Delete file (FCB) CPM MSX1 14h - Sequential read (FCB) CPM MSX1 15h - Sequential write FCB) CPM MSX1 16h - Create file (FCB) CPM MSX1 17h - Rename file (FCB)

CPM MSX1* 18h - Get login vector CPM MSX1* 19h - Get current drive CPM MSX1 1Ah - Set disk transfer address MSX1 1Bh - Get allocation information 1Ch - Unused

1Dh - Unused

1Eh - Unused

1Fh - Unused

20h - Unused

CPM MSX1 21h - Random read (FCB) CPM MSX1 22h - Random write(FCB) CPM MSX1 23h - Get file size (FCB) CPM MSX1 24h - Set random record (FCB) 25h - Unused

MSX1 26h - Random block write (FCB) MSX1 27h - Random block read (FCB) CPM MSX1 28h - Random write with zero fill (FCB) 29h - Unused

MSX1* 2Ah - Get date MSX1* 2Bh - Set date MSX1* 2Ch - Get time MSX1* 2Dh - Set time MSX1* 2Eh - Set/reset verify flag MSX1* 2Fh - Absolute sector read MSX1* 30h - Absolute sector write NEW* 31h - Get disk parameters

32h - \

. . \ Unused

. . /

3Fh - /



NEW 40h - Find first entry NEW 41h - Find next entry NEW 42h - Find new entry

NEW 43h - Open file handle NEW 44h - Create file handle NEW 45h - Close file handle NEW 46h - Ensure file handle NEW 47h - Duplicate file handle NEW 48h - Read from file handle NEW 49h - Write to file handle NEW 4Ah - Move file handle pointer NEW 4Bh - I/O control for devices NEW 4Ch - Test file handle

NEW 4Dh - Delete file or subdirectory NEW 4Eh - Rename file or subdirectory NEW 4Fh - Move file or subdirectory NEW 50h - Get/set file attributes NEW 51h - Get/set file date and time

NEW 52h - Delete file handle NEW 53h - Rename file handle NEW 54h - Move file handle NEW 55h - Get/set file handle attributes NEW 56h - Get/set file handle date and time

NEW * 57h - Get disk transfer address NEW * 58h - Get verify flag setting NEW 59h - Get current directory NEW 5Ah - Change current directory NEW 5Bh - Parse pathname NEW 5Ch - Parse filename NEW * 5Dh - Check character NEW 5Eh - Get whole path string NEW 5Fh - Flush disk buffers

NEW 60h - Fork a child process NEW 61h - Rejoin parent process NEW 62h - Terminate with error code NEW 63h - Define abort exit routine NEW 64h - Define disk error handler routine NEW * 65h - Get previous error code NEW * 66h - Explain error code

NEW 67h - Format a disk NEW 68h - Create or destroy RAM disk NEW 69h - Allocate sector buffers NEW * 6Ah - Logical drive assignment

NEW * 6Bh - Get environment item NEW * 6Ch - Set environment item NEW * 6Dh - Find environment item

NEW * 6Eh - Get/set disk check status NEW * 6Fh - Get MSX-DOS version number NEW * 70h - Get/set redirection status

<b>3. FUNCTION BY FUNCTION DEFINITIONS</b>

Below are detailed descriptions of each of the MSX-DOS functions including both the old and new ones. The names in brackets after the function numbers are the public labels for the function codes which are defined in "CODES.MAC". Programs should use these names whenever possible.



Many of the functions below 40h return an error flag rather than an error code. If the error flag is set then the actual error code indicating the cause of the error can be obtained by the "get previous error code" function (function 65h). All of the functions above 40h return an error code in register A. The "Program Interface Specification" document describes the general errors which can be returned from many of the functions. The individual function specifications here describe the main error conditions which are specific to particular functions.

Note that many of the function calls which modify the information on a disk do not automatically flush disk buffers and so the disk is not necessarily correctly updated immediately after the function call is made.

Such calls include all types of "create", "write", "delete", "rename", "change file attributes" and "change file date and time" function calls. The only functions which always flush disk buffers are "flush buffers", "close"

and "ensure". After these operations the disk will always be correctly updated.



<b> 3.1 PROGRAM TERMINATE (00H)</b>

Parameters: C = 00H (_TERM0) Results: Does not return

This function terminates program with a zero return code. It is provided for compatibility with MSX-DOS 1 and CP/M, the preferred method of exiting a program is to use the "terminate with error code" function call (function 62h), passing a zero error code if that is what is desired. See the description of that function call, and also the "Program Interface Specification", for details of what happens when a program terminates. This function call never returns to the caller.



<b> 3.2 CONSOLE INPUT (01H)</b>

Parameters: C = 01H (_CONIN) Results: L=A = Character from keyboard

A character will be read from the standard input (file handle 0 - usually the keyboard) and echoed to the standard output (file handle 1 - usually the screen). If no character is ready then this function will wait for one.

Various control characters, as specified for the "console status" function (function 0Bh), will be trapped by this function for various control purposes. If one of these characters is detected then it will be processed and this function will wait for another character. Thus these characters will never be returned to the user by this function.



<b> 3.3 CONSOLE OUTPUT (02H)</b>

Parameters: C = 02H (_CONOUT) E = Character to be output Results: None



The character passed in register E is written to the standard output (file handle 1 - usually the screen). If printer echo is enabled then the character is also written to the printer. Various control codes and escape sequences are interpreted as screen control codes. A list of these is included in the "Program Interface Specification", they are a sub-set of the standard VT-52

control codes. TABs will be expanded to every eighth column.



A console input status check is done, and if any of the special control characters described for the "console status" function (function 0Bh) is found then it will be processed as for that function. Any other character will be saved internally for a later "console input" function call.



<b> 3.4 AUXILIARY INPUT (03H)</b>

Parameters: C = 03H (_AUXIN) Results: L=A = Input character

A character is read from the auxiliary input device (file handle 3) and if no character is ready then it will wait for one. The auxiliary input device must have been installed before this function may be used. If no such device has been installed then this function will always return the end of file character ("Ctrl-Z").



<b> 3.5 AUXILIARY OUTPUT (04H)</b>

Parameters: C = 04H (_AUXOUT) E = Character to be output Results: None



The character passed in register E will be written to the auxiliary output device (file handle 3). The auxiliary output device must have been installed before this function may be used. If no such device has been installed then this function will simply throw the character away.



<b> 3.6 PRINTER OUTPUT (05H)</b>

Parameters: C = 05H (_LSTOUT) E = Character to be output Results: None



The character passed in register E will be sent to the standard printer device (file handle 4 - usually the parallel printer). The same channel is used for console output which is echoed to the printer. TABs are not expanded by this function, although they are expanded when screen output is echoed to the printer with "Ctrl-P".



<b> 3.7 DIRECT CONSOLE I/O (06H)</b>

Parameters: C = 06H (_DIRIO) E = 00H...FEH - character for output = FFH - requests input Results: A=L = input - 00H - no character ready else input character undefined for output

If E=FFh on entry then the keyboard will be examined for a characterfrom the standard input (file handle 0) and 00h returned if no character is ready.

If a character is ready then it will be read from the standard input (file handle 0) and returned in register A without being echoed and with no check for control characters.



If E<>FFh on entry then the character in register E will be printed directly to the standard output (file handle 1) with no TAB expansion or printer echo. Also no console status check is done by this function. Note that although this function does not expand TABs, the VT-52 control codes include TAB expansion so the effect on the screen is the same.



<b> 3.8 DIRECT CONSOLE INPUT (07H)</b>

Parameters: C = 07H (_DIRIN) Results: L=A = Input character

This function is identical to the input option of function 06h, except that if no character is ready it will wait for one. Like function 06h, no echo or control characters checks will be done. This function is not compatible with CP/M which uses this function number for "get I/O byte".



<b> 3.9 CONSOLE INPUT WITHOUT ECHO (08H)</b>

Parameters: C = 08H (_INNOE) Results: L=A = Input character

This function is identical to function 01h except that the input character will not be echoed to the standard output. The same control character checks will be done. This function is not compatible with CP/M which uses this function number for "set I/O byte".



<b> 3.10 STRING OUTPUT (09H)</b>

Parameters: C = 09H (_STROUT) DE = Address of string Results: None



The characters of the string pointed to by register DE will be output using the normal console output routine (function call 02h). The string is terminated by "$" (ASCII 24h).



<b> 3.11 BUFFERED LINE INPUT (0AH)</b>

Parameters: C = 0AH (_BUFIN) DE = Address of an input buffer Results: None



DE must point to a buffer to be used for input. The first byte of this buffer must contain the number of characters which the buffer can hold (0...255). A line of input will be read from the standard input device (file handle 0 - usually the keyboard) and stored in the buffer. The input will be terminated when a CR is read from the standard input. The number of characters entered, which does not include the CR itself, will be stored at (DE+1). If there is room in the buffer then the CR will be stored after the last character.



When inputting from the keyboard (which will normally be the case), a simple line editor is provided, and also a 256 byte circular buffer of previous lines which can be edited and re-entered. The details of these editing facilities are described in the separate "Command Specification"

document, so they are not included here. When the input buffer becomes full, the console bell will be rung for each character typed which cannot be put in the buffer. Each character entered will be echoed to the standard output and also to the printer if printer echo is enabled.



<b> 3.12 CONSOLE STATUS (0BH)</b>

Parameters: C = 0BH (_CONST) Results: L=A = 00H if no key was pressed = FFH if a key was pressed

A flag is returned in register A to indicate whether a character is ready (that is, a key was pressed) for input from the keyboard. If a character is ready then it will be read and tested for certain special control characters.

If it is not one of these then it is stored in an internal single byte buffer and subsequent call to this function will return "character ready"

immediately without checking the keyboard. If this function says that a character is ready then the character may be read by function 02h or 08h.



If the character is "Ctrl-C" then the program will be terminated with a ".CTRLC" error via the user's abort routine if one is defined. If the character is "Ctrl-P" then printer echo will be enabled and it will be disabled if it is "Ctrl-N". If the character is "Ctrl-S" then the routine will hang up waiting for another character to be pressed and then return "no character ready", thus providing a "wait" facility. The character typed to continue operation will be ignored, except that of it is "Ctrl-C" then the program will be terminated. These same input checks are also done for functions 01h, 02h, 08h, 09h and 0Ah.



<b> 3.13 RETURN VERSION NUMBER (0CH)</b>

Parameters: C = 0CH (_CPMVER) Results: L=A = 22H

H=B = 00H



This function simply returns the CP/M version number which is being emulated. This is always version 2.2 in current systems.



<b> 3.14 DISK RESET (0DH)</b>

Parameters: C = 0DH (_DSKRST) Results: None



Any data which is waiting in internal buffers is written out to disk. It is not necessary to call this function in order to allow a disk change as is the case with CP/M. The disk transfer address is also set back to its default value of 80h by this function.



<b> 3.15 SELECT DISK (0EH)</b>

Parameters: C = 0EH (_SELDSK) E = Drive number. 0=A: 1=B: etc.

Results: L=A = Number of drives (1...8)

This function simply selects the specified drive as the default drive. The current drive is also stored at address 0004h for CP/M compatibility. The number of drives available is returned in register A but this will not include the RAM disk.



<b> 3.16 OPEN FILE [FCB] (0FH)</b>

Parameters: C = 0FH (_FOPEN) DE = Pointer to unopened FCB

Results: L=A = 0FFH if file not found = 0 if file is found

The unopened FCB must contain a drive which may be zero to indicate the current drive and a filename and extension which may be ambiguous. The current directory of the specified drive will be searched for a matching file and if found it will be opened. Matching entries which are sub-directories or system files will be ignored, and if the filename is ambiguous then the first suitable matching entry will be opened.



Device names may be put in the FCB (without a colon) to allow devices to be accessed as if they were actually disk files. The standard device names are defined in the "Program Interface Specification".



The low byte of the extent number is not altered by this function, and a file will only be opened if it is big enough to contain the specified extent.

Normally the transient program will set the extent number to zero before calling this function. The high byte of the extent number will be set to zero to ensure compatibility with CP/M.



The filename and extension in the FCB will be replaced by the actual name of the file opened from the directory entry. This will normally be the same as what was there before but may be different if an ambiguous filename or one with lower case letters in was used.



The record count will be set to the number of 128 byte records in the specified extent, which is calculated from the file size. The file size field itself, the volume-id and the 8 reserved bytes will also be set up. The current record and random record fields will not be altered by this function, it is the application program's responsibility to initialize them before using the read or write functions.



If the file cannot be found, then the "APPEND" environment item will be examined. If this is set then it is interpreted as a drive/path string which specifies a second directory in which to look for the file. The specified directory will be searched for the file and if found it will be opened as above. In this case the drive byte of the FCB will be set to the drive on which the file was found to ensure correct accessing of the file if the original drive byte was zero (default).



<b> 3.17 CLOSE FILE [FCB] (10H)</b>

Parameters: C = 10H (_FCLOSE) DE = Pointer to opened FCB

Results: L=A = 0FFH if not successful = 0 if successful

The FCB must have previously been opened with either an OPEN or a CREATE

function call. If the file has only been read then this function does nothing. If the file has been written to then any buffered data will be written to disk and the directory entry updated appropriately. The file may still be accessed after a close, so the function can be regarded as doing an "ensure" function.



<b> 3.18 SEARCH FOR FIRST [FCB] (11H)</b>

Parameters: C = 11H (_SFIRST) DE = Pointer to unopened FCB

Results: L=A = 0FFH if file not found = 0 if file found.



This function searches the current directory of the drive specified in the FCB (default drive if FCB contains zero) for a file which matches the filename and extension in the FCB. The filename may be ambiguous (containing "?" characters) in which case the first match will be found. The low byte of the extent field will be used, and a file will only be found if it is big enough to contain this extent number. Normally the extent field will be set to zero by the program before calling this function. System file and sub-directory entries will not be found.



If a suitable match is found (A=0) then the directory entry will be copied to the DTA address, preceded by the drive number. This can be used directly as an FCB for an OPEN function call if desired. The extent number will be set to the low byte of the extent from the search FCB, and the record count will be initialized appropriately (as for OPEN). The attributes byte from the directory entry will be stored in the S1 byte position, since its normal position (immediately after the filename extension field) is used for the extent byte.



If no match is found (A=0FFh) then the DTA will not be altered. In no case will the FCB pointed to by DE be modified at all. This function remembers sufficient information internally to allow it to continue the search with a SEARCH FOR NEXT function, so it is not necessary for the FCB to be preserved if doing a SEARCH FOR NEXT function.



In CP/M, if the drive number is set to "?" in this function then all directory entries, allocated or free will be matched. Also if the extent field is set to "?" then any extent of a file will be matched. Both of these features are normally only used by special purpose CP/M programs which are generally specific to the CP/M filing system (such as "STAT"). Neither feature is present in MSX-DOS 1/2.



<b> 3.19 SEARCH FOR NEXT [FCB] (12H)</b>

Parameters: C = 12H (_SNEXT) Results: L=A = 0FFH if file not found = 0 if file found.



It continues the search to look for the next match with the filename. The results returned from this function are identical to SEARCH FOR FIRST and all the same comments apply. The information used to continue the search is held internally within MSX-DOS and so the original FCB used in the SEARCH FOR

FIRST need not still exist.



<b> 3.20 DELETE FILE [FCB] (13H)</b>

Parameters: C = 13H (_FDEL) DE = Pointer to unopened FCB

Results: L=A = 0FFH if no files deleted = 0 if files deleted OK



All files in the current directory of the disk specified by the FCB, and which match the ambiguous filename in the FCB, are deleted. Sub-directories, system files, hidden files and read only files are not deleted. If any files at all are successfully deleted then this function returns with A=0. A return with A=FFh indicates that no files were deleted.



<b> 3.21 SEQUENTIAL READ [FCB] (14H)</b>

Parameters: C = 14H (_RDSEQ) DE = Pointer to opened FCB

Results: L=A = 01H if error (end of file) = 0 if read was successful

This function reads the next sequential 128 byte record from the file into the current disk transfer address. The record is defined by the current extent (high and low bytes) and the current record. After successfully reading the record, this function increments the current record and if it reaches 080h, sets it back to zero and increments the extent number. The record count field is also kept updated when necessary.



Unlike CP/M it is possible to have partially filled records, since the file size is not necessarily a multiple of 128 bytes. If this occurs then the partial record is padded out with zeroes when it is copied to the transient program's DTA address.



<b> 3.22 SEQUENTIAL WRITE [FCB] (15H)</b>

Parameters: C = 15H (_WRSEQ) DE = Pointer to opened FCB

Results: L=A = 01H if error (disk full) = 0 if write was successful

This function writes the 128 bytes from the current disk transfer address to the file at the position defined by the current record and extent, which are then incremented appropriately. The record count byte is kept updated correctly if the file is extended or if the write moves into a new extent.

The file size in the FCB is also updated if the file is extended.



<b> 3.23 CREATE FILE [FCB] (16H)</b>

Parameters: C = 16H (_FMAKE) DE = Pointer to unopened FCB

Results: L=A = 0FFH if unsuccessful = 0 if successful

This function creates a new file in the current directory of the specified drive and opens it ready for reading and writing. The drive, filename and low byte of the extent number must be set up in the FCB and the filename must not be ambiguous. Checks will be done to ensure that invalid filenames are not created.



If there is already a file of the required name then the action depends on the value of the extent number byte. Normally this will be zero and in this case the old file will be deleted and a new one created. However if the extent number is non-zero then the existing file will be opened without creating a new file. This ensures compatibility with early versions of CP/M

where each extent had to be explicitly created.



In all cases the resulting file will be opened with the required extent number exactly as if an OPEN function call had been done.



<b> 3.24 RENAME FILE [FCB] (17H)</b>

Parameters: C = 17H (_FREN) DE = Pointer to unopened FCB

Results: L=A = 0FFH not if successful = 0 if successful

The unopened FCB has the normal drive and filename, and also a second filename starting at (DE+17). Every file in the current directory of the specified drive which matches the first filename, is changed to the second filename with "?" characters in the second filename leaving the appropriate character unchanged. Checks are done to prevent duplicate or illegal filenames from being created. Entries for sub-directories, hidden files and system files will not be renamed.



<b> 3.25 GET LOGIN VECTOR (18H)</b>

Parameters: C = 18H (_LOGIN) Results: HL = Login vector

This function returns a bit set in HL for each drive which is available, bit-0 of L corresponding to drive "A:". Up to eight drives ("A:" to "H:") are supported by the system currently, so register H will usually be zero on return.



<b> 3.26 GET CURRENT DRIVE (19H)</b>

Parameters: C = 19H (_CURDRV) Results: L=A = Current drive (0=A: etc)

This function just returns the current drive number.



<b> 3.27 SET DISK TRANSFER ADDRESS (1AH)</b>

Parameters: C = 1AH (_SETDTA) DE = Required Disk Transfer Address Results: None



This function simply records the address passed in DE as the disk transfer address. This address will be used for all subsequent FCB read and write calls, for "search for first" and "search for next" calls to store the directory entry, and for absolute read and write calls. It is not used by the new MSX-DOS read and write functions. The address is set back to 80h by a DISK RESET call.



<b> 3.28 GET ALLOCATION INFORMATION (1BH)</b>

Parameters: C = 1BH (_ALLOC) E = Drive number (0=current, 1=A: etc) Results: A = Sectors per cluster BC = Sector size (always 512) DE = Total clusters on disk HL = Free clusters on disk IX = Pointer to DPB

IY = Pointer to first FAT sector

This function returns various information about the disk in the specified drive. It is not compatible with CP/M which uses this function number to return the address of an allocation vector. Note that unlike MSX-DOS 1, only the first sector of the FAT may be accessed from the address in IY, and the data there will only remain valid until the next MSX-DOS call.



<b> 3.29 RANDOM READ [FCB] (21H)</b>

Parameters: C = 21H (_RDRND) DE = Pointer to opened FCB

Results: L=A = 01H if error (end of file)





0 if read was successful




This function reads a 128 byte record from the file to the current disk transfer address. The file position is defined by the three byte random record number in the FCB (bytes 21h...23h). Unlike CP/M all three bytes of the random record number are used. A partial record at the end of the file will be padded with zeroes before being copied to the user's DTA.



The random record number is not altered so successive calls to this function will read the same record unless the transient program alters the random record number. A side effect is that the current record and extent are set up to refer to the same record as the random record number. This means that sequential reads (or writes) can follow a random read and will start from the same record. The record count byte is also set up correctly for the extent.



<b> 3.30 RANDOM WRITE [FCB] (22H)</b>

Parameters: C = 22H (_WRRND) DE = Pointer to opened FCB

Results: L=A = 01H if error (disk full) = 0 if no error

This function writes a 128 byte record from the current disk transfer address to the file, at the record position specified by the three byte random record number (bytes 21h...23h). All three bytes of the random record number are used. If the record position is beyond the current end of file then un-initialized disk space will be allocated to fill the gap.



The random record number field will not be changed, but the current record and extent fields will be set up to refer to the same record. The record count byte will be adjusted as necessary if the file is being extended or if the write goes into a new extent.



<b> 3.31 GET FILE SIZE [FCB] (23H)</b>

Parameters: C = 23H (_FSIZE) DE = Pointer to unopened FCB

Results: L=A = 0FFH if file not found = 0 if file found OK



This function searches for the first match with the filename in the FCB, exactly the same as OPEN FILE (function 0FH). The size of the located file is rounded up to the nearest 128 bytes and the number of records determined. The three byte random record field of the FCB is set to the number of records, so it is the number of the first record which does not exist. The fourth byte of the random record number is not altered.



<b> 3.32 SET RANDOM RECORD [FCB] (24H)</b>

Parameters: C = 24H (_SETRND) DE = Pointer to opened FCB

Results: None



This function simply sets the three byte random record field in the FCB to the record determined by the current record and extent number. The fourth byte of the random record number is not altered. No check is done as to whether the record actually exists in the file.



<b> 3.33 RANDOM BLOCK WRITE [FCB] (26H)</b>

Parameters: C = 26H (_WRBLK) DE = Pointer to opened FCB

HL = Number of records to write Results: A = 01H if error = 0 if no error

Data is written from the current disk transfer address to the position in the file defined by the random record number. The record size is determined by the record size field in the FCB (bytes 0Eh and 0Fh) which must be set by the user after opening the file and before calling this function. If the record size is less than 64 bytes then all four bytes of the random record number are used, otherwise only the first three are used.



The number of records to be written is specified by HL, and together with the record size this determines the amount of data to be written. An error will be returned if the size exceeds 64k, thus limiting the maximum size of a transfer.



After writing the data, the random record field is adjusted to the next record number in the file (ie. HL is added on to it). The current record and extent fields are not used or altered. The file size field is updated if the file has been extended.



The record size can be any value from 1...0FFFFh. Small record sizes are no less efficient that large record sizes so if desired the record size can be set to one and the record count then becomes a byte count. It is desirable to write as much as possible with one function call since one large transfer will be quicker than several small ones.



If the number of records to write (HL) is zero then no data will be written, but the size of the file will be altered to the value specified by the random record field. This may be either longer or shorter than the file's current size and disk space will be allocated or freed as required.

Additional disk space allocated in this way will not be initialized to any particular value.



<b> 3.34 RANDOM BLOCK READ [FCB] (27H)</b>

Parameters: C = 27H (_RDBLK) DE = Pointer to opened FCB

HL = Number of records to read Results: A = 01H if error (usually caused by end-of-file) = 0 if no error HL = Number of records actually read

This function is the complement of the BLOCK WRITE function described above and most of the same comments apply as regards its use. Again if large blocks are read then it will be much faster than the normal CP/M operation.

For example if it is desired to read 20k from a file, it is better to read the 20k with one function call rather than 20 separate function calls of 1k each. However it makes no difference whether the 20k read is done with a record size of 1 and a record count of 20k, with a record size of 20k and a record count of 1, or any intermediate combination.



The number of records actually read is returned in HL. This may be smaller than the number of records requested if the end of the file was encountered.

In this case any partial record will be padded out with zeroes before being copied to the users DTA. The random record field is adjusted to the first record not read, ie. the value returned in HL is added on to it.



<b> 3.35 RANDOM WRITE WITH ZERO FILL [FCB] (28H)</b>

Parameters: C = 28H (_WRZER) DE = Pointer to opened FCB

Results: L=A = 01H if error = 00H if no error

This function is identical to RANDOM WRITE (function 22h) except that if the file has to be extended, any extra allocated disk clusters will be filled with zeroes before writing the data.



<b> 3.36 GET DATE (2AH)</b>

Parameters: C = 2AH (_GDATE) Results: HL = Year 1980...2079

D = Month (1=Jan...12=Dec) E = Date (1...31) A = Day of week (0=Sun...6=Sat)

This function simply returns the current value of the internal calender in the format shown.



<b> 3.37 SET DATE (2BH)</b>

Parameters: C = 2BH (_SDATE) HL = Year 1980...2079

D = Month (1=Jan...12=Dec) E = Date (1...31) Results: A = 00H if date was valid FFH if date was invalid

The supplied date is checked for validity and if it is valid then it is stored as the new date. The validity checks include full checking for the number of days in each month and leap years. If the date is invalid then the current date will be left unaltered. The date is stored in the real time clock chip so it will be remembered when the machine is turned off.



<b> 3.38 GET TIME (2CH)</b>

Parameters: C = 2CH (_GTIME) Results: H = Hours (0...23) L = Minutes (0...59) D = Seconds (0...59) E = Centiseconds (always zero)

This function returns the current value of the system clock in the format shown.



<b> 3.39 SET TIME (2DH)</b>

Parameters: C = 2DH (_STIME) H = Hours (0...23) L = Minutes (0...59) D = Seconds (0...59) E = Centiseconds (ignored) Results: A = 00H if time was valid FFH if time was invalid

This function sets the internal system clock to the specified time value.

If the time is invalid then register A will be returned as 0FFh to indicate an error and the current time will be left unaltered. The time is stored in the real time clock chip and so it will be remembered and kept correct when the machine is turned off.



<b> 3.40 SET/RESET VERIFY FLAG (2EH)</b>

Parameters: C = 2EH (_VERIFY) E = 0 to disable verify <> 0 to enable verify Results: None



This function simply enables or disables automatic verification of all writes. It defaults to off when MSX-DOS is started up. Enabling verify improves system reliability but also slows down write operations. Note that this function depends on the disk driver and the verification will not be done if the driver does not support it.



<b> 3.41 ABSOLUTE SECTOR READ (2FH)</b>

Parameters: C = 2FH (_RDABS) DE = Sector number L = Drive number (0=A: etc.) H = Number of sectors to read Results: A = Error code (0=> no error)

This function reads sectors directly from the disk without interpreting them as files. The disk must be a valid DOS disk in order for the sector number to be translated into a physical position on the disk. The sectors will be read to the current disk transfer address. Any disk error will be reported by the system in the usual way.



<b> 3.42 ABSOLUTE SECTOR WRITE (30H)</b>

Parameters: C = 30H (_WRABS) DE = Sector number L = Drive number (0=A: etc.) H = Number of sectors to write Results: A = Error code

This function writes sectors directly to the disk without interpreting them as files. The disk must be a valid DOS disk in order for the sector number to be translated into a physical position on the disk. The sectors will be written from the current disk transfer address. Any disk errors are reported by the system in the usual way.



<b> 3.43 GET DISK PARAMETERS (31H)</b>

Parameters: C = 31H (_DPARM) DE = Pointer to 32 byte buffer L = Drive number (0=default, 1=A: etc.) Results: A = Error code DE = Preserved

This functions returns a series of parameters relating to the format of the disk in the specified drive, to the buffer allocated within the user's program. It is useful for programs which are going to do absolute sector reads and writes, in order for them to be able to interpret the absolute sector numbers. The parameters returned contain some redundant information in order to provide parameters which are most useful to transient programs. The format of the returned parameter block is:

DE+0 - Physical drive number (1=A: etc) DE+1,2 - Sector size (always 512 currently) DE+3 - Sectors per cluster (non-zero power of 2) DE+4,5 - Number of reserved sectors (usually 1) DE+6 - Number of copies of the FAT (usually 2) DE+7,8 - Number of root directory entries DE+9,10 - Total number of logical sectors DE+11 - Media descriptor byte DE+12 - Number of sectors per FAT

DE+13..14 - First root directory sector number DE+15..16 - First data sector number DE+17..18 - Maximum cluster number DE+19 - Dirty disk flag DE+20..23 - Volume id. (-1 => no volume id.) DE+24..31 - Reserved (currently always zero)

The dirty disk flag indicates whether in the disk there is a file which can be recovered by UNDEL command. It is reset when the file allocation is done.



<b> 3.44 FIND FIRST ENTRY (40H)</b>

Parameters: C = 40H (_FFIRST) DE = Drive/path/file ASCIIZ string or fileinfo block pointer HL = filename ASCIIZ string (only if DE = fileinfo pointer) B = Search attributes IX = Pointer to new fileinfo block Results: A = Error (IX) = Filled in with matching entry

The "drive/path" portion of the string, or the fileinfo block, specifies a directory which is to be searched. A ".IATTR" error will be returned if a fileinfo block which specifies a file is passed. The "file" portion of the string, or the filename ASCIIZ string in HL, determines what filenames will be matched. If no match is found then a ".NOFIL" error is returned, otherwise the fileinfo block pointed to by IX is filled in with the details of the matching entry.



The filename may contain ambiguous filename characters ("?" or "*") in which case the first matching entry will be returned. If the filename is null (either the ASCIIZ string pointed to by DE is null or ends in a "\" or the filename string pointed to by HL is null), then this function will behave exactly as if the filename was "*.*" so any name will match.



The attributes byte in register B specifies what type of entry will be matched. If it is zero then only non-hidden, non-system files will be found.

If the directory, hidden or system bits in register B are set then entries with these attributes will be matched as well as ordinary files. The read only and archive bits of register B are ignored.



If the volume name bit of register B is set then the search is exclusive, only the volume label entry will be found. In this case also the fileinfo block and filename or the drive/path/file string are ignored apart from specifying the drive. This means that the volume name will always be found in the root directory if it exists whether or not it matches the filename given.



If DE points to a fileinfo block, then if desired, IX can point to the same fileinfo block. In this case when a match is found the new fileinfo block will overwrite the old one.



<b> 3.45 FIND NEXT ENTRY (41H)</b>

Parameters: C = 41H (_FNEXT) IX = Pointer to fileinfo block from previous find first function.

Results: A = Error (IX) = Filled in with next matching entry

This function should only be used after a "find first entry" function call. It searches the directory for the next match to the (presumably ambiguous) filename which was given to the "find first entry" function call.

If there are no more matching entries then a ".NOFIL" error is returned, otherwise the fileinfo block is filled in with the information about the new matching entry.



<b> 3.46 FIND NEW ENTRY (42H)</b>

Parameters: C = 42H (_FNEW) DE = Drive/path/file ASCIIZ string or fileinfo block pointer HL = filename ASCIIZ string (only if DE = fileinfo pointer) B = b0..b6 = Required attributes b7 = Create new flag IX = Pointer to new fileinfo block containing template filename Results: A = Error (IX) = Filled in with new entry

This function is very similar to the "find first entry" function described above. The parameters in HL and DE are used in exactly the same way to specify a directory entry. However instead of searching the selected directory for an entry which matches the specified name, a new entry will be created with this name. The fileinfo block pointed to by IX will be filled in with information about the new entry just as if it had been found with a "find first entry" call.



If there are any ambiguous characters ("?" or "*") in the filename, then they will be replaced by the appropriate character from a "template filename"

in the filename position of the new fileinfo block pointed to by IX. If the result is still ambiguous, or otherwise illegal, then a ".IFNM" error is returned. This is useful for copy operations which do an automatic rename.



Like "find first entry", if the filename is null, then it will be treated exactly as if it was "*.*". For this function that means that the template filename will be used as the new filename to create.



A ".DRFUL" error will be returned if there is no room in the root directory, and a ".DKFUL" if a sub-directory must be extended and the disk is already full.



The attribute byte passed in register B is the attribute which the new entry will be given. If the volume name bit is set then a volume name will be created in the root directory. If the directory bit is set then the entry created will be for a sub-directory, otherwise it will be for a file. The system, hidden and read only bits may be set for a file, and the hidden bit for a sub-directory. A file will always be created with the archive attribute bit set.



A file will be created as zero length with the current date and time. A sub-directory will have a single cluster allocated to it and the "." and ".."

entries will be initialized appropriately.



If there is already an entry with the specified name in the directory then the action depends on the "create new" flag (bit-7 of register B) and also on the type of the entry. If the "create new" flag is set then a ".FILEX" error will always be returned. Setting this flag thereforeensures that an existing file will not be deleted.



If an entry already exists and the "create new" flag is not set then the type of the existing entry is examined to see whether it can be deleted to make room for the new file. An error will be returned if the entry is a read only file (".FILRO" error), a system file (".SYSX" error) or a sub-directory (".DIRX" error) or there is a file handle already open to this file (".FOPEN"

error). If we are trying to create a sub-directory then even an ordinary file will not be deleted (".FILEX" error).



For all of these error codes (".FILEX", ".FILRO", ".SYSX", ".DIRX", ".FOPEN"), the fileinfo block will be filed in with the details of the already existing entry and this fileinfo block may be used exactly as if it had been returned from a "find first" function.



<b> 3.47 OPEN FILE HANDLE (43H)</b>

Parameters: C = 43H (_OPEN) DE = Drive/path/file ASCIIZ string or fileinfo block pointer A = Open mode. b0 set => no write b1 set => no read b2 set => inheritable b3..b7 - must be clear Results: A = Error B = New file handle

The drive/path/file string or the fileinfo block should normally refer to a file rather than a sub-directory or volume name. If it is a volume name then a ".IATTR" error will be returned. If it is a sub-directory then ".DIRX"

error will be returned.



Assuming that a file is specified then it will be opened ready for reading and/or writing (depending on the open mode in A) and a new file handle for it will be returned in register B. The lowest available file handle number will be used and an error will result if there are no spare file handles (".NHAND"

error), or insufficient memory (".NORAM" error).



If the "no read" bit of register A is set then reads from the file handle will be rejected and if the "no write" bit is set then writes will be rejected, in both cases with an ".ACCV" error. Writes will also be rejected if the file is read only (".FILRO" error). If the "inheritable" bit of register A is set then the file handle will be inherited by a new process created by the "fork" function call (see function 60h).



If a device file handle is opened by giving a filename which matches one of the built in devices (for example "CON" or "NUL"), then it will always be opened initially in ASCII mode. The IOCTL function (function 4Bh) can be used to change this to binary mode but great care must be taken in reading from devices in binary mode because there is no end of file condition.



<b> 3.48 CREATE FILE HANDLE (44H)</b>

Parameters: C = 44H (_CREATE) DE = Drive/path/file ASCIIZ string A = Open mode. b0 set => no write b1 set => no read b2 set => inheritable b3..b7 - must be clear B = b0..b6 = Required attributes b7 = Create new flag Results: A = Error B = New file handle

A file or sub-directory, as specified by the attributes in register B, will be created with the name and in the directory specified by the drive/path/file string. A ".IATTR" error is returned if register B specifies a volume name.



An error will be returned if the file or sub-directory cannot be created.

The error conditions in this case are the same as for the "find new entry"

function (function 42h) with the main error codes being ".FILEX", ".DIRX", ".SYSX", ".FILRO", ".FOPEN", ".DRFUL" and ".DKFUL". Like the "find new"

function, if the "create new" flag (bit-7 of register B) is set then an existing file will not be deleted and will always return a ".FILEX" error.



If the attributes byte specifies a sub-directory then the hidden bit may also be set to create a hidden sub-directory. For a file, the hidden, system or read only bits may be set to create a file with the appropriate attributes. An invalid attributes bits will simply be ignored. A file will always be created with the archive attribute bit set.



A file will automatically be opened just as for the "open" function described above, and a file handle returned in register B. The "open mode"

parameter is interpreted in the same way as for the "open" function. A sub-directory will not be opened (because this is meaningless) so register B

will be returned as 0FFh which can never be a valid file handle.



<b> 3.49 CLOSE FILE HANDLE (45H)</b>

Parameters: C = 45H (_CLOSE) B = File handle Results: A = Error

This function releases the specified file handle for re-use. If the associated file has been written to then its directory entry will be updated with a new date and time, the archive attributes bit will be set, and any buffered data will be flushed to disk. Any subsequent attempt to use this file handle will return an error. If there are any other copies of this file handle, created by "duplicate file handle" or "fork", then these other copies may still be used.



<b> 3.50 ENSURE FILE HANDLE (46H)</b>

Parameters: C = 46H (_ENSURE) B = File handle Results: A = Error

If the file associated with the file handle has been written to then its directory entry will be updated with a new date and time, the archive attributes bit will be set, and any buffered data will be flushed to disk.

The file handle is not released and so it can still be used for accessing the file, and the current file pointer setting will not be altered.



<b> 3.51 DUPLICATE FILE HANDLE (47H)</b>

Parameters: C = 47H (_DUP) B = File handle Results: A = Error B = New file handle

This function creates a copy of the specified file handle. The lowest available file handle number will always be used and a ".NHAND" error returned if there are none available. The new file handle will refer to the same file as the original and either one may be used. If the file pointer of one handle is moved, the other one will also be moved. If either handle is closed the other one may still be used.



Note that because duplicate file handles created by this function are not "separately opened", they do not count as separate file handles for the purposes of generating ".FOPEN" errors. So for example a "DUP"ed file handle may be renamed (function 53h) or have its attributes changed (function 55h) and the effect will apply to both file handles. Note in particular that if one copy of a "DUP"ed file handle is deleted (function 54h) then the file really will be deleted and the other file handle, although still open, can no longer be used safely. If it is used (other than being closed, ensured or deleted) then an ".FDEL" error will be returned.



<b> 3.52 READ FROM FILE HANDLE (48H)</b>

Parameters: C = 48H (_READ) B = File handle DE = Buffer address HL = Number of bytes to read Results: A = Error HL = Number of bytes actually read

The specified number of bytes are read from the file at the current file pointer position and copied to the buffer address specified in register DE.

The file pointer is then updated to the next sequential byte. A ".ACCV" error will be returned if the file handle was opened with the "no read" access bit set.



The number of bytes read may be less than the number requested for various reasons, and the number read will be returned in register HL if there is no error. In general if less is read than requested then this should not be treated as an error condition but another read should be done to read the next portion, until a ".EOF" error is returned. An ".EOF" error will never be returned for a partial read, only for a read which reads zero bytes. Reading files in this way ensures that device file handles will work correctly (see below).



For disk files the number of bytes read will only be less than the number requested if the end of the file is reached and in this case the next read operation will read zero bytes and will return an ".EOF" error. When reading from a device file handle (for example the standard file handles 0 to 4), the behaviour depends on the particular device, and on whether it is being read in ASCII or binary mode (see function 4Bh below). The "CON" device will be described as an example because it is the most commonly used device, but other devices behave similarly.



When reading from the "CON" device in binary mode, characters will be read from the keyboard, without any interpretation and without being echoed to the screen or printer. The exact number of characters requested will always be read and there is no end of file condition. Because of the lack of any end of file indication, great care must be taken when reading from devices in binary mode.



A read function call to the "CON" device in ASCII mode (the default mode and that which normally applies to the standard input channel), will only read one line of input. The input line will be read from the keyboard with the normal line editing facilities available to the user, and the character typed will be echoed to the screen and to the printer if Ctrl-P is enabled.

Special control characters "Ctrl-P", "Ctrl-N", "Ctrl-S" and "Ctrl-C" will be tested for and will be treated exactly as for the console status function 0Bh.



When the user types a carriage return the line will be copied to the read buffer, terminated with a CR-LF sequence and the read function will return with an appropriate byte count. The next read will start another buffered line input operation. If the number of bytes requested in the read was less than the length of the line input then as many character as requested will be returned, and the next read function call will return immediately with the next portion of the line until it has all been read.



If the user types a line which starts with a "Ctrl-Z" character then this will be interpreted as indicating end of file. The line will be discarded and the read function call will read zero bytes and return an ".EOF" error. A subsequent read after this will be back to normal and will start another line input. The end of file condition is thus not permanent.



<b> 3.53 WRITE TO FILE HANDLE (49H)</b>

Parameters: C = 49H (_WRITE) B = File handle DE = Buffer address HL = Number of bytes to write Results: A = Error HL = Number of bytes actually written

This function is very similar to the "read" function above (function 48h).

The number of bytes specified will be written to the current file pointer position in the file, and the file pointer will be adjusted to point to just after the last byte written. If the file was opened with the "no write"

access bit set then a ".ACCV" error will be returned, and if the file is read only then a ".FILRO" error will be returned.



If the write goes beyond the current end of file then the file will be extended as necessary. If the file pointer is already beyond the end of the file then disk space will be allocated to fill the gap and will not be initialized. If there is insufficient disk space then a ".DKFUL" error will be returned and no data will be written, even if there was room for some of the data.



The number of bytes written can usually be ignored since it will either be zero if an error is returned or it will be equal to the number requested if the write was successful. It is very much more efficient to write files in a few large blocks rather than many small ones, so programs should always try to write in as large blocks as possible.



This function sets a "modified" bit for the file handle which ensures that when the file handle is closed or ensured, either explicitly or implicitly, the directory entry will be updated with the new date, time and allocation information. Also the archive bit will be set to indicate that this file has been modified since it was last archived.



Writing to device file handles is not a complicated as reading from them because there are no end of file conditions or line input to worry about.

There are some differences between ASCII and binary mode when writing to the "CON" device, in that a console status check is done in ASCII mode only. Also printer echo if enabled will only be done in ASCII mode.



<b> 3.54 MOVE FILE HANDLE POINTER (4AH)</b>

Parameters: C = 4AH (_SEEK) B = File handle A = Method code DE:HL = Signed offset Results: A = Error DE:HL = New file pointer

The file pointer associated with the specified file handle will be altered according to the method code and offset, and the new pointer value returned in DE:HL. The method code specifies where the signed offset is relative to as follows:



A=0 Relative to the beginning of the file A=1 Relative to the current position A=2 Relative to the end of the file.



Note that an offset of zero with an method code of 1 will simply return the current pointer value, and with a method code of 2 will return the size of the file. No end of file check is done so it is quite possible (and sometimes useful) to set the file pointer beyond the end of the file. If there are any copies of this file handle created by the "duplicate file handle" function (function 47h) or the "fork" function (function 60h) then their file pointer will also be changed.



The file pointer only has any real meaning on disk files since random access is possible. On device files the file pointer is updated appropriately when any read or write is done, and can be examined or altered by this function. However changing will have no effect and examining it is very unlikely to be useful.



<b> 3.55 I/O CONTROL FOR DEVICES (4BH)</b>

Parameters: C = 4BH (_IOCTL) B = File handle A = Sub-function code 00H => get file handle status 01H => set ASCII/binary mode 02H => test input ready 03H => test output ready 04H => find screen size DE = Other parameters Results: A = Error DE = Other results

This function allows various aspects of file handles to be examined and altered. In particular it can be used to determine whether a file handle refers to a disk file or a device. This is useful for programs which want to behave differently for disk files and device I/O.



This function is passed the file handle in register B and a sub-function code in register A which specifies one of various different operations. Any other parameters required by the particular sub-function are passed in register DE and results are returned in register DE. If the sub-function code is invalid then a ".ISBFN" error will be returned.



If A=0 then the operation is "get file handle status". This returns a word of flags which give various information about the file handle. The format of this word is different for device file handles and disk file handles, and bit-7 specifies which it is. The format of the word is as follows:

For devices: DE - b0 set => console input device b1 set => console output device b2..b4 reserved b5 set => ASCII mode clear=> binary mode b6 set => end of file b7 always set (=> device) b8..b15 reserved

For disk files: DE - b0..b5 drive number (0=A: etc) b6 set => end of file b7 always clear (=> disk file) b8..b15 reserved

Note that the end of file flag is the same for devices as for disk files.

For devices it will be set if the previous attempt to read from the device produced a ".EOF" error and will be cleared by the next read. For disk files it is worked out by comparing the file pointer with the file size.



If A=1 then the operation is a "set ASCII/binary mode". This operation is only allowed for device file handles. An ASCII/binary flag must be passed in bit-5 of register E (exactly where it is returned by "get file handle status"). This is set for ASCII mode and clear for binary mode. All other bits of register DE are ignored.



If A=2 or 3 then the operation is "test input ready" or "test output ready" respectively. In both cases a flag is returned in register E which is FFh if the file handle is ready for a character and 00h if not. The exact meaning of "ready for a character" depends on the device. Disk file handles are always ready for output, and are always ready for input unless the file pointer is at the end of file. The "CON" device checks the keyboard status to determine whether it is ready for input or not.



If A=4 the the operation is "get screen size". This returns the logical screen size for the file handle with the number of rows in register D and the number of columns in register E. For devices with no screen size (such as disk files) both D and E will be zero. Zero for either result should therefore be interpreted as "unlimited". For example this function is used by the "DIR /W" command to decide how many files to print per line, and a value of zero for register E is defaulted to 80.



<b> 3.56 TEST FILE HANDLE (4CH)</b>

Parameters: C = 4CH (_HTEST) B = File handle DE = Drive/path/file ASCIIZ string or fileinfo block pointer Results: A = Error B = 00H => not the same file FFH => same file

This rather specialist function is passed a file handle and either a drive/path/file string or a fileinfo block which identifies a file. It determines if the two files are actually the same file and returns a flag indicating the result. Note that if the file handle is for a device rather than a disk file then it will always return "B=00h" to indicate "not the same file".



This function allows the "COPY" command to detect certain error conditions such as copying file onto themselves and give the user informative error messages. It may also be useful for other programs which need to do similar tests.



<b> 3.57 DELETE FILE OR SUBDIRECTORY (4DH)</b>

Parameters: C = 4DH (_DELETE) DE = Drive/path/file ASCIIZ string or fileinfo block pointer Results: A = Error

This function deletes the object (file or sub-directory) specified by the drive/path/file string or the fileinfo block. Global filename characters are not allowed so only one file or sub-directory can be deleted with this function. A sub-directory can only be deleted if it is empty or an error (".DIRNE") occurs if not). The "." and ".." entries in a sub-directory cannot be deleted (".DOT" error) and neither can the root directory. A file cannot be deleted if there is a file handle open to it (.FOPEN error) or if it is read only (.FILRO error).



If it is a file then any disk space which was allocated to it will be freed. If the disk is an MSX-DOS 2 disk then enough information is retained on the disk to allow the "UNDEL" utility program do undelete the file. This information is only retain ed until the next disk space allocation (usually a write to a file) is done on this disk. After making this function call, if a fileinfo block was passed then it must not be used again (other than passing it to a "find next entry" function) since the file to which it refers no longer exists.



If a device name such as "CON" is specified then no error will be returned but the device will not actually be deleted.



<b> 3.58 RENAME FILE OR SUBDIRECTORY (4EH)</b>

Parameters: C = 4EH (_RENAME) DE = Drive/path/file ASCIIZ string or fileinfo block pointer HL = New filename ASCIIZ string Results: A = Error

This function renames the object (file or sub-directory) specified by the drive/path/file string or the fileinfo block, with the new name in the string pointed to by HL. The new filename string must not contain a drive letter or directory path (".IFNM" error if it does). If a device name such as "CON" is specified then no error will be returned but the device will not actually be renamed.



Global filename characters are not allowed in the drive/path/file string, so only one object can be renamed by this function. However global filename characters are allowed in the new filename passed in HL and where they occur the existing filename character will be left unaltered. Checks are done to avoid creating an illegal filename, for example a file called "XYZ" cannot be renamed with a new filename string of "????A" because the new filename would be "XYZ A" which is illegal. In this case a ".IFNM" error will be returned.



If there is already an entry with the new filename then an error (".DUPF") is returned to avoid creating duplicate filenames. The "." and ".." entries in a sub-directory cannot be renamed (".IDOT" error) and neither can the root directory (it has noname). A file cannot be renamed if there is a file handle open to it (".FOPEN" error) although a read only file can be renamed.



Note that if DE pointed to a fileinfo block, this is not updated with the new name of the file. Therefore care must be taken in using the fileinfo block after making this function call.



<b> 3.59 MOVE FILE OR SUBDIRECTORY (4FH)</b>

Parameters: C = 4FH (_MOVE) DE = Drive/path/file ASCIIZ string or fileinfo block pointer HL = New path ASCIIZ string Results: A = Error

This function moves the object (file or sub-directory) specified by the drive/path/file string or the fileinfo block, to the directory specified by the new path string pointed to by HL. There must not be a drive name in the new path string. If a device name such as "CON" is specified then no error will be returned but the device will not actually be moved.



Global filename characters are not allowed in any of the strings so only one object (file or sub-directory) can be moved by this function, although if a sub-directory is moved, all its descendants will be moved with it. If there is already an entry of the required name in the target directory then a ".DUPF" error is returned to prevent creating duplicate filenames. The "."

and ".." entries in a sub-directory cannot be moved (".DOT" error) and also a directory cannot be moved into one of its own descendants (".DIRE" error) since this would create an isolated loop in the filing system. A file cannot be moved if there is a file handle open to it (".FOPEN" error).



Note that if a fileinfo block is passed to this function, the internal information in the fileinfo block is not updated to reflect the new location of the file. This is necessary because otherwise the fileinfo block could not be used for a subsequent "find next" function call. However it does mean that the fileinfo block no longer refers to the moved file and so must not be used for any operations on it such as "rename" or "open".



<b> 3.60 GET/SET FILE ATTRIBUTES (50H)</b>

Parameters: C = 50H (_ATTR) DE = Drive/path/file ASCIIZ string or fileinfo block pointer A = 0 => get attributes 1 => set attributes L = New attributes byte (only if A=1) Results: A = Error L = Current attributes byte

This function is normally used to change the attributes of a file or sub-directory. It can also be used to find out the current attributes but this is more usually done with the "find first entry" function (function 40h). If A=0 then the current attributes byte for the file or sub-directory will just be returned in register L.



If A=1 then the attributes byte will be set to the new value specified in register L, and this new value will also be returned in register L. Only the system, hidden, read only and archive bits may be altered for a file, and only the hidden bit for a sub-directory. An ".IATTR" error will be returned if an attempt is made to alter any other attribute bits. If a fileinfo block is passed then the attributes byte in it will not be updated with the new setting.



Global filename characters are not allowed so only one object (file or sub-directory) can have its attributes set by this function. The attributes of the root directory cannot be changed because it does not have any. The attributes of a file cannot be changed if there is a file handle open to it (".FOPEN" error). The attributes of the "." and ".." directory entries however can be changed. If a device name such as "CON" is specified then no error will be returned but the device's attributes will not actually be changed (since it does not have any).



<b> 3.61 GET/SET FILE DATE AND TIME (51H)</b>

Parameters: C = 51H (_FTIME) DE = Drive/path/file ASCIIZ string or fileinfo block pointer A = 0 => get date and time 1 => set date and time IX = New time value (only if A=1) HL = New date value (only if A=1) Results: A = Error DE = Current file time value HL = Current file date value

If A=1 then this function sets the date and time of last modification of the file or sub-directory specified by the drive/path/file string or fileinfo block. Global filename characters are not allowed in any part of the string so only one file can have its date and time modified by this function. If a device name such as "CON" is specified then no error will be returned but the device's date and time will not actually be changed.



The date and time format are exactly as contained in the directory entry and fileinfo blocks (see the "Program Interface Specification"). No checks are done for sensible dates or times, the values are simply stored. Note that if a fileinfo block is passed then the date and time stored in it will not be updated by this function.



If A=0 then the current values are just returned. Note that although the time value is passed in IX, it is returned in DE. The date and time of a file cannot be altered (although it can be read) if there is a file handle open to the file (".FOPEN" error).



<b> 3.62 DELETE FILE HANDLE (52H)</b>

Parameters: C = 52H (_HDELETE) B = File handle Results: A = Error

This function deletes the file handle associated with the specified file and closes the file handle. A file handle cannot be deleted if there are any other separately opened file handles open to the same file (".FOPEN" error).

If there are any duplicates of the file handle (created by a "duplicate file handle" or "fork" function), then these duplicates will be marked as invalid and any attempt to use them will produce an ".HDEAD" error.



The error conditions for this function are the same as for the "delete file or sub-directory" function (function 4Dh). The file handle will always be closed, even if there is an error condition such as ".FILRO" or ".FOPEN".



<b> 3.63 RENAME FILE HANDLE (53H)</b>

Parameters: C = 53H (_HRENAME) B = File handle HL = New filename ASCIIZ string Results: A = Error

This function renames the file associated with the specified file handle with the new name in the string pointed to by HL. Apart from the fact that the file is specified by a file handle rather than an ASCIIZ string or a fileinfo block, this function is identical to the "rename file or subdirectory" function (function 4Eh), and has the same error conditions.



A file handle cannot be renamed if there are any other separately opened file handles for this file (".FOPEN" error), although it can be renamed if there are copies of this file handle, and in this case the copies will be renamed. Renaming a file handle will not alter the file pointer but it will do an implicit "ensure" operation.



<b> 3.64 MOVE FILE HANDLE (54H)</b>

Parameters: C = 54H (_HMOVE) B = File handle HL = New path ASCIIZ string Results: A = Error

This function moves the file associated with the specified file handle to the directory specified by the new path string pointed to by HL. Apart from the fact that the file is specified by a file handle rather than an ASCIIZ

string or a fileinfo block, this function is identical to the "move file or subdirectory" function (function 4Fh), and has the same error conditions.



A file handle cannot be moved if there are any other separately opened file handles for this file (".FOPEN" error), although it can be moved if there are copies of this file handle, and in this case the copies will also be moved. Moving a file handle will not alter the file pointer but it will do an implicit "ensure" operation.



<b> 3.65 GET/SET FILE HANDLE ATTRIBUTES (55H)</b>

Parameters: C = 55H (_HATTR) B = File handle A = 0 => get attributes 1 => set attributes L = New attributes byte (only if A=1) Results: A = Error L = Current attributes byte

This function gets or sets the attributes byte of the file associated with the specified file handle. Apart from the fact that the file is specified by a file handle rather than an ASCIIZ string or a fileinfo block, this function is identical to the "get/set file attributes" function (function 50h), and has the same error conditions.



A file handle cannot have its attributes changed (although they can be read) if there are any other separately opened file handles for this file (".FOPEN" error). The file pointer will not be altered but an implicit "ensure" operation will be done.



<b> 3.66 GET/SET FILE HANDLE DATE AND TIME (56H)</b>

Parameters: C = 56H (_HFTIME) B = File handle A = 0 => get date and time 1 => set date and time IX = New time value (only if A=1) HL = New date value (only if A=1) Results: A = Error DE = Current file time value HL = Current file date value

This function gets or sets the date and time of the file associated with the specified file handle. Apart from the fact that the file is specified by a file handle rather than an ASCIIZ string or a fileinfo block, this function is identical to the "get/set file date and time" function (function 51h), and has the same error conditions.



A file handle cannot have its date and time changed (although they can be read) if there are any other separately opened file handles for this file (".FOPEN" error). The file pointer will not be altered but an implicit "ensure" operation will be done.



<b> 3.67 GET DISK TRANSFER ADDRESS (57H)</b>

Parameters: C = 57H (_GETDTA) Results: DE = Current disk transfer address

This function returns the current disk transfer address. This address is only used for the "traditional" CP/M style FCB functions and the absolute sector read and write functions.



<b> 3.68 GET VERIFY FLAG SETTING (58H)</b>

Parameters: C = 58H (_GETVFY) Results: B = 00H => verify disabled FFH => verify enabled

This function simply returns the current state of the verify flag which can be set with MSX-DOS function 2Eh.



<b> 3.69 GET CURRENT DIRECTORY (59H)</b>

Parameters: C = 59H (_GETCD) B = Drive number (0=current, 1=A: etc) DE = Pointer to 64 byte buffer Results: A = Error DE = Filled in with current path

This function simply gets an ASCIIZ string representing the current directory of the specified drive into the buffer pointed to by DE. The string will not include a drive name or a leading or trailing "\" character, so the root directory is represented by a null string. The drive will be accessed to make sure that the current directory actually exists on the current disk, and if not then the current directory will be set back to the root and a null string returned.



<b> 3.70 CHANGE CURRENT DIRECTORY (5AH)</b>

Parameters: C = 5AH (_CHDIR) DE = Drive/path/file ASCIIZ string Results: A = Error

The drive/path/file string must specify a directory rather than a file.

The current directory of the drive will be changed to be this directory. If the specified directory does not exist then the current setting will be unaltered and a ".NODIR" error returned.



<b> 3.71 PARSE PATHNAME (5BH)</b>

Parameters: C = 5BH (_PARSE) B = Volume name flag (bit 4) DE = ASCIIZ string for parsing Results: A = Error DE = Pointer to termination character HL = Pointer to start of last item B = Parse flags C = Logical drive number (1=A: etc)

This function is purely a string manipulation function, it will not access the disks at all and it will not modify the user's string at all. It is intended to help transient programs in parsing command lines.



The volume name flag (bit 4 of register B; it is in the same bit position as the volume name bit in an attributes byte) determines whether the string will be parsed as a "drive/path/file" string (if the bit is cleared) or a "drive/volume" string (if the bit is set).



The pointer returned in DE will point to the first character which is not valid in a pathname string, and may be the null at the end of the string. See the "Command Specification" for details of the syntax of pathname strings and also for a list of valid characters.



The pointer returned in HL will point to the first character of the last item of a string (filename portion). For example, when a string "A:\XYZ\P.Q

/F" was passed, DE will point to the white space character before "/F" and HL

will point to "P". If the parsed string ends with a character "\" or is null (apart from drive name), then there will be no "last item", thus HL and DE

will point to the same character. In this case, some special procedures will be needed to all the programs which use this function.



The drive number returned in register C is the logical drive specified in the string. If the string did not start with a drive letter then register C

will contain the default drive number, since the default drive has been implicitly specified. Register C will never be zero.



The parse flags returned in register B indicate various useful things about the string. For a volume name bits 1, 4, 5, 6 and 7 will always be clear. For a filename, bits 3 to 7 relate to the last item on the string (the "filename" component). The bit assignments are as follows:

b0 - set if any characters parsed other than drive name b1 - set if any directory path specified b2 - set if drive name specified

b3 - set if main filename specified in last item b4 - set if filename extension specified in last item b5 - set if last item is ambiguous

b6 - set if last item is "." or ".."

b7 - set if last item is ".."



<b> 3.72 PARSE FILENAME (5CH)</b>

Parameters: C = 5CH (_PFILE) DE = ASCIIZ string for parsing HL = Pointer to 11 byte buffer Results: A = Error (always zero) DE = Pointer to termination character HL = Preserved, buffer filled in B = Parse flags

This function is purely a string manipulation function, it will not access disks at all and will not modify the string at all. It is intended mainly to help transient programs in printing out filenames in a formatted way. The ASCIIZ string will be parsed as a single filename item, and the filename will be stored in the user's 11 byte buffer in expanded form, with both the filename and the extension padded out with spaces.



The parse flags returned in register B are identical to those for the "parse pathname" function above (function 5Bh), except that bits 0, 1 and 2

will always be clear. The user's buffer will always be filled in, even if there is no valid filename in the string, in which case the buffer will be filled with spaces. "*" characters will be expanded to the appropriate number of "?"s. If either the filename or the filename extension is too long then the excess characters will be ignored.



The pointer returned in register DE will point to the first character in the string which was not part of the filename, which may be the null at the end of the string. This character will never be a valid filename character (see the "Command Specification" for details of valid filename characters).



<b> 3.73 CHECK CHARACTER (5DH)</b>

Parameters: C = 5DH (_CHKCHR) D = Character flags E = Character to be checked Results: A = 0 (never returns an error) D = Updated character flags E = Checked (upper cased) character

This function allow language independent upper casing of characters and also helps with handling 16-bit characters and manipulation of filenames. The bit assignments in the character flags are as follows:

b0 - set to suppress upper casing b1 - set if first byte of 16-bit character b2 - set if second byte of 16-bit character b3 - set => volume name (rather than filename) b4 - set => not a valid file/volume name character b5...b7 - reserved (always clear)



Bit 0 is used to control upper casing. If it is clear then the character will be upper cased according to the language setting of the machine. If this bit is set then the returned character will always be the same as the character passed.



The two 16-bit character flags (bits 1 and 2) can both be clear when the first character of a string is checked and the settings returned can be passed straight back to this function for each subsequent character. Care must be taken with these flags when moving backwards through strings which may contain 16-bit characters.



Bit 4 is set on return if the character is one of the set of filename or volume name terminator characters. Bit 3 is simply used to determine whether to test for filename or volume name characters since the sets are different.

16-bit characters (either byte) are never considered as volume or filename terminators.



<b> 3.74 GET WHOLE PATH STRING (5EH)</b>

Parameters: C = 5EH (_WPATH) DE = Pointer to 64 byte buffer Results: A = Error DE = Filled in with whole path string HL = Pointer to start of last item

This function simply copies an ASCIIZ path string from an internal buffer into the user's buffer. The string represents the whole path and filename, from the root directory, of a file or sub-directory located by a previous "find first entry" or "find new entry" function. The returned string will not include a drive, or an initial "\" character. Register HL will point at the first character of the last item on the string, exactly as for the "parse path" function (function 5Bh).



If a "find first entry" or "find new entry" function call is done with DE

pointing to an ASCIIZ string then a subsequent "get whole path" function call will return a string representing the sub-directory or file corresponding to the fileinfo block returned by the "find" function. If this is a sub-directory then the fileinfo block may be passed back in register DE to another "find first entry" function call, which will locate a file within this sub-directory. In this case the newly located file will be added onto the already existing whole path string internally, and so a subsequent "get whole path string" function call will return a correct whole path string for the located file.



Great care must be taken in using this function because the internal whole path string is modified by many of the function calls, and in many cases can be invalid. The "get whole path" function call should be done immediately after the "find first entry" or "find new entry" function to which it relates.



<b> 3.75 FLUSH DISK BUFFERS (5FH)</b>

Parameters: C = 5FH (_FLUSH) B = Drive number (0=current, FFH=all) D = 00H => Flush only = FFH => Flush and invalidate Results: A = Error

This function flushes any dirty disk buffers for the specified drive, or for all drives if B=FFh. If register D is FFh then all buffers for that drive will also be invalidated.



<b> 3.76 FORK TO CHILD PROCESS (60H)</b>

Parameters: C = 60H (_FORK) Results: A = Error B = Process id of parent process

This function informs the system that a child process is about to be started. Typically this is a new program or sub-command being executed. For example COMMAND2.COM does a "fork" function call before executing any command or transient program.



A new set of file handles is created, and any current file handles which were opened with the "inheritable" access mode bit set (see the "open file handle"

function - function 43h), are copied into the new set of file handles. Any file handles which were opened with the "inheritable" bit clear will not be copied and so will not be available to the child process.

The standard file handles (00h...05h) are inheritable and so these will be copied.



A new process id is allocated for the child process and the process id. of the parent process is returned so that a later "join" function call can switch back to the parent process. A ".NORAM" error can be produced by this function if there is insufficient memory to duplicate the file handles.



Because the child process now has a copy of the previous file handles rather than the originals, if one of them is closed then the original will remain open. So for example if the child process closes the standard output file handle (file handle number 1) an re-opens it to a new file, then when a "join" function is done to return to the parent process the original standard output channel will still be there.



<b> 3.77 REJOIN PARENT PROCESS (61H)</b>

Parameters: C = 61H (_JOIN) B = Process id of parent, or zero Results: A = Error B = Primary error code from child C = Secondary error code from child

This function switches back to the specified parent process and returns the error code which the child process terminated with in register B, and a secondary error code from the child in register C. Although the relationship between parent and childprocesses is strictly one-to-one, this function can jump back several levels by giving it a suitable process id. A ".IPROC" error will be returned if the process id is invalid.



The child process's set of file handles are automatically closed and the parent process's set of file handles becomes active again. Also any user RAM

segments which the child process had allocated will be freed.



If the process id passed to this function is zero then a partial system re-initialisatin is done. All file handles are closed and the standard input and output handles re-opened and all user segments are freed. This should not normally be done by a user program if it intends to return to the command interpreter since the command interpreter will not be in a consistent state after this.



This function takes great care that the freeing of memory and adjusting of process id is done before actually closing any file handles and thus before accessing the disk. This ensures that if a disk error occurs and is aborted, the join operation will have been done successfully. However if a "join 0"

produces a disk error which is aborted, then the re-initialization of default file handles will not have been done. In this case another "join 0" function call should be done and this will not attempt access disk (because all the files have been closed) and so will be successful.



Note that if this function call is made via 0F37Dh then registers B and C

will not return the error codes. This is because program termination and abort handling must be done by the application program. The error code will have been passed to the abort vector and code there must remember the error code if it needs to. See the "terminate with error code" function (function 62h) for the meaning of the primary and secondary error code.



<b> 3.78 TERMINATE WITH ERROR CODE (62H)</b>

Parameters: C = 62H (_TERM) B = Error code for termination Results: Does not return

This function terminates the program with the specified error code, which may be zero indicating no error. This function call will never return to the caller (unless a user abort routine executes forces it to - see function 63h). The operation of this function is different depending on whether it was called from the MSX-DOS environment via 00005h or from the disk BASIC

environment via 0F37Dh.



If called via 00005h then if a user abort routine has been defined by function 63h it will be called with the specified error code (and a zero secondary error code). Assuming that this routine returns, or if there was no user abort routine defined, then control will be passed back to whatever loaded the transient program via a jump at location 00000h. This will almost always be the command interpreter, but in some cases it may be another transient program. The error code will be remembered by the system and the next "join" function (function 61h) which is done will return this error code. The command interpreter will print an error message for any code in the range 20h...FFh, but will not print a message for errors below this.



If this function is called from the disk BASIC environment via 0F37Dh then control will be passed to the abort vector at location "BREAKVECT". In this environment there is no separately defined user abort routine and the error code must be remembered by the code at "BREAKVECT" because "join" will not return the error code.



<b> 3.79 DEFINE ABORT EXIT ROUTINE (63H)</b>

Parameters: C = 63H (_DEFAB) DE = Address of abort exit routine 0000H to un-define routine Results: A = 0 (never generates errors)

This function is only available when called via location 00005h in the MSX-DOS environment. It cannot be called at location 0F37Dh from the disk BASIC environment.



If register DE is zero then a previously defined abort routine will be undefined, otherwise a new one will be defined. The abort routine will be called by the system whenever the transient program is about to terminate for any reason other than a direct jump to location 0000h. Programs written for MSX-DOS 2 should exit with a "terminate with error code" function call (function 061h) rather than a jump to location 0000h.



The user abort routine will be entered with the user stack active, with IX, IY and the alternate register set as it was when the function call was made and with the whole TPA paged in. The termination error code will be passed to the routine in register A with a secondary error code in register B

and if the routine executes a "RET" then the values returned in registers A and B will be stored as the error codes to be returned by the "join"

function, and normally printed out by the command interpreter. Alternatively the routine may jump to some warm start code in the transient program rather than returning. The system will be in a perfectly stable state able to accept any function calls.



The primary error code passed to the routine in register A will be the code which the program itself passed to the "terminate with error code"

function (which may be zero) if this is the reason for the termination. The routine will also be called if a Ctrl-C or Ctrl-STOP is detected (".CTRLC" or ".STOP" error), if a disk error is aborted (".ABORT" error), or if an error occurred on one of the standard input or output channels being accessed through MSX-DOS function calls 01h...0Bh (".INERR" or ".OUTERR").



The errors ".ABORT", ".INERR" and ".OUTERR" are generated by the system as a result of some other error. For example a ".ABORT" can result from a ".NRDY" error, or a ".INERR" can result from a ".EOF" error. In these cases the original error code (".NRDY" or ".EOF") is passed to the abort routine in register B as the secondary error code. For all other errors there is no secondary error code and register B will be zero.



If the abort routine executes "POP HL : RET" (or equivalent) rather than a simple return, then control will pass to the instruction immediately following the MSX-DOS call or BIOS call in which the error occurred. This may be useful in conjunction with a disk error handler routine (see function 64h) to allow an option to abort the current MSX-DOS call when a disk error occurs.



<b> 3.80 DEFINE DISK ERROR HANDLER ROUTINE (64H)</b>

Parameters: C = 64H (_DEFER) DE = Address of disk error routine 0000H to un-define routine Results: A = 0 (never generates errors)

This function specifies the address of a user routine which will be called if a disk error occurs. The routine will be entered with the full TPA paged in, but with the system stack in page-3 active and none of the registers will be preserved from when the MSX-DOS function call was made.



The error routine can make MSX-DOS calls but must be very careful to avoid recursion. The list of function calls in section 2 of this document indicates which function calls can be safely made from a user error routine. This routine is called with the redirection status being temporarily invalidated in case the standard I/O channels have been redirected. See the "get/set redirection state" function (function 70h) for details of this.



The specification of parameters and results for the routine itself is as below. All registers including IX, IY and the alternate register set may be destroyed but the paging and stack must be preserved. The routine must return to the system, it must not jump away to continue the transient program. If it wants to do this then it should return A=1 ("abort") and a user abort routine will then get control and this may do whatever it wants to.



Parameters: A = Error code which caused error B = Physical drive C = b0 - set if writing b1 - set if ignore not recommended





b2 - set if auto-abort suggested


b3 - set if sector number is valid DE = Sector number (if b3 of C is set) Results: A = 0 => Call system error routine 1 => Abort

2 => Retry

3 => Ignore

<b> 3.81 GET PREVIOUS ERROR CODE (65H)</b>

Parameters: C = 65H (_ERROR) Results: A = 0

B = Error code from previous function

This function allows a user program to find out the error code which caused the previous MSX-DOS function call to fail. It is intended for use with the old CP/M compatible functions which do not return an error code. For example if a "create file FCB" function returns A=0FFh thee could be many reasons for the failure and doing this function call will return the appropriate on, for example ".DRFUL" or ".SYSX".



<b> 3.82 EXPLAIN ERROR CODE (66H)</b>

Parameters: C = 66H (_EXPLAIN) B = Error code to be explained DE = Pointer to 64 byte string buffer Results: A = 0

B = 0 or unchanged DE = Filled in with error message

This function allows a user program to get an ASCIIZ explanation string for a particular error code returned by any of the MSX-DOS functions. If an error comes from one of the old functions then "get previous error code" must be called first to get the real error code and then this function can be called to get an explanation string.



The "Program Interface Specification" contains a list of all the currently defined error codes and the messages for them. Foreign language versions of the system will of course have different messages. If the error code does have a built in explanation string then this string will be returned and register B will be set to zero. If there is no explanation string then a string of the form: "System error 194" or "User error 45" will be returned, and register B will be unchanged. (System errors are those in the range 40h...FFh and user errors are 00h...3Fh.)

<b> 3.83 FORMAT A DISK (67H)</b>

Parameters: C = 67H (_FORMAT) B = Drive number (0=>current, 1=>A:) A = 00H => return choice string 01H...09H => format this choice 0AH...FDH => illegal FEH, FFH => new boot sector HL = Pointer to buffer (if A=1...9) DE = Size of buffer (if A=1...9) Results: A = Error B = Slot of choice string (only if A=0 on entry) HL = Address of choice string (only if A=0 on entry)

This function is used to format disks and is really only provided for the "FORMAT" command although other programs may use it (with care) if they find it useful. It has three different options which are selected by the code passed in register A.



If A=0 then registers B and HL return the slot number and address respectively of an ASCIIZ string which specifies the choice of formats which is available. A ".IFORM" error will be returned if this disk cannot be formatted (for example the RAM disk). Normally the string will be read using the "RDSLT" routine and displayed on the screen followed by a "? " prompt.

The user then specifies a choice "1"..."9" and this choice is passed back to the "format" function, after a suitable warning prompt, to actually format the disk. If A=0, in some cases zero is returned in HL. This means that there is only one kind of the format and no prompt is required. There is no way of knowing what disk format a particular choice refers to since this is dependant on the particular disk driver.



If A=01h...09h then this is interpreted as a format choice and a disk will be formatted in the specified drive with no further prompting. Register HL

and DE must specify a buffer area to be used by the disk driver. There is no way of knowing how big this buffer should be so it is best to make it as big as possible. If the buffer crosses page boundaries then this function will select the largest portion of it which is in one page for passing to the disk driver. Many disk drivers do not use this buffer at all.



If A=FFh then the disk will not actually be formatted, but it will be given a new boot sector to make the disk a true MSX-DOS 2 disk. This is designed to update old MSX-DOS 1.0 disks to have a volume id and thus allow the full disk checking and undeletion which MSX-DOS 2 allows. The case A=FEh is the same as A=FFh except that only the disk parameters are updated correctly and the volume id does not overwrite the boot program. Also there are some MSX-DOS 1.0 implementations which put an incorrect boot sector on the disk and these disks cannot be used by MSX-DOS 2 until they have been corrected by this function.



The "new boot sector" function is mainly intended for the "FIXDISK"

utility program, but may be used by other programs if they find it useful. If it is used then a "get format choice" function call (A=0) should be done first and if this returns an error (typically ".IFORM") then the operation should be aborted because this is a drive which does not like to be formatted and the disk could be damaged by this function.



<b> 3.84 CREATE OR DESTROY RAMDISK (68H)</b>

Parameters: C = 68H (_RAMD) B = 00H => destroy RAM disk 1...FEH => create new RAM disk FFH => return RAM disk size Results: A = Error B = RAM disk size

If register B=0FFh then this routine just returns the number of 16k RAM

segments which are allocated to the RAM disk currently. A value of zero indicates that there is no RAM disk currently defined. If B=0 then the current RAM disk will be destroyed, loosing all data which it contained and no error will be returned if there was no RAM disk.



Otherwise, if B is in the range 01h...FEh then this function will attempt to create a new RAM disk using the number of 16k segments specified in register B. An error will be returned if there is already a RAM disk (".RAMDX") or if there is not even one segment free (".NORAM"). If there are insufficient free RAM segments to make a RAM disk of the specified size then the largest one possible will be created. No error is returned in this case.



In all cases the size of the RAM disk will be returned in register B as a number of segments. Note that some of the RAM is used for the file allocation tables and the root directory so the size of the RAM disk as indicated by "DIR" or "CHKDSK" will be somewhat smaller than the total amount of RAM used.

The RAM will always be assigned the drive letter "H:" regardless of the number of drives in the system.



<b> 3.85 ALLOCATE SECTOR BUFFERS (69H)</b>

Parameters: C = 69H (_BUFFER) B = 0 => return number of buffers else number of buffers required Results: A = Error B = Current number of buffers

If B=0 then this function just returns the number of sector buffers which are currently allocated. If B<>0 then this function will attempt to use this number of sector buffers (must always be at least 2). If it cannot allocate as many as requested then it will allocate as many as possible and return the number in register B but will not return an error. The number of sector buffers can be reduced as well as increased.



The sector buffers are allocated in a 16k RAM segment outside the normal 64k so the number of buffers does not detract from the size of the TPA.

However the number of buffers does affect efficiency since with more buffers allow more FAT and directory sectors to be kept resident. The maximum number of buffers will be about 20.



<b> 3.86 LOGICAL DRIVE ASSIGNMENT (6AH)</b>

Parameters: C = 6AH (_ASSIGN) B = Logical drive number (1=A: etc) D = Physical drive number (1=A: etc) Results: A = Error D = Physical drive number (1=A: etc)

This function controls the logical to physical drive assignment facility.

It is primarily intended for the "ASSIGN" command although user programs may want to use it to translate logical drive numbers to physical drive numbers.



If both B and D are non-zero then a new assignment will be set up. If register B is non-zero and register D is zero then any assignment for the logical drive specified by B will be cancelled. If both register B and D are zero then all assignments will be cancelled. If register B is non-zero and register D is FFh then the current assignment for the logical drive specified by register B will simply be returned in register D.



All drives used in the various function calls, including drive names in strings and drive numbers as parameters to function calls, are logical drives. However the drive number passed to disk error routines is a physical drive so if "ASSIGN" has been used these may be different from the corresponding logical drive.



<b> 3.87 GET ENVIRONMENT ITEM (6BH)</b>

Parameters: C = 6BH (_GENV) HL = ASCIIZ name string DE = Pointer to buffer for value B = Size of buffer Results: A = Error DE = Preserved, buffer filled in if A=0



This function gets the current value of the environment item whose name is passed in register HL. A ".IENV" error is returned if the name string is invalid. If there is no environment item of that name then a null string will be returned in the buffer. If there is an item of that name then its value string will be copied to the buffer. If the buffer is too small then the value string will be truncated with no terminating null and a ".ELONG" error will be returned. A buffer 255 bytes will always be large enough since value strings cannot be longer than this (including the terminating null).



<b> 3.88 SET ENVIRONMENT ITEM (6CH)</b>

Parameters: C = 6CH (_SENV) HL = ASCIIZ name string DE = ASCIIZ value string Results: A = Error

This function sets a new environment item. If the name string is invalid then a ".IENV" error is returned, otherwise the value string is checked and a ".ELONG" error returned if it is longer than 255 characters, or a ".NORAM"

error if there is insufficient memory to store the new item. If all is well then any old item of this name is deleted and the new item is added to the beginning of the environment list. If the value string is null then the environment item will be removed.



<b> 3.89 FIND ENVIRONMENT ITEM (6DH)</b>

Parameters: C = 6DH (_FENV) DE = Environment item number HL = Pointer to buffer for name string Results: A = Error HL = Preserved, buffer filled in

This function is used to find out what environment items are currently set. The item number in register DE identifies which item in the list is to be found (the first item corresponds to DE=1). If there is an item number <DE> then the name string of this item will be copied into the buffer pointed to by HL. If the buffer is too small then the name will be truncated with no terminating null, and a ".ELONG" error returned. A 255 byte buffer will never be too small. If there is no item number <DE> then a null string will be returned, since an item can never have a null name string.



<b> 3.90 GET/SET DISK CHECK STATUS (6EH)</b>

Parameters: C = 6EH (_DSKCHK) A = 00H => get disk check status 01H => set disk check status B = 00H => enable (only if A=01H) FFH => disable (only if A=01H) Results: A = Error B = Current disk check setting

If A=0 then the current value of the disk check variable is returned in register B. If A=01h then the variable is set to the value in register B. A value of 00h means that disk checking is enabled and a non-zero means that it is disabled. The default state is enabled.



The disk check variable controls whether the system will re-check the boot sector of a disk to see whether it has changed, each time a file handle, fileinfo block or FCB is accessed. If it is enabled then it will be impossible to accidentally access the wrong disk by changing a disk in the middle of an operation, otherwise this will be possible and may result in a corrupted disk. Depending on the type of disk interface, there may be some additional overhead in having this feature enabled although with many types of disk (those with explicit disk change detection hardware) it will make no difference and the additional security is well worth having.



<b> 3.91 GET MSX-DOS VERSION NUMBER (6FH)</b>

Parameters: C = 6FH (_DOSVER) Results: A = Error (always zero) BC = MSX-DOS kernel version DE = MSXDOS2.SYS version number

This function allows a program to determine which version of MSX-DOS it is running under. Two version numbers are returned, one in BC for the MSX-DOS

kernel in ROM and the other is DE for the MSXDOS2.SYS system file. Both of these version numbers are BCD values with the major version number in the high byte and the two digit version number in the low byte. For example if there were a version 2.34 of the system, it would be represented as 0234h.



For compatibility with MSX-DOS 1.0, the following procedure should always be followed in using this function. Firstly if there is any error (A<>0) then it is not MSX-DOS at all. Next look at register B. If this is less than 2

then the system is earlier than 2.00 and registers C and DE are undefined. If register B is 2 or greater then registers BC and DE can be used as described above. In general the version number which should be checked (after this procedure) is the MSXDOS2.SYS version in register DE.



<b> 3.92 GET/SET REDIRECTION STATE (70H)</b>

Parameters: C = 70H (_REDIR) A = 00H => get redirection state 01H => set redirection state B = New state. b0 - standard input





b1 - standard output


Results: A = Error B = Redirection state before command b0 set => input is redirected b1 set => output is redirected

This function is provided primarily for disk error routines and other character I/O which must always go to the console regardless of any redirection. When the CP/M character functions (functions 01h...0Bh) are used, they normally refer to the console. However if the standard input or output file handles (file handles 0 and 1) have been closed and reopened to a disk file, then the CP/M character functions will also go to the disk file.

However certain output such as disk error output must always go to the screen regardless.



This function allows any such redirection to be temporarily cancelled by calling this function with A=1 and B=0. This will ensure that any subsequent CP/M console I/O will go to the console, and will also return the previous setting so that this can be restored afterwards. The system is a somewhat unstable state when the redirection state has been altered like this and there are many function calls which will reset the redirection to its real state over-riding this function. In general any function call which manipulates file handles, such as "open", "close", "duplicate" and so on, will reset the redirection state. The effect of this function is therefore purely temporary.



</code>

++++++++++ END OF DOCUMENT ++++++++++





<code> <b>RS232C Extended BIOS Call specification</b>

September 18th, 1984

December 24th, 1985



RS232C Extended BIOS Call specification Page 2





1.0 GENERAL DESCRIPTION




The RS232C driver can be used by application programs using the "EXTENDED BIOS CALL" mechanism. Such user can access each function in the RS232C driver through the entry jump table with inter-slot call funtion provided in the BIOS. The user is able to know the location of this table by EXTENDED BIOS CALL 0 and 1. Refer to the document "Specification of the EXTENDED BIOS CALL" for details.





1.1 EXTENDED BIOS CALL ENTRY TABLE




The RS232C driver has entries as follows. A application program is able to use RS232C driver by 'inter-slot call' to those entries.



For I/O port only type of RS-232C interface.



EXBTBL: DEFB DVINFB ; device information

DEFB 0 ; reserved for future expansion DEFB 0

JP INIT ; initialize RS232C port JP OPEN ; Open RS232C port JP STAT ; ReaD STATus

JP GETCHR ; receive data

JP SNDCHR ; send data

JP CLOSE ; close RS232C port JP EOF ; tell EOF code received JP LOC ; reports number of characters in the ; receiver buffer

JP LOF ; reports number of free space left in ; receiver buffer

JP BACKUP ; back up a character JP SNDBRK ; send a break character JP DTR ; turn on/off DTR line NOENT

NOENT

NOENT



RS232C Extended BIOS Call specification Page 3



Multi channel type RS-232C cartridge



EXBTBL:

DEFB DVINFB

DEFB 1 ; version number

DEFB 0 ; reserved for future expansion JP INIT ; initialize RS232C port JP OPEN ; open RS232C port JP STAT ; ReaD STATus

JP GETCHR ; reveive data

JP SNDCHR ; send data

JP CLOSE ; close RS232C port JP EOF ; tell EOF code received JP LOC ; reports number of characters in the ; receiver buffer

JP LOF ; reports number of free space left in the ; receiver buffer

JP BACKUP ; back up a character JP SNDBRK ; send break character JP DTR ; turn on/off DTR line JP SETCHN ; set channel number NOENT

NOENT



NOTE



The RS232C receiver is driven by the interrupt generated by receiver ready.

However, the inter-slot call handler disables interrupt automatically. So, when control returns to the application program, it has to enable interrupt as soon as possible. Otherwise, RS232C

receiver routine loses incoming characters.



RS232C Extended BIOS Call specification Page 4





2.0 DESCRIPTION OF EACH EXTENDED BIOS CALL




2.1 Initialize RS232C Port (INIT)



Entry: [HL]= address of the parameter table [B] = slot address of the parameter table Return: carry flag is set if illegal parameters are contained Modify: [AF]



Description:

To initialize the RS232C port with specified parameter. This entry must be called before any other function calls are made. The parameters are similar to _COMINI expanded statement of BASIC.

However, note that all the ascii parameters must be specified with upper case characters only.



BAUD RATE

It is possible to set different baud rate for transmitter and receiver. The possible value for the baud rate are as follows:

50, 75, 110, 300, 600, 1200, 1800, 2000, 2400, 3600, 4800, 7200, 9600, 19200



When negative value is specified, its absolute value is written to i8253 timer/counter directly.



TIME OUT

The RS232C driver waits till the CTS (Clear To Send) signal is turned on and/or XON is received when the character is to be sent.

The driver will generates time out error when it waits for them, if specified time passed. Its time is specified this value at second.

If 0 specified then the driver doesn't generate time out error and waits forever.



RS232C Extended BIOS Call specification Page 5



+-------------------------------+

[B]:[HL]--> | Character length '5'-'8' |\ +-------------------------------+ \ | Parity 'E','O','I','N' | |

+-------------------------------+ |

| Stop bits '1','2','3' | |

+-------------------------------+ >-- ASCII | XON/XOFF controll 'X','N' | | character +-------------------------------+ |

| CTR-RTS hand shake 'H','N' | |

+-------------------------------+ |

| Auto LF for receive 'A','N' | |

+-------------------------------+ |

| Auto LF for send 'A','N' | |

+-------------------------------+ /

| SI/SO control 'S','N' |/

+-------------------------------+

| Receiver baud rate (low) |\ +--- ----+ \

| 50-19200 (high) | |

+-------------------------------+ |

| Transmitter baud rate (low) | >-- Binary +--- ----+ |

| 50-19200 (high) | |

+-------------------------------+ /

| Time out counter 0-255 |/

+-------------------------------+



RS232C Extended BIOS Call specification Page 6



2.2 Open RS232C Port (OPEN)



Entry: [HL]= address of FCB (must be located higher address than 8000H)

[C] = buffer length ( 32-254 ) [E] = open mode, one of following: +----------+------------------------------+

|open mode | meanings |

+----------+------------------------------+

| 1 | <input> mode |

| 2 | <output> mode |

| 4 | <raw> and <input/output> mode|

+----------+------------------------------+

Return: carry flag is set if any error occured.

Modify: [AF]



Description:

Opens RS232C port with specified FCB (File Control Block). Opens must be made before any I/O operations take place. Each received character occupies two bytes in the buffer. One is received character code itself and another is error status of the received character. And extra 9 bytes are necessary as a working storage for the file control. Note that the buffer length passed by [C]

specifies number of characters, so the actual length of buffer is [C] x 2 + 9 bytes. And this buffer area can be accessed without slot handling whenever the RS232C driver is called (including the timing when the interrupt from the the receiver generated).



| |

+-------------------------------+

| 9 bytes for file control |

| |

+-------------------------------+

| [C] x 2 bytes receiver buffer |

| |

+-------------------------------+

| |



RS232C Extended BIOS Call specification Page 7



2.3 Read Status (STAT)



Entry: None

Return: [HL]= status data.

Modify: None



Description:

Returns various status information and error code of the character just read from the buffer (not the character just received).

+---------+-------------------------------------------------+

| BIT NO. | Description |

+---------+-------------------------------------------------+

| 15 | Buffer over flow error |

| | 0 - no buffer over flow |

| | 1 - buffer over flow |

| 14 | Time out error |

| | 0 - no time out error occured |

| | 1 - time out error occured |

| 13 | Framing error |

| | 0 - no framing error occured |

| | 1 - framing error occured |

| 12 | Over run error |

| | 0 - no over run error occured |

| | 1 - over run error occured |

| 11 | Parity error |

| | 0 - the character hasn't parity error |

| | 1 - the character has parity error |

| 10 | Control break key was pressed |

| | 0 - control break key wasn't pressed |

| | 1 - control break key was pressed |

| 9 | Not used, reserved |

| 8 | Not used, reserved |

| 7 | Clear To Send |

| | 0 - false |

| | 1 - true |

| 6 | Timer/counter output-2 |

| | 0 - timer/counter output-2 is negated |

| | 1 - timer/counter output-2 is asserted |

| 5 | Not used, reserved |

| 4 | Not used, reserved |

| 3 | Data Set Ready |

| | 0 - false |

| | 1 - true |

| 2 | break detect |

| | 0 - not yet detect |

| | 1 - detect |

| 1 | Ring Indicator |

| | 0 - false |

| | 1 - true |

| 0 | Carrier Detect |

| | 0 - false |

| | 1 - true |

+---------+-------------------------------------------------+



RS232C Extended BIOS Call specification Page 8



2.4 Get A Character From The Receive Buffer (GETCHR)

Entry: None

Return: [A] = character received sign flag is set if any error occured.

carry flag is set if the character is an EOF code when port is opened for input mode.

Modify: [F]



Description:

Get a character from the receiver buffer. Returns backed up character if any.



2.5 Send A Character To The RS232C Port (SNDCHR)



Entry: [A] = character to send Return: carry flag is set if control break key was pressed zero flag is set if time out error occured during waiting for XON or/and CTS signal.

Modify: [F]



Description:

Send specified character to RS232C port. The character flow control by XON/XOFF characters and/or CTS (Clear To Send) line signal is handled if initialized so. Time out error will be generated when specified time passed during waiting for permision for transmission, and the character will not be sent.



2.6 Close The RS232C Port (CLOSE)



Entry: None

Return: carry is set if any error occured Modify: [AF]



Description:

Closes the RS232C port. The buffer is released, and a EOF code is sent if the port was opened for <output> mode. RTS signal is turned to inactive state.



RS232C Extended BIOS Call specification Page 9



2.7 Check For The EOF Code (EOF)



Entry: None

Return: [HL]= -1, carry flag is set, if the next character is EOF

code.

= 0, carry flag is reset, if the next character is not EOF code.

Modify: [AF]



Description:

Tests whether the next character is EOF code or not. Returns 0 if no character.



2.8 Returns A Number Of Character In The Receive Buffer (LOC)

Entry: None

Return: [HL] = number of character in the receiver buffer Modify: [AF]



Description:

Returns number of valid character in the receive buffer. This value includes number of backed up character. Characters after EOF code are ignored if opened in <input> mode, but occupies buffer space although.



2.9 Returns Number Of Free Space In The Receive Buffer (LOF)

Entry: None

Return: [HL] = number of free space Modify: [AF]



Description:

Returns a number of free space in character in the receiver buffer.



2.10 Back Up A Character (BACKUP)



Entry: [C] = character to back up Return: None

Modify: [F]



Description:

Backs up a character in the special buffer. Last backed up character will be lost if any.



RS232C Extended BIOS Call specification Page 10



2.11 Send Break Character (SNDBRK)



Entry: [DE] = number of break character to send Return: carry flag is set if control break key was pressed Modify: [AF], [DE]



Description:

Transmit specified number of break characters. Aborts if Control-Break key is pressed during the transmission and returns with carry flag set.



2.12 Turn On/off DTR Line (DTR)



Entry: [A] = 0 if turn off [A] = not 0 if turn on

Return: None

Modify: [F]



Description:

DTR (Data Terminal Ready) line is turned on when power-on/reset initializing or INIT routine is called.





3.0 MULTIPLE CHANNEL TYPE RS-232C CARTRIDGE




3.1 Set Channel Number (SETCHN)



Entry: [A] = channel number.

Return: Carry flag is set if the channel is not in the cartridge.

Otherwise the channel is in the cartridge.

Modify: [AF], [BC]



Description:

The channel number is set with 0 when power-on/reset initializing.



RS232C Extended BIOS Call specification Page 11



APPENDIX A



MISCELLANEOUS INFORMATIONS



A.1 THE BEHAVIOR OF CONTROL SIGNALS



RESET COMINI OPEN CLOSE

---------------------------------------------------------

RTS - inactive no effect active inactive DTR - active active no effect no effect

RTS signal is affected in following cases:



1. OPEN statement is executed - activated.

2. CLOSE statement is executed - inactivated.

3. The rest of the communication buffer is less than 16 byte and CTS-RTS

handshake is enabled - inactivated.

4. When it is inactive and the rest of the communication buffer becomes more than byte and CTS-RTS handshake is enabled - activated.



DTR signal is affected by CALL COMDTR and CALL COMINI statements.



A.2 HANDLING OF EOF



EOF is transmitted when close is executed when the open mode was output.</code>





<code> Page 1



<b> MSX RS232C interface hardware specification</b>

ASCII Microsoft

May 29th, 1984



(c) ASCII Corp. All right reserved

MSX RS232C interface hardware specifaction Page 2



This document describes the hardware requirements of RS-232C interface for MSX home presonal computers.





1.0 LSI COMPONENTS




i-8251 Communication interface i-8253 Programmable interval timer

At least 4Kbyte of ROM storage for the support software.





2.0 PORT ADDRESS




80H R/W 8251 data port

81H R/W 8251 command/status port 82H R Status sense port for CTS, Timer/Counter 2, RI and CD

82H W Interrupt mask register 83H * not specified

84H R/W 8253 counter 0

85H R/W 8253 counter 1

86H R/W 8253 counter 2

87H W 8253 mode register

* The port whose address is 83H can be used for the monufacturer's own purpose.



MSX RS232C interface hardware specifaction Page 3



3.0 THE USAGE OF PORT AT ADRESS 82H



82H read - Get system status

+--------+-------------------------------------+

| data | |

| bit | Description |

+--------+-------------------------------------+

| D7 | CTS ( Clear To Send ) |

| | 0 - CTS is asserted |

| | 1 - CTS is negated |

| D6 | Timer/counter output-2 from i8253 |

| D5 | --+ |

| D4 | | |

| D3 | | Reserved |

| D2 | --+ |

| D1 | + RI ( Ring Indicator ) |

| | 0 - RI is asserted |

| | 1 - RI is negated |

| D0 | + CD ( Carrier Detect ) |

| | 0 - CD is asserted |

| | 1 - CD is negated |

+--------+-------------------------------------+



NOTE: Signals with + sign are optional. If only one of then is implented, it must be a 'CD' signal.



NOTE



The CTS is not sensed through 8251, but sensed through the prot as described above because of the problem in CTS lopic in some versions of 8251 and make the software handling possible.



MSX RS232C interface hardware specifaction Page 4



82H write - Interrupt mask register +--------+----------------------------------------+

| data | |

| bit | Description |

+--------+----------------------------------------+

| D7 | --+ |

| D6 | | |

| D5 | | Reserved |

| D4 | --+ |

| D3 | + Timer interrupt from i8253 channel-2 |

| | 1 - mask interrupt (initial value) |

| | 0 - enable interrupt |

| D2 | + Sync character detect/Break detect |

| | 1 - mask interrupt (initial value) |

| | 0 - enable interrupt |

| D1 | + Transmit data ready (TxReady) |

| | 1 - mask interrupt (initial value) |

| | 0 - enable interrupt |

| D0 | Receive data ready (RxReady) |

| | 1 - mask interrupt (initial value) |

| | 0 - enable interrupt |

+--------+----------------------------------------+



NOTE : Signals with + sign are optional. That is, the minimum requirement for the interrupt signal is RxReady.



MSX RS232C interface hardware specifaction Page 5



4.0 THE USAGE OF 8253 TIMER-COUNTER TO GENERATE BAUD RATE CLOCK FOR 8251





4.1 Frequency Of X'tal




The frequency of the crystal :





1.8432Mhz




+------------------+------------------------------+

| baud rate (baud) | scale factor and error (x16) |

+------------------+------------------------------+

| 50 | 2304 |

| 75 | 1536 |

| 110 | 1047 110.0287 +0.3% |

| 150 | 768 |

| 300 | 384 |

| 600 | 192 |

| 1200 | 96 |

| 1800 | 64 |

| 2000 | 58 1986.2 -0.7% |

| 2400 | 48 |

| 3600 | 32 |

| 4800 | 24 |

| 7200 | 16 |

| 9600 | 12 |

| 19200 | 6 |

+------------------+------------------------------+





4.2 The Usage Of Counter Channel




CH0 - Rx baud rate clock CH1 - Tx baud rate clock CH2 - Used by application Optionally generates interrupt

MSX RS232C interface hardware specifaction Page 6





5.0 THE CONNECTION OF DB25 CONNECTOR




+-------+------------------+ +-------+--------------------+

| PIN | SIGNAL | | PIN | SIGNAL |

+-------+------------------+ +-------+--------------------+

| 1 | Frame ground | | 14 | |

| 2 | Transmit data | | 15 | |

| 3 | Receive data | | 16 | |

| 4 | Request To Send | | 17 | |

| 5 | Clear To Send | | 18 | |

| 6 | Data Set Ready | | 19 | |

| 7 | Signal ground | | 20 | Data Terminal Ready|

| 8 | Carrier detect | | 21 | |

| 9 | | | 22 | Ring indicator |

| 10 | | | 23 | |

| 11 | | | 24 | |

| 12 | | | 25 | |

| 13 | | | | |

+-------+------------------+ +-------+--------------------+</code>





Z80


The Z80 is 8 bit processor running with a frequency of 3.57945 Mhz.

Details: Z80 command set

Z80 instruction set summary

Lex Lechz: the following table lists the extensions from the Z80 to the R800 processor.

These extensions are implemented in RuMSX.



R800-Processor (16 Bit, 7.15909 Mhz) opcodes





Instruction Operation C Z P/V S N H Opcode M-Cycles T-States

MULUW HL,BC DEHL <- HL*BC Chg Chg 0 0 NoChg NoChg ED C3 36 36

MULUW HL,SP DEHL <- HL*SP Chg Chg 0 0 NoChg NoChg ED F3 36 36

MULU A,B HL <- A*B Chg Chg 0 0 NoChg NoChg ED C1 14 14

MULU A,C HL <- A*C Chg Chg 0 0 NoChg NoChg ED C9 14 14

MULU A,D HL <- A*D Chg Chg 0 0 NoChg NoChg ED D1 14 14

MULU A,E HL <- A*E Chg Chg 0 0 NoChg NoChg ED D9 14 14

Please also be careful with illegal instructions. Officially 8 bit access to the IX and IY register isn't guaranteed on the Z80. Using the R800 no problems will arise. However , the object code of LD IXH,IXL is DD 65 but the assembler will probably create DD DD 65. On the Z80 this code will run ok but this is not guaranteed that it will work proper on the R800. So be careful with illegal instructions.





<code>------------------------------------------------------------------------

A

R800 INSTRUCTION CHARTS

------------------------------------------------------------------------

In these charts instructions of the R800, grouped in kind of instructions are collected. Of the mnemonics in these charts the name of the instruction, usage of this instruction are smplified showed.

In the column of the usage of an instruction when there is an <- symbol The details of the left side are shown on the rightside The KAKKO (??) means the details of the memory by the shown belonging register. (???)

For example if there is :



r <- [.hl]



the details of the memory of the shown HL register is is going to 8 bit (???) The in/out-put instructions [n] and [.c] are the equivalence of the in/out-put ports.

In the flag column the flags used are shown. OPcode column the machinecode of every different instruction is written down in HEX and BIN format.

The B stands for the length of the code in bytes, the C stands for the length of the code in clock cycles.The shown mnemonics that have changed for the R800

can't be guaranteed to work properly on the Z80 because they are not the same as the z80 instructions. (??)

<660 APPENDIX A R800 INSTRUCTION CHART>

remarks



+-------+---------------------------------------------------------------+

|.a{7} |The highest bit of register .a |

|.{4..7}|Bit 4-7 of register .a |

|; |Punctuation of the usage |

|.de:.hl|.de is the upper 16bit and .hl is the lower 16 bit and 32 bit |

| | |

| | formed. |

|[.ix+d]|adres is formed when the 8bit of d is added to .ix |

|C |carry flag |

|Z |zero flag |

|P/v |parity overflow |

|S |sign flag |

|N |substraction flag |

|H |half clear flag |

| |flag don't change |

|+ |flag changed in commando used |

|0 |flag is set to 0 |

|1 |flag is set to 1 |

|? |becomes uncertain |

|V |uses the overflow flag |

|P |uses the parity flag |

|i(iff) |value of the interrupt flipflop is attained |

|r,r' |8 bit register, .a,.b,.c,.d,.e,.h,.l |

|u,u' |8 bit register, .a,.b,.c,.d,.e,.ixh,.ixl |

|v,v' |8 bit register, .a,.b,.c,.d,.e,.iyh,.iyl |

|p |8 bit register, .ixh,.ixl |

|q |8 bit register, .iyh,.iyl |

|ss |16 bit register,.bc,.de,.hl,.sp |

|pp |16 bit register,.bc,.de,.ix,.sp |

|rr |16 bit register,.bc,.de,.iy,.sp |

|qq |16 bit register,.bc,.de,.hl,.af |

|e |8 bit value of short branch (+127~128) |

|k |adres of the brk comando, 00h,08h,10h,18h,20h,28h,30h,38h |

|nn |direct value of 16 bit, positive adres |

|n |direct value of 8 bit |

|b |value shown number of bits for the bits of the mathematical |

| | operation?? |

|NOT |bit rotation (??) |

|\/ |taking the OR of the bits |

|\-/ |taking the XOR of the bits |

|/\ |taking the AND of the bits |

|tmp |temporary value (??) |

|B |number of bytes of the instruction |

|C |number of clock cycles of the instruction |

+-------+---------------------------------------------------------------+

???

<A1 8 bit transfer instructions 661>

A.1 8 BIT TRANSFER INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|ld r,r' | r <- r' |     |01 r r'| |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|ld r,n | r <- n |     |00 r 110| |2|2|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld r,[.hl] | r <- [.hl] |     |01 r 110| |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|ld r,[.ix+d]| r <- [.ix+d] |     |11011101|DD |3|5|

| | | |01 r 110| | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld r,[.iy+d]| r <- [.iy+d] |     |11111101|FD |3|5|

| | | |01 r 110| | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld [.hl],r |[.hl] <- r |     |10110 r | |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|ld [.ix+d],r| [.ix+d] <- r |     |11011101|DD |3|5|

| | | |01110 r | | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld [.iy+d],r| [.iy+d] <- r |     |11111101|FD |3|5|

| | | |01110 r | | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld u,u' | u <- u' |     |11011101|DD |2|2|

| | | |01 u u'| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld v,v' | v <- v' |     |11111101|FD |2|2|

| | | |01 v v'| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld u,n | u <- n |     |11011101|DD |3|3|

| | | |00 u 110| | | |

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld v,n | v <- n |     |11111101|FD |3|3|

| | | |00 v 110| | | |

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld [.hl],n | [.hl] <- n |     |00110110|36 |2|3|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld [.ix+d],n| [.ix+d] <- n |     |11011101|DD |4|5|

| | | |00110110|36 | | |

| | | |<- d ->| | | |

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld [.iy+d],n| [.iy+d] <- n |     |11111101|FD |4|5|

| | | |00110110|36 | | |

| | | |<- d ->| | | |

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

<662 APPENDIX A R800 instruction chart> +------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|ld .a,.i | .a <- .i |+ + 0 i 0 |11101101|ED |2|2|

| | | |01010111|57 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .a,.r | .a <- .r |+ + 0 i 0 |11101101|ED |2|2|

| | | |01011111|5F | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .i,.a | .i <- .ax+d] |     |11101101|ED |2|2|

| | | |01000111| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .r,.a | .r <- .a |     |11101101|ED |2|2|

| | | |01001111| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .a,[.bc] | .a <- [.bc] |     |00001010|0A |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|ld .a,[.de] | .a <- [.de] |     |00011010|1A |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|ld .a,[nn] | .a <- [nn] |     |00111010|3A |3|4|

| | | |<- NNl->| | | |

| | | |<- NNh->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld [.bc],.a | [.bc] <- .a |     |00000010|02 |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|ld [.de],.a | [.de] <- .a |     |00010010|12 |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|ld [nn],.a | [nn] <- .a |     |00110010|32 |3|4|

| | | |<- NNl->| | | |

| | | |<- NNh->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

+-+----+----+----+----+----+----+----+----+

| |000 |001 |010 |011 |100 |101 |110 |111 |

+-+----+----+----+----+----+----+----+----+

|r| .b | .c | .d | .e | .h | .l | | .a |

+-+----+----+----+----+----+----+----+----+

|u| .b | .c | .d | .e |.ixh|.ixl| | .a |

+-+----+----+----+----+----+----+----+----+

|v| .b | .c | .d | .e |.iyh|.iyl| | .a |

+-+----+----+----+----+----+----+----+----+



A.2 16 bit TRANSFER INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|ld ss,nn | ss <- nn |     |00ss0001| |3|3|

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .ix,nn | .ix <- nn |     |11011101|DD |4|4|

| | | |00100001|21 | | |

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .iy,nn | .iy <- nn |     |11111101|FD |4|4|

| | | |00100001|21 | | |

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .sp,.hl | .sp <- .hl |     |11111001|F9 |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|ld .sp,.ix | .sp <- .ix |     |11011101|DD |2|2|

| | | |11111001|F9 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .sp,.iy | .sp <- .iy |     |11111101|FD |2|2|

| | | |11111001|F9 | | |

+------------+----------------------------+-------------+--------+---+-+-+

<A.2 16 bit transfer instructions 663> +------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|ld ss,[nn] | ssh <- [nn+1] |     |11101101|ED |4|6|

| | ssl <- [nn] | |01ss1011| | | |

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .hl,[nn] | .h <- [nn+1] |     |00101010|2A |3|5|

| | .l <- [nn] | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .ix,[nn] |.ixh <- [nn+1] |     |11011101|DD |4|6|

| |.ixl <- [nn] | |00101010|2A | | |

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld .iy,[nn] |.iyh <- [nn+1] |     |11111101|FD |4|6|

| |.iyl <- [nn] | |00101010|2A | | |

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld [nn],ss |[nn+1] <- ssh |     |11101101|ED |4|6|

| |[nn] <- ssl | |01ss0011| | | |

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld [nn],.hl |[nn+1] <- .h |     |00100010|22 |3|5|

| |[nn] <- .l | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld [nn],.ix |[nn+1] <- .ixh |     |11011101|DD |4|6|

| |[nn] <- .ixl | |00100010|22 | | |

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ld [nn],.iy |[nn+1] <- .iyh |     |11111101|FD |4|6|

| |[nn] <- .iyl | |00100010|22 | | |

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

+--+---+---+---+---+

| |00 |01 |10 |11 |

+--+---+---+---+---+

|ss|.bc|.de|.hl|.sp|

+--+---+---+---+---+

<664 appendix A r800 instruction chart >

A.3 EXCHANGE INSTRUCTIONS

+-------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+-------------+----------------------------+-------------+--------+---+-+-+

|xch .de,.hl |.de <-> .hl |     |11101011|EB |1|1|

+-------------+----------------------------+-------------+--------+---+-+-+

|xch .af,.af' |.af <-> .af' |+ + + + + +|00001000|08 |1|1|

+-------------+----------------------------+-------------+--------+---+-+-+

|xch [.sp],.hl|.l <-> [.sp];.h <-> [sp+1] |     |11100011|E3 |1|5|

+---------- --+----------------------------+-------------+--------+---+-+-+

|xch [.sp],.ix|.ixl <-> [.sp] |     |11011101|DD |2|6|

| |.ixh <-> [.sp+1] | |11100011|E3 | | |

+-------------+----------------------------+-------------+--------+---+-+-+

|xch [.sp],.iy|.iyl <-> [.sp] |     |11111101|FD |2|6|

| |.iyh <-> [.sp] | |11100011|E3 | | |

+-------------+----------------------------+-------------+--------+---+-+-+

|xchx |.bc <-> .bc';.de <-> de'; |     |11011001|D9 |1|1|

| |.hl <-> .hl' | | | | | |

+-------------+----------------------------+-------------+--------+---+-+-+



A.4 STACK OPERATION INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|push qq |[.sp-2]<-qql;[sp-1]<-qqh |     |11qq0101| |1|4|

| |.sp <- .sp-2 | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|push .ix |[.sp-2]<-.ixl;[.sp-1]<-.ixh |     |11011101|DD |2|5|

| |.sp <- .sp-2 | |11100101|E5 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|push .iy |[.sp-2]<-.iyl;[.sp-1]<-.iyh |     |11111101|FD |2|5|

| |.sp <- .sp-2 | |11100101|E5 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|pop qq |qql<-[.sp];qqh<-[.sp+1] |     |11qq0001| |1|3|

| |.sp <- .sp+2 | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|pop .ix |.ixl<-[.sp];.ixh<-[.sp+1] |     |11011101|DD |2|4|

| |.sp <- .sp+2 | |11100001|E1 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|pop .iy |.iyl<-[.sp];.iyh<-[.sp+1] |     |11111101|FD |2|4|

| |.sp <- .sp+2 | |11100001|E1 | | |

+------------+----------------------------+-------------+--------+---+-+-+

+--+---+---+---+---+

| |00 |01 |10 |11 |

+--+---+---+---+---+

|qq|.bc|.de|.hl|.af|

+--+---+---+---+---+

In case of pop .af, all flags are changed

<A.5 block move instructions 665>



A.5 BLOCK MOVE INSTRUCTIONS

+------------+------------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+------------------------------+-------------+--------+---+-+-+

|move[.hl++],|[.de]<-[.hl];.de<-.de+1 |  0 + 0 |11101101|ED |2|4|

|[.de++], |.hl<-.hl+1;.bc<-.bc-1 | *1 |10100000|A0 | | |

+------------+------------------------------+-------------+--------+---+-+-+

|move[.hl--],|[.de]<-[.hl];.de+.de-1 |  0 + 0 |11101101|ED |2|4|

|[.de--] |.hl<-.hl-1;.bc<-.bc-1 | *1 |10101000|A8 | | |

+------------+------------------------------+-------------+--------+---+-+-+

|movem [.hl++|repeat;[.de]<-[.hl];.de<-.de+1|  0 0 0 |11101101|ED |2|4|

| ],[.de++] |.hl<-.hl+1;.bc<-.bc-1;until.bc=0| |10110000|B0 | | |

+------------+------------------------------+-+-----------+--------+---+-+-+

|movem [.hl--|repeat;[.de]<-[.hl];.de<-.de-1|  0 0 0 |11101101|ED |2|4|

| ],[.de--] |.hl<-.hl-1;.bc<-.bc-1;until.bc=0| |10111000|B8 | | |

+------------+--------------------------------+-----------+--------+---+-+-+

*1 when .bc-1 = 0 it will be set to 0 else it will be set to 1



A.6 BLOCK SEARCH INSTRUCTION

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|cmp |.a-[.hl];.hl<-.hl+1 |+ + + + 1 |11101101|ED |2|4|

| .a,[.hl++]|.bc<-.bc-1 | *2 *1 |10100001|A1 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|cmp |.a-[.hl];.hl<-.hl-1 |+ + + + 1 |11101101|ED |2|4|

| .a,[.hl--]|.bc<-.bc-1 | *2 *1 |10101001|A9 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|cmpm |repeat;.a-[.hl];.hl<-.hl+1 |+ + + + 1 |11101101|ED |2|5|

| .a,[hl++]|.bc<-.bc-1;until .bc=0 | *2 *1 |10110001|B1 | | |

| | or .a=[.hl] | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|cmpm |repeat;.a-[.hl];.hl<-.hl-1 |+ + + + 1 |11101101|ED |2|5|

| .a,[hl--]|.bc<-.bc-1;until .bc=0 | *2 *1 |10111001|B9 | | |

| | or .a=[.hl] | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

*1 when bc-1=0 it will be set to 0 else it will be set to 1

*2 when .a=[.hl] it will be set to 1 else it will be set to 0



A.7 MULTIPLICATION INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+--+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C |

+------------+----------------------------+-------------+--------+---+-+--+

|mulub .a,r |.hl<-.a*r |0 +  0  +|11101101|ED |2|14|

| | | |11 r 001| | | |

+------------+----------------------------+-------------+--------+---+-+--+

|muluw .hl,ss|.de:.hl<-.hl*ss |0 +  0  +|11101101|ED |2|36|

| | | |11ss0011| | | |

+------------+----------------------------+-------------+--------+---+-+--+

With the mulub function when .b,.c,.d,.e are excluded of r the usage can't be guaranteed. (???) With the muluw function then .bc,.sp are excluded of ss the usage can't be guaranteed. (???) <666 appendix a r800 instruction chart> A.8 ADD INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|add .a,r |.a<-.a+r |+ + + v 0 +|10000 r | |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|add .a,p |.a<-.a+p |+ + + V 0 +|11011101|DD |2|2|

| | | |10000 p | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|add .a,q |.a<-.a+q |+ + + V 0 +|11111101|FD |2|2|

| | | |10000 q | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|add .a,[.hl]|.a<-.a+[.hl] |+ + + V 0 +|10000110|86 |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|add |.a<-.a+[.ix+d] |+ + + V 0 +|11011101|DD |3|5|

| .a,[.ix+d] | | |10000110|86 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|add |.a<-.a+[.iy+d] |+ + + V 0 +|11111101|FD |3|5|

| .a,[.iy+d] | | |10000110|86 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|add a,n |.a<-.a+n |+ + + V 0 +|11000110|C6 |2|2|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|addc .a.r |.a<-.a+r+C |+ + + V 0 +|10001 r | |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|addc .a,p |.a<-.a+p+C |+ + + V 0 +|11011101|DD |2|2|

| | | |10001 p | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|addc .a,q |.a<-.a+q+C |+ + + V 0 +|11111101|FD |2|2|

| | | |10001 q | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|addc.a,[.hl]|.a<-.a+[.hl]+C |+ + + V 0 +|10001110|8E |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|addc |.a<-.a+[.ix+d]+C |+ + + V 0 +|11011101|DD |3|5|

| .a,[.ix+d] | | |10001110|8E | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|addc |.a<-.a+[.iy+d]+C |+ + + V 0 +|11111101|FD |3|5|

| .a,[.iy+d] | | |10001110|8E | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|addc .a,n |.a<-.a+n+C |+ + + V 0 +|11001110|CE |2|2|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|addc .hl,ss |.hl<-.hl+ss+C |+ + ? V 0 +|11101101|ED |2|2|

| | | |01ss1010| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|add .hl,ss |.hl<-.hl+ss |  ?  0 +|00ss1001| |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|add .ix,pp |.ix<-.ix+pp |  ?  0 +|11011101|DD |2|2|

| | | |00pp1001| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|add .iy,rr |.iy<-.iy+rr |  ?  0 +|11111101|FD |2|2|

| | | |00rr1001| | | |

+------------+----------------------------+-------------+--------+---+-+-+

<A.8 ADD INSTRUCTIONS 667>



+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|inc r |r<-r+1 |+ + + V 0 |00 r 100| |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|inc p |p<-p+1 |+ + + V 0 |11011101|DD |2|2|

| | | |00 p 100| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|inc q |q<-q+1 |+ + + V 0 |11111101|FD |2|2|

| | | |00 q 100| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|inc [.hl] |[.hl]<-[.hl]+1 |+ + + V 0 |00110100|34 |1|4|

+------------+----------------------------+-------------+--------+---+-+-+

|inc [.ix+d] |[.ix+d]<-[.ix+d]+1 |+ + + V 0 |11011101|DD |3|7|

| | | |00110100|34 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|inc [.iy+d] |[.iy+d]<-[.iy+d]+1 |+ + + V 0 |11111101|FD |3|7|

| | | |00110100|34 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|inc ss |ss<-ss+1 |     |00ss0011| |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|inc .ix |.ix<-.ix+1 |     |11011101|DD |2|2|

| | | |00100011|23 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|inc .iy |.iy<-.iy+1 |     |11111101|FD |2|2|

| | | |00100011|23 | | |

+------------+----------------------------+-------------+--------+---+-+-+

+--+---+---+---+---+

| |00 |01 |10 |11 |

+--+---+---+---+---+

|ss|.bc|.de|.hl|.sp|

+--+---+---+---+---+

|pp|.bc|.de|.ix|.sp|

+--+---+---+---+---+

|rr|.bc|.de|.iy|.sp|

+--+---+---+---+---+

+-+----+----+----+----+----+-----+----+----+

| |000 |001 |010 |011 |100 |101 |110 |111 |

+-+----+----+----+----+----+-----+----+----+

|p| | | | |.ixh|.ixl | | |

+-+----+----+----+----+----+-----+----+----+

|q| | | | |.iyh|.iyl | | |

+-+----+----+----+----+----+-----+----+----+

<668 APPENDIX A R800 INSTRUCTION CHART> A.9 DECREASE INSTRUCTION

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|sub .a,r |.a<.a-r |+ + + V 1 +|10010 r | |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|sub .a,p |.a<-.a-p |+ + + V 1 +|11011101|DD |2|2|

| | | |10010 p | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|sub .a,q |.a<-.a-q |+ + + V 1 +|11111101|FD |2|2|

| | | |10010 q | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|sub .a,[.hl]|.a<-.a-[.hl] |+ + + V 1 +|10010110|96 |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|sub .a, |.a<-.a-[.ix+d] |+ + + V 1 +|11011101|DD |3|5|

| [.ix+d] | | |10010110|96 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|sub .a, |.a<-.a-[.iy+d] |+ + + V 1 +|11111101|FD |3|5|

| [.iy+d] | | |10010110|96 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|sub .a,n |.a<-.a-n |+ + + V 1 +|11010110|D6 |2|2|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|subc .a,r |.a<-.a-r-C |+ + + V 1 +|10011 r | |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|subc .a,p |.a<-.a-p-C |+ + + V 1 +|11011101|DD |2|2|

| | | |10011 p | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|subc .a,q |.a<-.a-q-C |+ + + V 1 +|11111101|FD |2|2|

| | | |10011 q | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|subc .a, |.a<-.a-[.hl]-C |+ + + V 1 +|10011110|9E |1|2|

| [.hl] | | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|subc .a, |.A<-.A-[.IX+D]+c |+ + + V 1 +|11011101|DD |3|5|

| [.ix+d] | | |10011110|9E | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|subc .a, |.a<-.a-[.iy+d]+c |+ + + V 1 +|11111101|FD |3|5|

| [.iy+d] | | |10011110|9E | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|subc a,n |.a<-.a-n-C |+ + + V 1 +|11011110|DE |2|2|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|subc .hl,ss |.hl<-.hl-ss-C |+ + ? V 1 +|11101101|ED |2|2|

| | | |01ss0010| | | |

+------------+----------------------------+-------------+--------+---+-+-+

<A.10 DECREASE INSTRUCTION 669>



+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|dec r |r<-r-1 |+ + + V 1 |00 r 101| |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|dec p |p<-p-1 |+ + + V 1 |11011101|DD |2|2|

| | | |00 p 101| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|dec q |q<-q-1 |+ + + V 1 |11111101|FD |2|2|

| | | |00 q 101| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|dec [.hl] |[.hl]<-[.hl]-1 |+ + + V 1 |00110101|35 |1|4|

+------------+----------------------------+-------------+--------+---+-+-+

|dec [.ix+d] |[.ix+d]<-[.ix+d]-1 |+ + + V 1 |11011101|DD |3|7|

| | | |00110101|35 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|dec [.iy+d] |[.iy+d]<-[.iy+d]-1 |+ + + V 1 |11111101|FD |3|7|

| | | |00110101|35 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|dec ss |ss<-ss-1 |     |00ss1011| |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|dec .ix |.ix<-.ix-1 |     |11011101|DD |2|2|

| | | |00101011|2B | | |

+------------+----------------------------+-------------+--------+---+-+-+

|dec .iy |.iy<-.iy-1 |     |11111101|FD |2|2|

| | | |00101011|2B | | |

+------------+----------------------------+-------------+--------+---+-+-+



A.10 COMPARISON INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|cmp .a,r |.a-r |+ + + V 1 +|10111 r | |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|cmp .a,r |.a-p |+ + + V 1 +|11011101|DD |2|2|

| | | |10111 p | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|cmp .a,q |.a-q |+ + + V 1 +|11111101|FD |2|2|

| | | |10111 q | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|cmp .a,[.hl]|.a-[.hl] |+ + + V 1 +|10111110|BE |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|cmp .a, |.a-[.ix+d] |+ + + V 1 +|11011101|DD |3|5|

| [.ix+d] | | |10111110|BE | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|cmp .a, |.a-[.iy+d] |+ + + V 1 +|11111101|FD |3|5|

| [.iy+d] | | |10111110|BE | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|cmp .a,n |.a-n |+ + + V 1 +|11111110|FE |2|2|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

< 670 APPENDIX A R800 INSTRUCTION CHART>

A.11 LOGIC OPERATION INSTRUCTION

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|and .a,r |.a<-.a/\r |+ + 1 P 0 0|10100 r | |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|and .a,p |.a<-.a/\p |+ + 1 P 0 0|11011101|DD |2|2|

| | | |10100 p | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|and .a,q |.a<-.a/\q |+ + 1 P 0 0|11111101|FD |2|2|

| | | |10100 q | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|and .a,[.hl]|.a<-.a/\[.hl] |+ + 1 P 0 0|10100110|A6 |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|and .a, |.a<-.a/\[.ix+d] |+ + 1 P 0 0|11011101|DD |3|5|

| [.ix+d] | | |10100110|A6 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|and .a, |.a<-.a/\[.iy+d] |+ + 1 P 0 0|11111101|FD |3|5|

| [.iy+d] | | |10100110|A6 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|and .a,n |.a<-.a/\n |+ + 1 P 0 0|11100110|E6 |2|2|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|or .a,r |.a<-.a\/r |+ + 0 P 0 0|10110 r | |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|or .a,p |.a<-.a\/p |+ + 0 P 0 0|11011101|DD |2|2|

| | | |10110 p | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|or .a,q |.a<-.a\/q |+ + 0 P 0 0|11111101|FD |2|2|

| | | |10110 q | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|or .a,[.hl] |.a<-.a\/[.hl] |+ + 0 P 0 0|10110110|B6 |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|or .a, |.a<-.a\/[.ix+d] |+ + 0 P 0 0|11011101|DD |3|5|

| [.ix+d] | | |10110110|B6 | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|or .a, |.a<-.a\/[.iy+d] |+ + 0 P 0 0|11111101|FD |3|5|

| [.iy+d] | | |10110110| | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|or .a,n |.a<-.a\/n |+ + 0 P 0 0|11110110|F6 |2|2|

| | | |<- n > | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|xor .a,r |.a<-.a\-/r |+ + 0 P 0 0|10101 r | |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|xor .a,p |.a<-.a\-/p |+ + 0 P 0 0|11011101|DD |2|2|

| | | |10101 p | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|xor .a,q |.a<-.a\-/q |+ + 0 P 0 0|11111101|FD |2|2|

| | | |10101 q | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|xor .a,[.hl]|.a<-.a\-/[.hl] |+ + 0 P 0 0|10101110|AE |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|xor .a, |.a<-.a\-/[.ix+d] |+ + 0 P 0 0|11011101|DD |3|5|

| [.ix+d] | | |10101110|AE | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|xor .a, |.a<-.a\-/[.iy+d] |+ + 0 P 0 0|11111101|FD |3|5|

| [.iy+d] | | |10101110|AE | | |

| | | |<- d ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|xor .a,n |.a<-.a\-/n |+ + 0 P 0 0|11101110|EE |2|2|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

<A.12 BIT OPERATION INSTRUCTION 671>

A.12 BIT OPERATION INSTRUCTION

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|bit b,r |z<-NOT r{b} |? + 1 ? 0 |11001011|CB |2|2|

| | | |01 b r | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bit b,[.hl] |z<-NOT [.hl]{b} |? + 1 ? 0 |11001011|CB |2|2|

| | | |01 b 110| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bit b, |z<-NOT [.ix+d]{b} |? + 1 ? 0 |11011101|DD |4|5|

| [.ix+d] | | |11001011|CB | | |

| | | |<- d ->| | | |

| | | |01 b 110| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bit b, |z<-NOT [.iy+d]{b} |? + 1 ? 0 |11111101|FD |4|5|

| [.iy+d] | | |11001011|CB | | |

| | | |<- d ->| | | |

| | | |01 b 110| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|set b,r |r{b}<-1 |     |11001011|CB |2|2|

| | | |11 b r | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|set b,[.hl] |[.hl]{b}<-1 |     |11001011|CB |2|5|

| | | |11 b 110| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|set b, |[.ix+d]{b}<-1 |     |11011101|DD |4|7|

| [.ix+d] | | |11001011|CB | | |

| | | |<- d ->| | | |

| | | |11 b 110| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|set b, |[.iy+d]{b}<-1 |     |11111101|FD |4|7|

| [.iy+d] | | |11001011|CB | | |

| | | |<- d ->| | | |

| | | |11 b 110| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|clr b,r |r{b}<-0 |     |11001011|CB |2|2|

| | | |10 b r | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|clr b,[.hl] |[.hl]{b}<-0 |     |11001011|CB |2|5|

| | | |10 b 110| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|clr b, |[.ix+d]{b}<-0 |     |11011101|DD |4|7|

| [.ix+d] | | |11001011|CB | | |

| | | |<= d ->| | | |

| | | |10 b 110| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|clr b, |[.iy+d]{b}<-0 |     |11111101|FD |4|7|

| [.iy+d] | | |11001011|CB | | |

| | | |<- d ->| | | |

| | | |10 b 110| | | |

+------------+----------------------------+-------------+--------+---+-+-+

<672 APPENDIX A R800 INSTRUCTION CHART> A.13 ROTATE INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|rol a |C<-.a{7};.a<-.a*2;a{0}<-C |  0  0 +|00000111|07 |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|ror a |C<-.a{0};.a<-.a/2;a{7}<-C |  0  0 +|00001111|0F |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|rolc a |tmp<-C;C<-.a{7};.a<-.a*2; |  0  0 +|00010111|17 |1|1|

| | .a{0}<-tmp | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rorc a |tmp<-C;C<-.a{0};.a<-.a/2; |  0  0 +|00011111|1F |1|1|

| | .a{7}<-tmp | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rol r |C<-r{7} |+ + 0 P 0 +|11001011|CB |2|2|

| |r<r*2;r{0}<-c | |00000 r | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rol [.hl] |C<-[.hl]{7} |+ + 0 P 0 +|11001011|CB |2|5|

| |[.hl]<-[.hl]*2;[.hl]{0}<-C | |00000110|06 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rol [.ix+d] |C<-[.ix+d]{7} |+ + 0 P 0 +|11011101|DD |4|7|

| |[.ix+d]<-[.ix+d]*2 | | |CB | | |

| |[.ix+d]{0}<-C | |<- d ->| | | |

| | | |00000110|06 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rol [.iy+d] |C<-[.iy+d]{7} |+ + 0 P 0 +|11111101|FD |4|7|

| |[.iy+d]<-[.iy+d]*2 | | |CB | | |

| |[.iy+d]{0}<-C | |<- d ->| | | |

| | | |00000110|06 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ror r |C<-r{0} |+ + 0 P 0 +|11001011|CB |2|2|

| |r<-r/2;r{7}<-C | | | | | |

| | | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ror [.hl] |C<-[.hl]{0} |+ + 0 P 0 +|11001011|CB |2|5|

| |[.hl]<-[.hl]/2;[.hl]{7}<-C | |00001110|0E | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ror [.ix+d] |C<-[.ix+d]{0} |+ + 0 P 0 +|11011101|DD |4|7|

| |[.ix+d]<-[.ix+d]/2 | | |CB | | |

| |[.ix+d]{7}<-C | |<- d ->| | | |

| | | |00001110|06 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rol [.iy+d] |C<-[.iy+d]{0} |+ + 0 P 0 +|11111101|FD |4|7|

| |[.iy+d]<-[.iy+d]/2 | | |CB | | |

| |[.iy+d]{7}<-C | |<- d ->| | | |

| | | |00001110|06 | | |

+------------+----------------------------+-------------+--------+---+-+-+

<A.13 ROTATE INSTRUCTIONS 673>

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|rolc r |tmp<-C;C<-r{7} |+ + 0 P 0 +|11001011|CB |2|2|

| |r<-r*2;r{0}<-tmp | |00010 r | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rolc [.hl] |tmp<-C;C<-[.hl]{7} |+ + 0 P 0 +|11001011|CB |2|5|

| |[.hl]<-[.hl]*2;[.hl]{0}<-tmp| |00010110|16 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rolc [.ix+d]|tmp<-C |+ + 0 P 0 +|11011101|DD |4|7|

| |C<-[.ix+d]{7} | |11001011|CB | | |

| |[.ix+d]<-[.ix+d]*2 | |<- b ->| | | |

| |[.ix+d]{0}<-tmp | |00010110|16 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rolc [.iy+d]|tmp<-C |+ + 0 P 0 +|11111101|FD |4|7|

| |C<-[.iy+d]{7} | |11001011|CB | | |

| |[.iy+d]<-[.iy+d]*2 | |<- b ->| | | |

| |[.iy+d]{0}<-tmp | |00010110|16 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rorc r |tmp<-C;C<-r{0} |+ + 0 P 0 +|11001011|CB |2|2|

| |r<-r/2;r{7}<-tmp | |00011 r | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rorc [.hl] |tmp<-C;C<-[.hl]{0} |+ + 0 P 0 +|11001011|CB |2|5|

| |[.hl]<-[.hl]/2;[.hl]{7}<-tmp| |00011110|1E | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rorc [.ix+d]|tmp<-C |+ + 0 P 0 +|11011101|DD |4|7|

| |C<-[.ix+d]{0} | |11001011|CB | | |

| |[.ix+d]<-[.ix+d]/2 | |<- b ->| | | |

| |[.ix+d]{7}<-tmp | |00011110|16 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rorc [.iy+d]|tmp<-C |+ + 0 P 0 +|11111101|FD |4|7|

| |C<-[.iy+d]{0} | |11001011|CB | | |

| |[.iy+d]<-[.iy+d]/2 | |<- b ->| | | |

| |[.iy+d]{7}<-tmp | |00011110|1E | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rol4 [.hl] |tmp<-.a{0..3} |+ + 0 P 0 |11101101|ED |2|5|

| |.a{0..3}<-[.hl]{4..7} | |11101111|6F | | |

| |[.hl]{4..7}<-[.hl]{0..3} | | | | | |

| |[.hl]{0..3}<-tmp | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|rol4 [.hl] |tmp<-.a{0..3} |+ + 0 P 0 |11101101|ED |2|5|

| |.a{0..3}<-[.hl]{4..7} | |11100111|67 | | |

| |[.hl]{4..7}<-[.hl]{0..3} | | | | | |

| |[.hl]{0..3}<-tmp | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

<674 APPENDIX A R800 INSTRUCTION CHART



A.14 SHIFT INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|shl r |C<-r{7} |+ + 0 P 0 +|11001011|CB |2|2|

|shla |r<-r*2 | |00100 r | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shl [.hl] |C<-[.hl]{7} |+ + 0 P 0 +|11001011|CB |2|5|

|shla |[.hl]<-[.hl]*2 | |00100110|26 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shl [,ix+d] |C<-[.ix+d]{7} |+ + 0 P 0 +|11011101|DD |4|7|

|shla |[.ix+d]<-[.ix+d]*2 | |11001011|CB | | |

| | | |<- d ->| | | |

| | | |00100110|26 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shl [,iy+d] |C<-[.iy+d]{7} |+ + 0 P 0 +|11111101|DD |4|7|

|shla |[.iy+d]<-[.iy+d]*2 | |11001011|CB | | |

| | | |<- d ->| | | |

| | | |00100110|26 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shr r |C<-r{0} |+ + 0 P 0 +|11001011|CB |2|2|

| |r<-r/2 | |00111 r | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shr [.hl] |C<-[.hl]{0} |+ + 0 P 0 +|11001011|CB |2|5|

| |[.hl]<-[.hl]/2 | |00111110|3E | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shr [,ix+d] |C<-[.ix+d]{0} |+ + 0 P 0 +|11011101|DD |4|7|

| |[.ix+d]<-[.ix+d]/2 | |11001011|CB | | |

| | | |<- d ->| | | |

| | | |00111110|3E | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shr [,iy+d] |C<-[.iy+d]{0} |+ + 0 P 0 +|11111101|DD |4|7|

| |[.iy+d]<-[.iy+d]/2 | |11001011|CB | | |

| | | |<- d ->| | | |

| | | |00111110|3E | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shra r |tmp<-r{7};C<-r{0} |+ + 0 P 0 +|11001011|CB |2|2|

| |r<-r/2;r{7}<-tmp | |00101 r | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shra [.hl] |tmp<-[.hl]{7};C<-[.hl]{0} |+ + 0 P 0 +|11001011|CB |2|2|

| |[.hl]<-[.hl]/2;[.hl]{7}<-tmp| |00101110|2E | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shra [.ix+d]|tmp<-[.ix+d]{7} |+ + 0 P 0 +|11011101|DD |4|7|

| |C<-[.ix+d]{0} | |11001011|CB | | |

| |[.ix+d]<-[.ix+d]/2 | |<- d ->| | | |

| |[.ix+d]{7}<-tmp | |00101110|2E | | |

+------------+----------------------------+-------------+--------+---+-+-+

|shra [.iy+d]|tmp<-[.iy+d]{7} |+ + 0 P 0 +|11111101|FD |4|7|

| |C<-[.iy+d]{0} | |11001011|CB | | |

| |[.iy+d]<-[.iy+d]/2 | |<- d ->| | | |

| |[.iy+d]{7}<-tmp | |00101110|2E | | |

+------------+----------------------------+-------------+--------+---+-+-+

The shl instruction and the shla instruction are exectly the same and use the same operand.

<A.15 BRANCH INSTRUCTIONS 675>



A.15 BRANCH INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|br nn |.pc<-nn |     |11000011|C3 |3|3|

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bnz nn |if z=0 |     |11000010|C2 |3|3|

| |.pc<-nn | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bz nn |if z=1 |     |11001010|CA |3|3|

| |.pc<-nn | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bnc nn |if c=0 |     |11010010|D2 |3|3|

| |.pc<-nn | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bc nn |if c=1 |     |11011010|DA |3|3|

| |.pc<-nn | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bpo nn |if P/v=0 |     |11100010|E2 |3|3|

| |.pc<-nn | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bpe nn |if P/v=1 |     |11101010|EA |3|3|

| |.pc<-nn | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bp nn |if s=0 |     |11110010|F2 |3|3|

| |.pc<-nn | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|bm nn |if s=1 |     |11111010|FA |3|3|

| | | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|br [.hl] |.pc<-.hl |     |11101001|E9 |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|br [.ix] |.pc<-.ix |     |11011101|DD |2|2|

| | | |11101001| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|br [.iy] |.pc<-.iy |     |11111101|FD |2|2|

| | | |11101001| | | |

+------------+----------------------------+-------------+--------+---+-+-+

<676 APPENDIX A R800 INSTRUCTION CHART>

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|short |.pc<-.pc+e |     |00011000|18 |2|3|

|br e | | |<- e-2->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|short |if z=0 |     |00100000|20 |2|2|

|bnz e |.pc<-.pc+e | |<- e-2->| | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|short |if z=1 |     |00101000|28 |2|2|

|bz e |.pc<-.pc+e | |<- e-2->| | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|short |if c=0 |     |00110000|30 |2|2|

|bnc e |.pc<-.pc+e | |<- e-2->| | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|short |if c=1 |     |00111000|38 |2|2|

|bc e |.pc<-.pc+e | |<- e-2->| | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|dbnz e |.b<-.b-1;if .b<>0 |     |00010000|10 |2|2|

| |.pc<-.pc+e | |<- e-2->| | | |

+------------+----------------------------+-------------+--------+---+-+-+



A.16 CALL INSTRUCTIONS



+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|call nn |[.sp-2]<-.spl;[.sp-1]<-.sph |     |11001101|CD |3|5|

| |.sp<-.sp-2;.pc<-nn | |<-nnl ->| | | |

| | | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|call nz,nn |if z=0 |     |11000100|C4 |3|3|

| |[.sp-2]<-.pcl;[.sp-1]<-.pch | |<-nnl ->| | |5|

| |.sp<-.sp-2;.pc<-nn | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|call z,nn |if z=1 |     |11001100|CC |3|3|

| |[.sp-2]<-.pcl;[.sp-1]<-.pch | |<-nnl ->| | |5|

| |.sp<-.sp-2;.pc<-nn | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|call nc,nn |if c=0 |     |11010100|D4 |3|3|

| |[.sp-2]<-.pcl;[.sp-1]<-.pch | |<-nnl ->| | |5|

| |.sp<-.sp-2;.pc<-nn | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|call c,nn |if c=1 |     |11011100|DC |3|3|

| |[.sp-2]<-.pcl;[.sp-1]<-.pch | |<-nnl ->| | |5|

| |.sp<-.sp-2;.pc<-nn | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|call po,nn |if P/v=0 |     |11100100|E4 |3|3|

| |[.sp-2]<-.pcl;[.sp-1]<-.pch | |<-nnl ->| | |5|

| |.sp<-.sp-2;.pc<-nn | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|call pe,nn |if P/v=1 |     |11101100|EC |3|3|

| |[.sp-2]<-.pcl;[.sp-1]<-.pch | |<-nnl ->| | |5|

| |.sp<-.sp-2;.pc<-nn | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|call p,nn |if s=0 |     |11110100|F4 |3|3|

| |[.sp-2]<-.pcl;[.sp-1]<-.pch | |<-nnl ->| | |5|

| |.sp<-.sp-2;.pc<-nn | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|call m,nn |if s=1 |     |11111100|FC |3|3|

| |[.sp-2]<-.pcl;[.sp-1]<-.pch | |<-nnl ->| | |5|

| |.sp<-.sp-2;.pc<-nn | |<-nnh ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

<A.16 CALL INSTRUCTIONS 677

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|ret |.pcl<-[.sp];.pch<-[.sp+1] |     |11001001|C9 |1|3|

| |.sp<-.sp+2 | | | | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ret nz |if z=0 ; .pcl<-[.sp] |     |11000000|C0 |1|1|

| |.pch<-.[.sp+1];.sp<-.sp+2 | | | | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|ret z |if z=1 ; .pcl<-[.sp] |     |11001000|C8 |1|1|

| |.pch<-.[.sp+1];.sp<-.sp+2 | | | | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|ret nc |if c=0 ; .pcl<-[.sp] |     |11010000|D0 |1|1|

| |.pch<-.[.sp+1];.sp<-.sp+2 | | | | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|ret c |if c=1 ; .pcl<-[.sp] |     |11011000|D8 |1|1|

| |.pch<-.[.sp+1];.sp<-.sp+2 | | | | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|ret po |if P/v=0 ; .pcl<-[.sp] |     |11100000|E0 |1|1|

| |.pch<-.[.sp+1];.sp<-.sp+2 | | | | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|ret pe |if P/v=1 ; .pcl<-[.sp] |     |11101000|E8 |1|1|

| |.pch<-.[.sp+1];.sp<-.sp+2 | | | | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|ret p |if s=0 ; .pcl<-[.sp] |     |11110000|F0 |1|1|

| |.pch<-.[.sp+1];.sp<-.sp+2 | | | | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|ret m |if s=1 ; .pcl<-[.sp] |     |11111000|F8 |1|1|

| |.pch<-.[.sp+1];.sp<-.sp+2 | | | | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|ret i |interrupt return |     |11101101|ED |2|5|

| | | |01001101|4D | | |

+------------+----------------------------+-------------+--------+---+-+-+

|ret n |Non Maskable Interrupt |     |11101101|ED |2|5|

| | return | |01000101|45 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|brk k |[.sp-2]<-.pcl;[.sp-1]<-.pch |     |11 111|C0 |1|4|

| |.sp<-.sp-2;.pcl<-k;pch<-0 | | k/8 | | | |

+------------+----------------------------+-------------+--------+---+-+-+

<678 APPENDIX A R800 INSTRUCTION CHART>

A.17 INOUT/OUTPUT INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|in .a,[n] |.a<-[n] |     |11011011|DB |2|3|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|in r,[.c] |r<-[.c] |+ + 0 P 0 |11101101|ED |2|3|

| | | |01 r 000| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|in .f,[.c] |.f<-[.c] |+ + 0 P 0 |11101101|ED |2|3|

| | | |01110000|70 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|in |[.hl]<-[.c];.b<-.b-1 |? + ? ? 1 |11101101|ED |2|4|

|[.hl++],[.c]|.hl<-.hl+1 | *1 |10100010|A2 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|in |[.hl]<-[.c];.b<-.b-1 |? + ? ? 1 |11101101|ED |2|4|

|[.hl--],[.c]|.hl<-.hl-1 | *1 |10101010|AA | | |

+------------+----------------------------+-------------+--------+---+-+-+

|inm |repeat;[.hl]<-[.c];.b<-.b-1 |? 1 ? ? 1 |11101101|ED |2|4|

|[.hl++],[.c]|.hl<-.hl+1;until .b=0 | |10110010|B2 | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|inm |repeat;[.hl]<-[.c];.b<-.b-1 |? 1 ? ? 1 |11101101|ED |2|4|

|[.hl--],[.c]|.hl<-.hl-1;until .b=0 | |10111010|BA | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|out [n],.a |[n]<-.a |     |11010011|D3 |2|3|

| | | |<- n ->| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|out [.c],r |[.c]<-r |     |11101101|ED |2|3|

| | | |01 r 001| | | |

+------------+----------------------------+-------------+--------+---+-+-+

|out |[.c]<-[.hl];.b<-.b-1 |? + ? ? 1 |11101101|ED |2|4|

|[.c],[.hl++]|.hl<-.hl+1 | *1 |10100011|A3 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|out |[.c]<-[.hl];.b<-.b-1 |? + ? ? 1 |11101101|ED |2|4|

|[.c],[.hl--]|.hl<-.hl-1 | *1 |10101011|AB | | |

+------------+----------------------------+-------------+--------+---+-+-+

|outm |repeat;[.c]<-[.hl];.b<-.b-1 |? 1 ? ? 1 |11101101|ED |2|4|

|[.c],[.hl++]|.hl<-.hl+1;until .b=0 | |10110011|B3 | |3|

+------------+----------------------------+-------------+--------+---+-+-+

|outm |repeat;[.c]<-[.hl];.b<-.b-1 |? 1 ? ? 1 |11101101|ED |2|4|

|[.c],[.hl--]|.hl<-.hl-1;until .b=0 | |10111011|BB | |3|

+------------+----------------------------+-------------+--------+---+-+-+

*1 als .b-1=0 it is set to 1 else it is 0

dependent of the external port which the .c register of in.f,[.c] desginates, flags will be changed. It doesn't matter where the external port is.(???) <A.18 CPU CONTROL INSTRUCTIONS 679>

A.18 CPU CONTROL INSTRUCTIONS

+------------+----------------------------+-------------+------------+-+-+

|MNEMONIC | INSTRUCTION ACTION | FLAGS | OPCODE | | |

| | | +--------+---+ | |

| | |S Z H P/v N C|76543210|HEX|B|C|

+------------+----------------------------+-------------+--------+---+-+-+

|adj .a |adjust to decimal |+ + + P  +|00100111|27 |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|not .a |.a<-NOT .a |  1  1 |00101111|2F |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|neg .a |.a<-NOT .a+1 |+ + + V 1 +|11101101|ED |2|2|

| | | |01000100|44 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|not c |C<-NOT C |  ?  0 +|00111111|3F |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|set c |C<-1 |  0  0 1|00110111|37 |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|nop |NO operation |     |00000000|00 |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|halt |HALT |     |01110110|76 |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|di |IFF<-0 |     |11110011|F3 |1|2|

+------------+----------------------------+-------------+--------+---+-+-+

|ei |IFF<-1 |     |11111011|FB |1|1|

+------------+----------------------------+-------------+--------+---+-+-+

|im 0 |interrupt mode 0 |     |11101101|ED |2|3|

| | | |01000110|46 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|im 1 |interrupt mode 1 |     |11101101|ED |2|3|

| | | |01010110|56 | | |

+------------+----------------------------+-------------+--------+---+-+-+

|im 2 |interrupt mode 2 |     |11101101|ED |2|3|

| | | |01011110|5E | | |

+------------+----------------------------+-------------+--------+---+-+-+

<680 >

<681 >

------------------------------------------------------------------------

B

R800 MULTIPLICATION MACRO

------------------------------------------------------------------------

B.1 MULTIPLICATION INSTRUCTIONS OF THE R800

The following multiplication instructions are available.



B.1.1 8 bit MULTIPLICATIONS

Two of the same kind 8 bit registers are filled and the result appears in register HL. The multiplication is performed with an instruction.

The instruction are shown below.

----------------------------------------------------------------------------

operation instruction clock cycles

----------------------------------------------------------------------------

HL<-A*B ED C1 14

HL<-A*C ED C9 14

HL<-A*D ED D1 14

HL<-A*E ED D9 14

---------------------------------------------------------------------------



B.1.2 16 bit MULTIPLICATIONS

Two of the same kind 16 bit registers are filled and the result appears in registers DE:HL. The multiplication is performed with an instruction.

The instruction are shown below.

----------------------------------------------------------------------------

operation instruction clock cycles

----------------------------------------------------------------------------

DE:HL<-HL*BC ED C3 36

DE:HL<-HL*SP ED F3 36

----------------------------------------------------------------------------

<682 APPENDIX A R800 INSTRCUCTION CHART>

B.2 MULTIPLICATION MACRO FOR M80



When using multiplications in M80, this macro can be used.



mult8 macro reg

ifidn <reg>,<b> defb 0edh,0c1h

else

ifidn <reg>,<B> defb 0edh,0c1h

else

ifidn <reg>,<c> defb 0edh,0c9h

else

ifidn <reg>,<C> defb 0edh,0c9h

else

ifidn <reg>,<d> defb 0edh,0d1h

else

ifidn <reg>,<D> defb 0edh,0d1h

else

ifidn <reg>,<e> defb 0edh,0d9h

else

ifidn <reg>,<E> defb 0edh,0d9h

else

if1

.printx *MULT8: illegal argument*

defb 00h,00h

err

endif

endif

endif

endif

endif

endif

endif

endif

endif

endm



mult16 macro reg

ifidn <reg>,<bc> defb 0edh, 0c3h

else

ifidn <reg>,<BC> defb 0edh,0c3h

else

<B.2 MULTIPLICATION MACRO FOR M80 683> ifidn <reg>,<sp> defb 0edh, 0f3h

else

ifidn <reg>,<SP> defb 0edh,0f3h

else

if1

.printx *MULT16: illegal argument*

defb 00h, 00h

err

end if

end if

end if

end if

end if

endm

<684 >

< 685></code>





MSX-BASIC-KUN (BASIC COMPILER)



by J.Suzuki 1989

this document & samples by Sho Endo translate to english by LASP

this text file typed without changes by Nestor Soriano

MSX-BASIC-KUN is an incredible BASIC compiler. It will compile a BASIC

program on memory in few seconds and execute it 15 to 100 times faster!! It can compile most of the statements and functions of MSX-BASIC and can handle strings and floating numbers. Once you see it, you'd feel you'd never need to learn the Z-80 machine language. Real time games, C.G., demo programs can be written by the ease of BASIC for machine language speed.



*** USAGE ***



1. Settings & General knowledge

This compiler is sold in Japan as a cartridge for 4500 yen. You just set it in a slot to use it. Also, you can found this compiler in MSX2+ Sanyo machines, in ROM.



Now you are in BASIC mode as usual, except that two commands are available:

CALL RUN

CALL TURBO ON/OFF



"CALL" can be written as "_" (underscore). I will ise that from now on.



_RUN is the command to compile and execute the entire program on memory. If it finds an error it will stop and yield the message.



_TURBO ON is the statement to define the beginning of the turbo block.

_TURBO OFF is the end of the block.



The turbo block is the part of the program you want to execute fast. When the entire program contains some uncompilable statements, you can define the block to be compiled using this set.



EXAMPLE



100 SCREEN 8:DEFINT A-Z

110 BLOAD"PICTURE",S

120 _TURBO ON

130 FOR X=0 TO 255

140 LINE(X,0)-(X,211),0

150 NEXT X

160 _TURBO OFF

170 GOTO 170



This program cannot be "_RUN", because the "BLOAD" is one of the commands that cannot be compiled. If you "RUN" this, the part lines 130 through 150

will be executed fast.



As '_RUN"FILE"' is not supported, you have to add _TURBO ON and _TURBO OFF at the beginning and the end if you want to RUN"FILE" and have the effect.



100 FOR I=0 TO 999

110 ...

.

.

.

890 'END OF THE PROGRAM



So, this can be _RUN or add 10 _TURBO ON and 900 _TURBO OFF and RUN"FILE".



If you _RUN a program containing "_TURBO ON/OFF" it will be an error.



_TURBO ON/OFF can not be written in a multi-statement lines.



_TURBO ON/OFF can not be nested. But you may have many closed blocks in a program.



Variables and arrays are handled differently in and outside of the blocks.

Once you are out of the block, variables and arrays used in the block are lost. Only, the integer types can be defined as common.



100 DEFINT A-Z:DIM C(2),D(2) 110 A=1:B=2:C(0)=3:D(0)=4

120 _TURBO ON(A,C()) 130 DIM D(2) 140 PRINT A,B,C(0),D(0) 150 A=5:B=6:C(0)=7:D(0)=8

160 _TURBO OFF

170 PRINT A,B,C(0),D(0)

RUN

1 0 3 0

5 2 7 4

Ok



Floating numbers used by the compiler is a special format 3-byte value. It's accuracy is about 4.5 digits. Double precision is not available.



An array must be declared by a constant in the beginning.



This compiler works on the BASIC program on the RAM and creates the objects and variables on the left RAM. So there is a limit of the size of the source program about 10K. Big arrays, string variables (each uses 256 byte), CLEAR

???,&H???? will make the situation tighter as you can imagine. The compiled objects can not be saved as independent programs.



Interrupts available, such as KEY(1) ON, OFF etc. But it will decrease the efficiency of the executed object's size & speed.



Some statements may not work correctly.



100 GOTO 130

110 A=3/2

120 END

130 DEFINT A-Z

140 GOTO 110



If you RUN this, A is 1. If you _RUN this, A is 1.5. DEF??? will be effective when encountered during the execution in the case of interpreter, while it depends on the order of line number in the other case.



A little complicated string operation may cause easily a "String formula too complex" error. As this compiler has only one level of stack for it. Break a long string formula into multiple small ones, if so.



If you _RUN an endless program, you can not stop it. Make a part to check keyboards.



100 GOTO 100 'Reset or power off to stop

100 IF INKEY$="" THEN 100

110 END

is better.





2. Difference from MSX-BASIC interpreter




List of statements, commands and functions that can not be compiled.



AUTO, BASE, BLOAD, BSAVE, CALL, CDBL, CINT, CLEAR, CLOAD, CLOAD?, CLOSE, CONT, CSAVE, CSNG, CVD, CVI, CVS, DEFFN, DELETE, DRAW, DSKF, EOF, ERASE, ERL, ERR, ERROR, EQV, FIELD, FILES, FPOS, FRE, GET, IMP, INPUT#, KEY LIST, LFILES, LINEINPUT#, LIST, LLIST, LOAD, LOC, LOF, LPRINT USING, LSET, MAXFILES, MERGE, MOTOR, MKD$, MKI$, MKS$, NAME, NEW, ON ERROR GOTO, ON INTERVAL GOSUB (due to a bug), OPEN, PLAY, PRINT#, PRINT USING, PUT KANJI, RENUM, RESUME, RSET, SAVE, SPC, TAB, TRON, TROFF, WIDTH.



List of those with limits.



CIRCLE: Start, end angles and aspect ratio can't be specified.

COPY: Only graphic COPY is available.

DEFDBL: Same as DEFSNG.

DIM: Must come first in the program or in the turbo block.

INPUT: Can handle only one variable at the time.

KEY: ON KEY GOSUB, KEY(n) ON/OFF only.

LOCATE: x,y must be given in as a set. No cursor switch parameter.

NEXT: Variable names after the NEXT can not be omitted.

ON: ON STOP GOSUB, ON INTERVAL GOSUB not available.

PRINT: Commas work in a different way. No wrapping for digits.

PUT: PUT SPRITE only.

RUN: Variables won't be initialized.

SCREEN: Screen mode and sprite size only.

SET: SET PAGE only.

STOP: Same as END.

USR: Parameter type must be integer only.

VARPTR: File number can not be given as the parameter.



Otherwise there is no significant difference.



In general, I/O commands & functions, and editing commands can not be compiled. Of course they are available in the direct mode, and outside of the turbo block. You can edit, debug and save a program in MSX-BASIC and execute it by _RUN.



If you want to use PRINT# to write characters on GRP:, use it outside of turbo block. Otherwise study the sample, "PRINT.TRB".



If you want to use PLAY, use BGM compiler, and get the sound by USR(n).





3. New features added




3 special commands are available by starting a remark line with some specific characters.



#I

Stands for INLINE. You can write a short machine-language routine.



100 DEFINT A-Z

110 K=1

120 '#I &H2A,K

130 '#I &HF3,&HCD,@150,&HFB

140 END

150 'SUB

160 RETURN



120 means LD HL,(K); K must be a simple variable of integer type.

130 means DI

CALL @150 ;Be careful, this line won't be RENUMed.

EI



#C

Stands for CLIP. In the screen modes 5 through 8 (except for PAINT, and CIRCLE), this will be set clipping on and off.



10 SCREEN 8

20 '#C-

30 LINE(0,0)-(255,255) 'Y CLIPPED

40 IF INKEY$="" THEN 40

50 '#C+

60 LINE(0,0)-(255,255) 'NOT CLIPPED

70 IF INKEY$="" THEN 70



#N

Check if NEXT overflows.



10 FOR I%=0 TO &H7FFF

20 NEXT I%



This program will end up in a "Overflow error" in MSX-BASIC. And if _RUN, it will be an endless loop. If #N+ is specififed, it will end normally. This code will decrease the efficiency of the object, too. Better not use unless it's really necessary. To clear, specify #N-.



NOTE: In MSX-2+ Sanyo you can found a new command:

CALL BC



This command turn on the BASIC COMPILER options.





ORIGINAL PANA AMUSEMENT CARTRIDGE FOR MSX2 COMPUTER's page # of 48



HOMESOFT - HOME SOFTWARE BENELUX bv kuppersweg 63065

2031 EB Haarlem/Holland



Telefoon (023) 311 241

Telefax (023) 318 488

Databank (023) 319 517



Foreword:



Welcome! Thank you for bying our FM Pana Amusement Cartridge. The FM

Pana Amusement Cartridge is an FM sound adaptor with S-ram (static) that can be used with either MSX2 computers that have 32K of Ram or more.

Please read this manual before



Keep this manual near and refer to it when necessary.



S-Ram mark for games



MSX music mark



MSX is a registrated trademark of ASCII Inc.



Some of the things that we can do with the Cartridge

S-RAM (-> page 7)



When used with games that have the S-RAM mark, the data from the game may be saved to the S-RAM in the cartridge and the game may be continued at a later time.



FM-sound (-> page 9)



When used with games that have the Music mark you can experience exciting sounds and stimulating music.



FM- sound extended BASIC (-> page 34)

You can make use of the FM sound functions with Basic

------------------------------------------------------------------------

The FM Pana Amusement Cartridge consist of so many letters it may be hard to remember. So for convinience sake, we will refer to it as the FMPAC from now on. We will also refer to the S-RAM PAC, mentioned earlier, and the FMPAC as just

------------------------------------------------------------------------



Contents Page

Be careful of these points! 4



Some difficult terms 5



Installing and removing the FMPAC 6



Using the PAC's with games 7

Use with games taht are S-RAM compatible 7

USE with games that have the music mark 9



Built in software (PAC commander) 10

The magical (PAC commander) 10

Starting and ending the PAC commander 11

Using the PAC commander 13

Checking the slotnumber 15

Spell 1: (Clear) 16

Spell 2: (Copy) 18

Spell 3: (Change) 26

Spell 4: (Delete file) 27

Spell 5: (Slot) 29

Spell 6: (BGM) 30



What to do when you see error messages 31



FM-sound extended BASIC (MSX-MUSIC) 34

(MSX-MUSIC) commands 35

Sample programs 41

MML table 42

Sound data table 44

Temper table 45



Specifications 46



Trouble shooting 47



General Care 48



Be careful of theese points!



The FMPAC has it's weaknesses.



Avoid the following to keep your FMPAC: Healthy.Ps

Keep the FMPAC out of direct sunlight

Do not spill liquids in the FMPAC



Do not drop or apply shock to the FMPAC



Do not remove the screews or open the case

If the FMPAC does not seem to be working proberley, refer to page 47



Some difficult terms.



You know that your FMPAC is for use with MSX computers. When you are reading this manual. You may come across some difficult words about computers or special terms. We will explain the Important words here so take note and remember them



Data



Information. For example: if you save a game in the middle of plays, the stage number and the level will become information.



S-RAM



Something that will preserve game data for later use. It is like a memo pad.



File



What you call data when it is read or copied from a floppy disk. A file will always have a name.



Floppy Disk



Something used to write instructions or files from a computer. It works something like a casette drive.



Save



This is what you call the writing data to the S-RAM or Floppy Disk

Load



This is what you call the reading data (file)

Installing and removing the FMPAC



The FMPAC is inserted into the MSX slot. The slot that can be used may be different for each game so refer to the game's manual

------------------------------------------------------------------------

When inserting and removing a cartridge into the slot, be sure that the power of the computer is turned OFF!!!

------------------------------------------------------------------------



Installation



Refer to the computeres manual and check how to insert Cartridges.



Removal



Hold the computer dowm with one hand and remove with the other.



Using the PAC's with games

Use the games that are S-RAM compatible

If you use this cartridge with games that have the S-RAM compatible mark on them, you will be able to save data into the FMPAC



------------------------------------------------------------------------

Different games you use may have different ways of using the S-RAM so you should read the game manual for details.

------------------------------------------------------------------------



Data that is saved in the middle of a game is stored in the portion of the FMPAC that is called the S-RAM. The S-RAM id divided into 8 small rooms (segments) and each game uses a seperate room. The room to be used by the game is explained in th



Example:



Pana Amusemnet Cartridge

1 2 3 4 5 6 7 8



The number that is shown in inverse white on black, is the room that is used by that game.



If you save a game into a room that has been used before, the data that was there before will be replaced with the new data.



------------------------------------------------------------------------

When using the FMPAC with 2 games or more read the following page to make sure that you don't erase data from the other games.

------------------------------------------------------------------------



Using the FMPAC with games

When using the FMPAC with 2 or more games

One FMPAC can save up to 8 data but games tahat use rooms which overlap with each other cannot be used together.

For example game A uses room 2 for it's data and another game B uses room 4 and 5 to save its data then since rooms 2 4 and 5 are used theese games can use the same FMPAC and another game C must use rooms 1 and 2

the data in room 2 from game A



Use with games that have the music mark

Using the FMPAC with games having the MSX-MUSIC mark will have great sounds and exiting music!!



When you play games on your computer, you notice that the games have neat sounds and music. Theese sounds are made by the build in sound functions in your computer called PSG sounds. The FM sound function that are in your FMPAC sounds mo



If the volume of the PSG sounds and the FMPAC sounds do not match up, use the volume control switch on the FMPAC to adjust the volume.



Move the switch to the left to lower the FM sound volume

Move the switch to the right to increase the FM volume





Volume selection switch




Turn off the switch before adjusting, Set the volume switch where it clicks into place.



Build in software (PAC commander)

The magical PAC commander



the PAC commander has 6 spells that it can use

Clear This is used to erase data saved with the FMPAC or other PAC's Copy This is used to copy data to another PAC or to a Floppy disk You can use it to also do the opposite, to copy data from a Floppy disk to a PAC

Change This is used to switch data on two different PAC's Delete File is used to erase a file data saved onto a floppy disk from a PAC

Slot This is used to check which slot the FMPAC has been installed into

BGM This is used to change or stop the background music that is playing when using the PAC commander.



Build in software (PAC commander)

Starting the commander



1. Make sure the power of the computer is turned off

2. Insert the FMPAC into a slot



If you are going to be using 2 PAC's to copy or change, Insert both PAC's first.



Don't insert cartridges other tham FMPAC's or PAC's !!



3. Turn ON the power on the computer

When the power is turned on and the build in software screen is displayed start up BASIC



4. When the Initial BASIC screen is showm enter the following at the keyboard. CALL FMPAC and press enter

BASIC Initial screen



5. this screen tells you that the PAC commander is active.



When using the PAC commander, do not use the pause key or the control key functions.



Build in software (PAC commander)

Ending the PAC commander



To end the PAC commander use the following steps

1. Make sure the screen is the same as the bottom pictures in the previous page (The Menu Screen)



If there is a message displayed on the screen, press wither the space or the ESC key to erase the message.



2. Turn off the power on the computer.



If you are not going to use the FMPAC right away, remove it from the slot.



Build in software (PAC commander)

Using the PAC commander



The PAC commander is very simple to use. All you have to do is press the keys described below to cast it's spells.



Keys for the PAC commander



(^) (v) (cursor keys) Used to choose which spell to cast and what to cast the spell on.

(Space bar) Used to tell the PAC commander to carry out your orders.

(ESC) Used to tall the PAC commander that you have made a mistake and you want to cancel your order.



BASIC use



Cursor on



CLEAR

COPY

CHANGE

DELETE FILE

SLOT

BGM



Lets say that what is shown above is the PAC commander screen. We will call this the spell screen. Use the cursor keys to move the green color bar up and down to choose which spell you wish to cast. Press the Spacebar when the cursor is at



Build in software (PAC commander)



The sub-menu and messages



According to what spell you choose sometimes the spell will not be cast imediatley, but another sub-menu like 1 and 2 will be shown on the screen.



1. PAC -> PAC

PAC -> FLOPPY

FLOPPY -> PAC



2. YES

NO



Like the spell menu, the items on the sub-menu is selected by using the cirsor keys and pressing the Spacebar will carry out your choice.

Pressing the ESC key will clear the sub-menu screen

3. this spell requires another PAC

is what MSX said

3 is called a message. The messages are shown while thr spells are being cast and messages will be erased when you press the spacebar and the ESC

key.



Messages give you important information so make sure to read them!



Build in software (PAC commander)

Checking the slot number



When using the PAC commander. MSX will tell you that the FMPAC is in slot 1 or slot 2. But sometimes the slot being used will not be compatible with the computer being used. When first using the PAC

commander, use the spell as sh



Now lets explain the 6 spells



It's in slot 2 but something's not right

The PAC is in slot 1 ??



whats wrong ??



is your computer allright.



Build in software (PAC commander) / Clear

Spell 1 (CLEAR)



The clear spell is a terrible spell that clears all data that has been saved in the PAC. Use this spell carefully.



1. Set the cursor to CLEAR on the spell menu and press the spacebar 2. the following 2 menu's will appear on the screen

The passwords and data in slot 2 YES

will be erased. Are you sure NO



says MSX



The number 1 will change according to what slot the PAC is in.



if there is more than 1 PAC installed the following will be shown

Which PAC to clear.



FMPAC 1

PAC 2



Move the cirsor to the one you want to clear.



Build in software (PAC commander) / Clear

3 Make sure you have choosen the right slot and PAC then press the Spacebar



If the PAC is not correct, press either the ESC key or move the cirsor to NO and press the Spacebar.



4. The following message will be shown on the screen

MSX has cast the CLEAR spell CL-CL-CL-Clear

5 Press the spacebar and the message will be erased and you will return to the spell menu.



Build in software (PAC commander) / Copy

Spell 2 (COPY)



The copy spell is used to copy data from PAC to PAC and from a PAC and a floppy sik. Copy means to make the same set of data in another place.

This spell can also erase data so be carefull when using it.



First choose the type of copy you want to do.



You will choose what kind of copy you want to do from a submenu but what happens after that will depends on what you choose.



1. Move the cursor on the spell menu to copy and press the spacebar 2. the followint submenu will be shown on the screen

PAC -> PAC From PAC to PAC

PAC -> FLOPPY From a PAC to a floppy disk FLOPPY -> PAC From a floppy disk to a PAC



3. Make your selection by using the cursor keys and press the space bar.



Build in software (PAC commander) / Copy

Be carefull on theese following points when using either PAC -> FLOPPY

spell or FLOPPY -> PAC

If you have more that one PAC installed the computer will ask you which PAC to copy from or which PAC to copy to. Make your selection with the cursor keys and press the spacebar. Otherwise, it will be just the same as when you have only one PAC



If you Choose PAC -> PAC you wont be able to use thsi spell if you have only 1 PAC



1 When you choose thsi type of copy the following message will be shown choose which PAC to copy from and press the spacebar.



FMPAC 1 Pac in slot 1

PAC 2 Pac in slot 2



2 The PAC to copy will be shown and check to see if it's correct then press spacebar.



If you have 3 or more PAC's installed use the cursor keys to select whick PAC to copy to.



Build in software (PAC commander) / Copy

3 The following message will be showm on the screen

The password and data in 1 will be erased are you sure says MSX



if you are sure press the spacebar



if you have choosen the wrong PAC to copy to press either the ESC key or move the cursor to no and press the spacebar. Start over from number 2



4 The following message screen will be shown on the screen telling you the copying has ended. Press the spacebar to erase the message.



MSX casts the COPY spell

C-c-c-c-Copy



Build in software (PAC commander) / Copy

You cannot use this copy spell unless you have a floppy disk drive

1 Insert a formatted (initialized disk into the disk drive you cannot use a brand new floppy disk as it is. Read the computer manual or the disk drive manual to learn how to format a disk.

if you have more than 1 drive connected, insert the disk into drive A

2 Move the cursor to PAC -> Floppy and press the spacebar. The following message will appear on the screen.



Copy to file :________ <- input characters

This message is asking you to give a name to the data, you must give a name to the data whenever you save data to a floppy disk. The data that you named is called a file. If the data does not have any name the computer will not be able to t



3 Press the letter keys and give the data a name. The letters you press will appear on the screen. Your name for the data can have up to 8

letters. You can use all the capital letters an numbers.

If you make a mistake press BS backspace key and enter the letter again.



Build in software (PAC commander) / Copy

4 When you have named the file press the spacebar the following message will be shown on the screen



MSX has cast the Copy spell

C-c-c-c-Copy



when the copying has ended the message will disappear

If you have copied files onto the disk beforem the names of the files will be shown on the screen during step 2



GAME001 1988-10-21 17:30

MYGAME 1988-10-22 19:12

LASTGAME 1988-10-22 22:02



FILE NAME DATE COPIED TIME COPIED



The date and time og the file copied is taken from the computer. If the date and time set on the computer is wrong the date will set to that woring time and date. Read the computer manual to fing out how to set the data and time.



Build in software (PAC commander) / Copy

If the file that you are going to save has the same name as a previous saved file the earlier file will be lost. This is called writing over a file. When there are many files on the disk it is easy to make a mistake and write over an old file. B



Writing over files



1 In step 3 on page 21 pressing the corsor keys will make the cursor to appear on the file list. Move the cirsor to the file that you wish to write over and press the spacebar.



2 The message shown below will appear on the screen

File name

xxxxxxxxxx write over this file

MSX asks



3 Check to see if the file to write over is correct then press the spacebar



If the file is not correct press either the ESC key or move the cursor to no and press the spacebar and start over from step 1 and simply follow the steps above.



Build in software (PAC commander) / Copy

FLOPPY -> PAC copy



You cannot use this type of copy unless you have a disk drive.



1 Place the disk that you wish to copy from into the drive if you have more than 1 drive place it in drive A

2 Moce the cirsor to FLOPPY -> PAC and press the spacebar

3 The list og files on the disk will be shown on the screen and the name of the file that the cursor is currentley at will be displayed

GAME001 1988-09-01 18:05

GAME002 1988-09-10 17:10

GAME003 1988-09-05 22.20



CURSOR FILE TO COPY FROM GAME001 <- Character cursor.



Build in software (PAC commander) / Copy

4 Move the cirsor to the file you want to copy and press the spacebar

5 the following message will be shown on the screen The slot the PAC is in



The password and data in 1 will be erased are you sure asks MSX



6 If the PAC to copy to is correct press the spacebar

If you have the worng PAC selected, press either the ESC key or move the cursor to NO and press spacebar and start over

7 The following message will be shown

MSX has cast the Copy spell

C-c-c-c-Copy



When the copying has ended the message will be erased and you will return to the spell menu



The list of files is the same as PAC -> FLOPPY look at page 22 for the explanation.



Build in software (PAC commander) / Change

Spell 3 (CHANGE)



Change is a powerfull spell that will exchange (swap) the contents of 2

pac's in less than a moment. If you use this spell carelessly you will loose track of what data is in which PAC so be carefull, if you have many PAC's it's a good idea n



This Spel can be used only if you have 2 PAC's inserted in the slots if you have only 1 PAC installed, turn OFF the power of the computer and then insert the other PAC.



1 Move the cursor on the spell menu to Change and press the spacebar

2 The following message will be shown on the screen

MSX casts the change spell

CH-ch-ch-Change



3 Press the spacebar to clear the message You have just changed the data



Build in software (PAC commander) / Delete file

Spell 4 (DELETE FILE)



The delete file spell is used to erase files on a floppy disk. Use thsi to remove unvanted files on a disk. Make sure you don't erase the wrong file.



This spell cannot be used unless you have a disk drive.



1 Insert the disk with the unvanted files into the disk drive if you have more than 1 drive insert the disk in drive A

2 Move the cursor to Delete file on the spell menu and press the spacebar. The files that have been copyed onto the disk before will be listed on the screen. Move the cursor to the file you want to erase and press spacebar.



3 The following message will be shown on the screen

FILE name



xxxxxxxx delete this file

asks MSX



Build in software (PAC commander) / Delete file

4 Make sure the file shown in the message shows the correct file and press the spacebar. The file you have choosen will be erased and the following message will be displayed

MSX has cast the DELETE file spell

DE-de-de-Delete



If you change your mind about the file to delete press the ESC key to cancel or move the cursor to NO and press the spacebar and start over from step 2



check to see if you have the right file name.



Build in software (PAC commander) / Slot

Spell 5 (SLOT)



This spell is used to find out what slot a PAC is in. It is used to check to see if the slot of the PAC commander matches the slot of the computer.



This spell can be used only if 1 PAC is installed. If you have other PAC's installed, turn off the power and remove the ther PAC's

1 Move the cirsor to slot on the spell menu and press spacebar. The following message will be displayed on the screen.



MSX has cast thew slot spell. PAC is in slot 1 write this down says MSX



2 After you have written down the slot number press either the spacebar or the ESC key to clear the message.



This number may be different from the slot number on the computer so write the number down or paste the number next to the slot for reference when using the FMPAC



The PAC commander will use this number so note this down

Build in software (PAC commander) / BGM



Spell 6 (BGM)



This spell is used to change or stop the BGM = Back ground music playing when using the PAC commander



1 Move the cursor to BGM on the spell and press the spacebar. The following sub-menu will be shown

SAMPLE 1

SAMPLE 2

SAMPLE 3

SAMPLE 4

SAMPLE 5

STOP



2 Move the cursor to the song that you want to hear and press the spacebar. The spell will be cast immediatley

If the power switch is turned OFF the music selection will automatically be set to music 1

Use the volume control on the television to adjust the music volume.



What to do when you see error messages

While using the PAC commander, you may see the following messages printed in yellow. These are called error messages and they tell you that something is wrong with your selections. If any of theese messages should appear try one of thr f



If the trouble occeur with the drive name, format or write protect check with the either the computer or the disk drive manual.



Oh-oh the disk is write protected

try again



The write protect tab on the floppy disk is set to the protect position.

Remove the disk from the drive and set the tab to non protected position so that the hole in the disk cannot be seen.



There is no disk in the drive

try again



You must have the disk in drive A . It will not work even if the disk is placed in drive B or C.



The disk in the drive may not be formatted. You must format a disk before using it.



Cannot find the file

says MSX



The file name could be wrong. Check the file name with the list of files.



When error messages appear

This disk cannot be used with MSX computers try again



This disk is broken

try again



Have you put in a disk from a different computer by mistake??. The disk to use must be formatted initialized on your type of computer. If thsi message appear even if you have done so, then that disk may be broken so try another disk.



This spell requires another floppy or PAC to work says MSX



Turn off the power and connect the disk drive or insert another PAC and try again.



This spell requires a floppy

says MSX



Turn oof the power on the computer and attach the disk drive and try again.



When error messages appear

This spell requires another PAC

says MSX



Turn off the power and insert another PAC and try again

There are 2 PAC installed, turn OFF the power, remove one of the PAC's and try again



Turn off the power and leave 1 FMPAC installed and try again

Not enough room on the disk

says MSX



The disk has become full. Deletesome unvanted files or use another disk.



The file type seems strange

says MSX



Files that have been saved by other means cannot be used. Always files that have been saved using the PAC format copy.



Not enough memory



The FMPAC requires at least 32K ram to work (data area) If this message occurs even if you have over 32Kof memeory, disconnect any thing that you have attached to the computer (disk drives etc.) and try again.



FM sound extended BASIC



MSX-MUSIC



The FM sound extended BASIC, MSX-MUSIC is made so that you can use the FM sounds in the FMPAC with your program an commands. Using MSX-MUSIC to produce sounds will allow you to create beautiful sounds not possible with the PSG.



If you have never composed music using BASIC before, reading the BASIC

manual on the play command will give you a understanding on creating music.



There is a semilar extension of BASIC call MSX-AUDIO but they are a little different so take care not to mix them up.



FM sound extended BASIC



MSX-MUSIC



MSX-MUSIC commands



Reading the instructions



The commands will be explained as the example below.



Example:



Command: MUSIC ------ command name



Operation ( what the command does)



Format: ( how the command is used

CALL MUSIC [(<MODE>[, ...])]



Sample (example)



Notes (notes on the command)



In the format of the command, the following symbols are used. The symbols are not to be entered but mean the following.



[ ] --- characters and symbols within the bracket are optional < > --- characters within theese must be entered in thsi position "..." - characters that are repeated.



FM sound extended BASIC



MSX-MUSIC



Command: MUSIC



Operation: Starts up MSX-MUSIX and determines how the channels are to be divided and used. This command us used first.



Format: CALL MUSIC [(<MODE>[,0[,<n1>[,<n2>[,......[,<n9>]]]]]]]]]])]



Modes may be 1 or 2

1 selects rhythm

The total number when adding n1-n9 must be 9 or less in mode 0

and 6 or less in mode 1 (n1-n2 specifies the number of channels used.



Sample: CALL MUSIC

3 channels are given different melodies to play and 3 other channels are prepeared to play rhythm [same as CALL MUSIC(1,0,1,1,1)]



CALL MUSIC (0,0,1,1,1,1,1,1,1) 9 channels are set to play different melodies ando no channels are set for rhuthm.



Note: n1-n9 are allocated to MML1-MML9 for the PLAY statement.



FM sound extended BASIC



MSX-MUSIC



Command BGM



Operation Specifies to allow other commands to be executed while music is playing



Format: CALL BGM(n) n is 0 or 1 or variable of those values default for MUSIC is 1



Sample: CALL BGM(0) no other command can be executed while music is playing.



CALL BGM(1) commands can be executed while music is playing.



Command PITCH



Operation This sets the pitch of the sounds to be played with the FM

sounds. All sounds will be adjusted to this pitch.



Format: CALL PITCH(n) n can be from 410 to 459 (or a variable) the default value is 440 (standard A)

sample: CALL PITCH(450) Sets the pitch of the sound to be played at 450Hz



FM sound extended BASIC



MSX-MUSIC



Command PLAY



Operations: Music will be played according to the MML settings

Format: Play [#<MODE>,]<MML 1>[,....[,<MML n>[,<MMLm>[,<MMLp1>...[, <MMLp3>]]]]]]]]]]]]

<MODE> can be 0,2,3

<MML1> through <MMLn> are FM sound MML's <MML> numbers are the same as the values for CALL MUSIC

<MML m> is for the rhythm MML

<MML p1> through <MML p3> are for the PSG MML



Sample: Play #2, "CD", "EF", "GA"



Notes: If <MODE> is set to 0 or not set, PSG will be played only MML p1-3 can be used if <MODE> is set to either 2 or 3 both FM and PSG can be used MML 1-2 are set according to the MUSIC command as notes from the starting order. However if a mode that does not use the rhythm channels is specified, the rhythm channels must be omitted.



Function: PLAY



Operation: This detimes if music is being played and returns the result as a value.



Format: CALL PLAY (n,x) n is the channel to check x is the name of the variable to store the value in.



Sample: CALL PLAY(0,A):PRINT A



When n=0 if any channels are playing, the value -1

will be stored in A and 0 if no channels are playing.



FM sound extended BASIC



MSX-MUSIC



Command STOPM



Operation: Stop play of BGM



Format: CALL STOPM



Sample: CALL STOPM



Command TEMPER (temperament)



Operation This sets the rhythm for the FM sound

Format: CALL TEMPER (n) n can be from 0 to 21 or a variable default value is 9



Sample: CALL TEMPER (0)



Notes: for a list of rhythms that can be set and their vlaues, see page 45 "Table of Rhythms.



Command TRANSPOSE



Operation: Will tranpose in units of half tones 1/100 units

Format: CALL TRANSPOSE (n)

n can have values from -12799 to 12799 or a variable However, some voices have a limited setting even through within the +-12799 range Default setting is 0



Sample: CALL TRANSPOSE (100) tranposes a half tone.



FM sound extended BASIC



MSX-MUSIC



Command VOICE



Operation: Stes what instrument <Voice> is to be played by the FM

sound channels. However, values without * mark and array values (refer to page 44 are limited to 2 when used together.



Format: CALL VOICE ([@n1], [@n2], .... [@n9]

n1-n9 can be values from 0-63 (voice nr) or variables

default setting is @0



Note: The voice number canbe selected from the table on page 44's Table of voices numbers.



Command VOICE COPY



Operation: This command copies the voice data to number 63 or an array variable.



Format: CALL VOICE COPY (@n1, -n2)

n1 can be voices from 0-63 that have no * mark or array variables.

n2 can be 63 or an array variable name.



Sample: DIM A%(16)

CALL VOICE COPY (@7,A%) pipe organ 1 is copied to array variable A.



Note: choose the voice from the table on page 44.



Sample Program

Here is an example using the MSX-MUSIC. The first 8 measures of the song Flower is shown below. Refer to thsi song and the MML table and enter your favorite song to be played with FM sounds.



MML Table



This is a table of the MML (music macro language) that can be used with the PLAY command.



Music MML



Statement Meaning Range Default Value *1



Mn Envelope cycle setting *2 1>=n<=65535 m255

Sn Envelope shape *2 0<=n<=15 S0

Vn Volume 0<=n<=15 V8

Ln Lenght 1<=n<=64 L4

Qn Division of sound lenght 1<=n<=8 Q8

On Octave 1<=n<=8 O4

> Raise 1 Octave - -

< Lower 1 Octave - -

Tn Tempo setting 32<=n<=255 T120

Nn Plays Note raised to n 0<=n<=96 -

Rn Rest setting 1<=n<=64 R4

A-G Note - -

+, # Sharp (raise half tone) - -

- Flat (Lower half tone) - -

(period). Lengthen note or rest by 1.5 - -

XA$ Plays MML stored in string - -

variable A$ *3

=x; sets parameter to x *4 -

& Tie - -

{}n will generate even notes of 1<=n<=64 value set n for the number within with Ln the {}

@n changes the voice set to n 0<=<=63 -

@Vn sets detail change in volume 0<=n<=127 -

@Nn maintain lenght set by n 1<=n<=64 value set with Ln



*1 Initial value set when CALL MUSIC is used *2 For PSG only

*3 Adding MML after [XA$;] will result in error *4 The value range is dertimined by the preceeding MML but it cannot exceed the value 32767



RHYTHM MML



There are 5 different voice that are available for the rhythm (percussion) MML and up to 3 voices may be played simultaneously. For this reason the rhythm MML first lines up the instruments that are to be played simultaneously and the



Statement Meaning Range Default



B Bass drum - -

S Snare drum - -

W Tom tom - -

C Cymbals - -

H Hi Hat - -

n (number) previous notes are played and n th note are rested 1<=n<=64 -

Vn Volume 0<=n<=15 8

! Accents preceeding note -

@An Sets volume for voices that 0<=n<=15 -

are accented.



[Tn], [@Vn], [Rn], [XA$;], [=x;], [.(period)] is the same as music MML



example: PLAY#2,"","","","BSH8H8H8S!H!8H8"



Bass, snare,hihat and wait an 8th note Hi hat and wait an 8th note

snare, hi hat plays accented and waits an 8th note Hi hat and wait an 8Th note



VOICE DATA TABLE



This is a list of the voices available for use with Voice command or the MML @ statement.



Voice No. Name Voice no. Name



0 * Piano 1 32 Piano 3

1 Piano 2 33 * Wood Bass

2 * Violin 34 Santule 2

3 * Flute 1 35 Brass

4 * Clarinet 36 Flute 2

5 * Oboe 37 Clavicord 2

6 * Trumpet 38 Clavicord 3

7 Pipe Organ 39 Koto 2

8 Xylophone 40 Pipe Organ 2

9 * Organ 41 P0hdsPLA

10 * Guitar 42 P0hdsPRA

11 Santule 1 43 Church Organ L

12 * Electric bass 44 Church Organ R

13 Clavicord 1 45 Synth Violin

14 * Hapsicord 46 Synth Organ

15 Hapsicord 47 Synth Brass

16 * Vibraphone 48 * Horn

17 Koto 1 49 Shamisen

18 Taiko 50 Magical

19 Engine 1 51 Fuwawa

20 UFO 52 Wonderflat

21 Synth Bell 53 Hard Rock

22 Chime 54 Machine

23 * Synth Bass 55 Machine V

24 * Synthesizer 56 Comic

25 Synth drum 57 SE comic

26 Synth rhythm 58 SE laser

27 Harmo drum 59 SE noise

28 Cow Bell 60 SE star 1

29 Hi Hat 61 SE star 2

30 Snare drum 62 Engine 2

32 Bass drum 63 no sound



* The name of the voice are given for reference only and they may not sound the same as the real instruments

* Are sounds that are build in the FM sound chip and sounds without an * indicates sounds generated by software.



RHYTHM TABLE



Table of Rhythm usable with the TEMPER statement

No. Rhythm



0 Pythograph

1 Mintone

2 Welkmeyster

3 Welkmeyster (adjusted)

4 Welkmeyster (seperate)

5 Kilanbuger

6 Kilanbuger (adjusted)

7 Velotte Young

8 Lamour

9 Perfect Rhythm (default)

10 Pure Rhythm c major (a minor)

11 Pure Rhythm cis major (b minor)

12 Pure Rhythm d major (h minor)

13 Pure Rhythm es major (c minor)

14 Pure Rhythm e major (cis minor)

15 Pure Rhythm f major (d minor)

16 Pure Rhythm fis major (es minor) 17 Pure Rhythm g major (e minor)

18 Pure Rhythm gis major (f minor)

19 Pure Rhythm a major (fis minor)

20 Pure Rhythm b minor (g minor)

21 Pure Rhythm h minor (gis minor)



Specifications

Item: Description



Machine: MSX, MSX2 personal Computers 32K byte of Ram

Conditions: Temperature 10'C-35'C



Humidity: 20%-80% without condensation

Battery life: 5 years approx



Dimensions: 210 X 1008 X 17 mm



Weight: (g) 140 (g) approx



FM sound: 2 operator FM sound generation

S-RAM: MSX game specific 8 segment S-RAM

RAM capicity 8Kbytes (64K bit) back up battery function to preserve data

BUILD in SOFT: Clear

Copy

PAC->PAC, PAC->FLOPPY, FLOPPY->PAC

Delete file

Slot

BGM

5 Sample Songs stop

Trouble Shooting

Check out theese items once more. If it doesn't work again then take the FMPAC to the store that it was purchased from and ask the clerk for advice.



Is the FMPAC plugged into the Slot firmly?



Is it in the correct Slot?



Try another slot and try again



Are you following the instructions??



Turn OFF the computer and remove the FMPAC then try again from the start

If the data are destroyed or Changed

The content of the FMPAC S-RAM operates with the build in battery. The expected battery life time is 5 yesrs but something may go wrong with the battery. If data is lost or seems to be strange, consult the store that you purchased the FMPAC f



General Care

If the FMPAC should become soiled, clean it in the following manner:

Wipe the case gentley with a soft cloth, if a rough cloth is used or it is wiped roughly you will damage the case.



If the case i heavely soiled, use a little dishwashing liquid, If the case does not become clean by gentley wiping, use a tiny bit of dishwashing liquid on a soft cloth an wipe the case clean with it.

Always wipe the liquid off with a soft cotton cloth after cleaning with dishwashing liquid.



<HANDY MEMO> Writing the following down.



DATE of PURCHASE .................................



Model number .................................



Place PURCHASED ................................. TLF ..............



Service Center ................................. TLF ..............





MSXtra


Monitor / debugger for MSX MSX-TRA is a disassembler/debugger, with it's own working memory. You can call it from basic with CALL MSXTRA or during boot time by holding CTRL +

STOP pressed.



MSX-TRA can prove to be very useful when your program contains a bug which makes the system hang completely. Just hit the reset button and hold CTRL+STOP pressed until you are in MSXTRA. Then you can start disassembling the program and check the memory contents. Since MSXTRA contains its own RAM, the debugger will not overwrite any byte of your program's memory.



(Short description found on http://www.msx.org/forum/msx-talk/hardware/msxtra)



The complete manuals can be found here:





Original dutch manual

English translation (automated, draft)





MSX2 TECHNICAL HANDBOOK

-----------------------



Edited by:		ASCII Systems Division Published by:		ASCII Coprporation - JAPAN

First edition:		March 1987

<i>

Text files typed by:	Nestor Soriano (Konami Man) - SPAIN

March 1997



Changes from the original:



none

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-





CHAPTER 1 - MSX SYSTEM OVERVIEW




The MSX2 was designed to be fully compatible with the MSX1, but there are many enhanced features in the MSX2. Chapter 1 introduces the enhanced features of the MSX2, and shows block figures and standard tables. This information is conceptual, but will be needed to understand dexcriptions in volume 2 and later.



1. FROM MSX1 TO MSX2



To begin with, let us took back to the original purpose or intention of MSX

and then sum up the transition from MSX1 to MSX2.



1.1 What is MSX?



MSX was announced as a new 8-bit computer standard in the autumn of 1983. In early days the word "compatibility" was not understood correctly and there were misunderstandings that MSX could execute programs from other computers.

Since MSX can execute programs only for MSX, it was said that were was no difference from the PC series (NEC) or FM series (Fujitsu) personal computers, which could only execute programs using their format.



Several years passed before personal computers became popular. In the early days only dedicated enthousiasts bought computers, which were difficult to use, and, needless to say, incompatible. They were satisfied to tinker with the computer and study it. But now computer use has expanded to include several classes of users. In other words, the personal computer is becoming a commodity item such as televisions or radio cassette recorders. Therefore, "compatibility" is coming to be a problem. If each TV station needs a different television set or if each radio cassette recorder needs a different tape, do you suppose they would be popular? Software or programs of the computer as a home electric product must be compatible.



The design team for MSX considered these problems. Since a computer is most powerful when left flexible and easy to expand, a "final" standard format was not practical. There are too many matters to define and hardware in constantly improving. Therefore MSX started with fixing format of the most fundamental harware and software such as DOS and BASIC, and the hardware bus which is the basis for expansion. Since the computer is used by itself and does not interact with other computers, the problem is small. But formats must be fixed if the computer is to be connected to "peripherals" and handle or accumulate various data. Fortunately MSX had the approval of many home appliance electric companies and an MSX format was established early. This allowed the system to be well known so that several manufacturers could make compatible peripherals for the MSX standard.



Some of the useful features included in the MSX system include the use of double precision BCD for normal BASIC arithmetic and the same file format as MS-DOS. The real capabilities of the MSX machine will come to light as it is used across several fields.



1.2 Environment of the MSX



Over one million MSX machines had been sold by December 1985 and are used mainly as game machines or primers by primary and junior high school students. But MSX use has gradually spread to include such uses as communication terminals, Japanese word processing, factory automation, and audio visual control. For improving its capabilities, a disk system and MSX-DOS have been prepared, and languages such as C, FORTH, and LOGO are available. BIOS, which is the collection of input/output routines in BASIC

ROM, and BDOS, which resides in the disk interface ROM and has compatibility with CP/M system calls have both been improved. So an excellent programming environment is now available. Chinese Character input, light pen and mouse input, and the RS-232C interface have been standardised, and stantardisation of other peripherals is proceeding. The keyboard and character set are consistent with international standards, and there are minor variations to satisfy the needs of individual countries.



Several new peripherals have been developed. Standard devices include printers, disk drives, and mice; audio/visual devices include laser drives, VTRs, synthesizer controllers, and video acquisition systems. Factory Automation devices include robot controllers, room temperature controllers, various adaptors for modem and telephone lines, and a health controller combined with a hemadynamometer has been developed. So you can see that the potential uses for MSX computers has really grown.



Many applications other than games are now supplied on disks and are becoming more practical. There are now Japanese word processors capable of clause transformation, data bases which can exchange data with higher-level systems, and CAI and CAD systems.



1.3 Extended Contents of MSX2



MSX2 was announced in May 1985 as a system having upgraded compatibility with MSX. Programs created under the MSX environment can be executed on MSX2

without any modifications, even at the assembly language level. Data and programs stored on cassette tapes or disks can be used without modification.

Features added by the MSX2 system are improved screen display, higher resolution, more colours available, and higher graphics speed. A battery-powered clock and RAMDISK feature have also been added. In this manual the name MSX2 refers to the computer made along the MSX2 standard and the name MSX1 refers to the computer made along the previous MSX standard.



System configuration is shown in Figures 1.1 and 1.2 and Table 1.1 and indicate the differences between MSX1 and MSX2. The differences are described as follows:



Table 1.1 MSX2/MSX1 standard comparison

MSX2	 |	 MSX1

-------------------------------+---------------------------

CPU		| Z80A or equivalent (clock 3.579545 MHz +- 1%)	 |

|------------------------------+--------------------------|

| 48K (MSX-BASIC version 2.0) | 32K (MSX-BASIC ver 1.0) |

ROM	| MAIN-ROM 32K	 | MAIN-ROM 32K	 |

| SUB-ROM	16K	 |			 |

MEMORY	 RAM	| 64K or more		 | 8K or more		 |

VRAM	| 64K or 128K		 | 16K			 |

|------------------------------+--------------------------|

LSI for VDP	| V-9938 (MSX-VIDEO)	 | TMS9918 or equivalent |

|---------------------------------------------------------|

CMT		|		 FSK 1200/2400 baud			 |

|---------------------------------------------------------|

PSG		| 8 octaves tri-chord output (AY-3-8910 compatible)	 |

|---------------------------------------------------------|

Keyboard	| Alphanumeric		 | Alphanumeric		 |

| Graphic symbols	 | Graphic symbols	 |

|---------------------------------------------------------|

Floppy disk (*) |		 Based on MS-DOS format 		 |

|---------------------------------------------------------|

Printer 	| 8-bit parallel	 | (*)			 |

|---------------------------------------------------------|

ROM cartridge	|			 I/O bus			 |

| with slot for game cartridge and expansion bus	 |

|---------------------------------------------------------|

Joystick	|	 2	 | 1 or 2 (*)		 |

|------------------------------+--------------------------|

CLOCK-IC	| Standard		 | (*)			 |

|------------------------------+--------------------------|

RAM disk	| Standard		 | Different for 	 |

feature 	|			 | each maker		 |

-----------------------------------------------------------



(*) Optional

Figure 1.1 MSX2 system configuration

1. Minimum configuration



Sound I/O <--+	Video I/O Printer I/O Cartridge Slot x 1

|	 ^		 ^	 |

|	 |		 |	 |

|	 -----------------------------+---------

|	 |			 | |

+-- | Z80A 		 V |

|			 ---- |

| ROM 48K		 |	| |

|			 |	| |

Joystick x 2 --> | RAM 64K		 |	| |

|			 |	| |

| VDP(V9938) VRAM 64K	 ---- |

|				 |

| PPI	 PSG			 |

|				 |

------------	 |	----------------	 |

| Cassette | --> |	| Keyboard |	 |

------------	 ---------------------------------------



2. Software support range	 -- Lightpen, Superimpose, Video |			 digitize Sound I/O <--+	Video I/O Printer I/O | Cartridge Slot x 3

|	 ^		 ^	| |

|	 |		 |	| |

|	 -----------------------------+---------

|	 |			 +----+----+ |

+-- | Z80A 		 V V V |::::::::::::::::::::: |			---- ---- ---- +:---- ---- ---- ----: | ROM 48K		| | |	| | | | | | | | | | | |: |			| | |	| | | | | | | | | | | |: Joystick x 2 --> | RAM 64K		| | |	| | | | | | | | | | | |: |			| | |	| | | | | | | | | | | |: Trackball,	 | VDP(V9938) VRAM 128K ---- ---- ---- +:---- ---- ---- ----: mouse, etc	 |				 |::::::::::::::::::::: | PPI	 PSG			 |

|				 | Extended Cartridge ------------	 |	----------------	 | Slot x 4

| Cassette | --> |	| Keyboard |	 |

------------	 ---------------------------------------



Figure 1.2 MSX1 system configuration

1. Minimum configuration



Sound I/O <--+	Video I/O		 Cartridge Slot x 1

|	 ^			 |

|	 |			 |

|	 -----------------------------+---------

|	 |			 | |

+-- | Z80A 		 V |

|			 ---- |

| ROM 32K		 |	| |

|			 |	| |

Joystick x 1 --> | RAM 8K		 |	| |

|			 |	| |

| VDP(TMS9918) VRAM 16K ---- |

|				 |

| PPI	 PSG			 |

|				 |

------------	 |	----------------	 |

| Cassette | --> |	| Keyboard |	 |

------------	 ---------------------------------------



2. Software support range



Sound I/O <--+	Video I/O Printer I/O Cartridge Slot x 3

|	 ^		 ^	 |

|	 |		 |	 |

|	 -----------------------------+---------

|	 |			 +----+----+ |

+-- | Z80A 		 V V V |::::::::::::::::::::: |			---- ---- ---- +:---- ---- ---- ----: | ROM 32K		| | |	| | | | | | | | | | | |: |			| | |	| | | | | | | | | | | |: Joystick x 2 --> | RAM 64K		| | |	| | | | | | | | | | | |: |			| | |	| | | | | | | | | | | |: Trackball,	 | VDP(TMS9918)VRAM 16K ---- ---- ---- +:---- ---- ---- ----: mouse, etc	 |				 |::::::::::::::::::::: | PPI	 PSG			 |

|				 | Extended Cartridge ------------	 |	----------------	 | Slot x 4

| Cassette | --> |	| Keyboard |	 |

------------	 ---------------------------------------



* MSX-BASIC



BASIC has also been extended from version 1.0 to version 2.0 in order to support a new VDP, backup RAM, CLOCK-IC, and so on. Compatibility with MSX1

is maintained. When using the newly extended screen mode, be careful when specifiyng range, since ranges are slightly different in MSX2.



MSX2 has three types of memory, ROM, RAM, VRAM, which are described below.



ROM



Standard ROM size is 48K bytes. The MSX ROM uses only 32K bytes. The extra 16K bytes portion of the MSX2 contains routines supporting the extended features.



The "MAIN-ROM" consists of 32K bytes and contains the BASIC interpreter, and the "extended ROM" or "SUB-ROM" consists of 16K bytes and contains routines for the extended features.



RAM



Standard RAM size is 64K bytes, which is large enough so that MSX-DOS can be executed. The RAM size of MSX1 varied from 8K to 64K bytes, so in some cases large programs could not be executed without expanding RAM. MSX2 does not have this problem.



VRAM



A minimum of 64K bytes are required for VRAM in order to execute the added features of the screen display. VRAM is thus four times larger than in MSX1, which had only 16 K bytes VRAM. But many machines actually use a VRAM size of 128K bytes, which is eight times larger. Machines with 128K bytes VRAM can display 256 colours at the same time.



MSX machines which have 64K bytes VRAM but cannot be expanded to 128K bytes are marked "VRAM64K" on their catalogue or packaging.



* VDP



The MSX series computers use a video display processor (VDP) type LSI chip for controlling the screen output. The VDP used for MSX1 was the TMS9918, but the MSX2 uses the V9938 (MSX-VIDEO), which has upper and full compatibility with the TMS9918 and can execute software for TMS9918 without any modification.



Table 1.2 shows the VDP standard and Table 1.3 shows each screen mode. V9938

is an excellent LSI chip with digitising, superimposing, and hardware scrolling features. Chapter 4 of this manual describes it in detail.



Table 1.2 VDP specifications

V9938	 |	 TMS9918

----------------------------+----------------------

Screen mode		| 10 (see table 1.3)	 |	 4	 |

|---------------------------+---------------------|

Number of dots		| 512 x 212 maximum	 |			 |

(horizontal x		| 424 dots for vertical | 256 x 192 maximum |

vertical)		| can be achieved by	 |			 |

| interlace feature	 |			 |

|---------------------------+---------------------|

Number of	|			 |			 |

colours to	| 512 maximum		 |	16 maximum	 |

specify	|			 |			 |

Colour			|---------------------------+---------------------|

Number of	|			 |			 |

colours to	| 256 maximum		 |	16 maximum	 |

display at	|			 |			 |

the same time |			 |			 |

|-------------------------------------------------|

Character set		|	 alphanumeric + graphic symbols	 |

|	 256 characters 8 x 8 dots	 |

|-------------------------------------------------|

Sprite colour		| 16 maximum per sprite |	1 per sprite	 |

|---------------------------+---------------------|

Palette feature 	| Yes			 |	No		 |

---------------------------------------------------



Table 1.3 V9938 screen mode

Mode		Number of	Dots	 Colours	Palette Sprite characters ---------------------------------------------------------------------------

* Text 1 | 40 x 24 |	 | 2 from 512 | Yes	| No Text 2 | 80 x 24 |	 | 4 from 512 | Yes	| No * Multi-colour| 	 | 64 x 48 | 16 from 512 | Yes	| Mode 1

* Graphic 1 | 32 x 24 |	 | 16 from 512 | Yes	| Mode 1

* Graphic 2 | 	 | 256 x 192 | 16 from 512 | Yes	| Mode 1

Graphic 3 | 	 | 256 x 192 | 16 from 512 | Yes	| Mode 2

Graphic 4 | 	 | 256 x 212 | 16 from 512 | Yes	| Mode 2

Graphic 5 | 	 | 512 x 212 | 4 from 512 | Yes	| Mode 2

Graphic 6 | 	 | 512 x 212 | 16 from 512 | Yes	| Mode 2

Graphic 7 | 	 | 256 x 212 | 256 from 256 | No	| Mode 2

---------------------------------------------------------------------------



(*) Feature modes available from TMS9918 (however, palette feature only from V9938).



* Battery-powered Clock-IC



Battery-powered RAM is connected to the I/O port and is used for storage of setup information and for keeping track of the date and time. Setup information specifies the screen colour and mode at reset. This allows the user to set up the desired environment when the system is booted.



The CLOCK-IC works independently of the main power supply. After being set once new time settings are no longer required.



* RAM Disk Feature



When using BASIC on MSX1 machines which had 64K bytes RAM, only 32K bytes of RAM were used; the other 32K bytes were unused since the BASIC interpreter occupied the address space. On MSX2 machines this unused RAM can be used as a RAMDISK. For users who do not have a disk drive, this feature is very useful when loading or saving BASIC programs temporarily.



2. MSX2 SYSTEM OVERVIEW



This section gives a simple overview of the MSX2 software and hardware systems. To help you understand the concepts, diagrams which would be useful when developping softwarem, such as VRAM map, the I/O map, and the interface standard, are found in the APPENDIX of this manual.



2.1 Hardware overview



First of all, look at the block diagram in Figure 1.3 to understand the hardware configuration of the MSX2 as a whole.



Figure 1.3 MSX2 block diagram

------------

| CPU Z80A |

------------

|

|	----- -------------------------------

+--| |--| ROM 48K (MSX-BASIC ver 2.0) |

|	| | -------------------------------

|	| S | ----------------

|	| |--| MAIN RAM 64K |

|	| L | ----------------

|	| | ::::::::::::::::: ::::::::::::::::: |	| O |::: MEMORY MAPPER :::: RAM 64K to 4M : |	| | ::::::::::::::::: ::::::::::::::::: |	| T | ::::::::::::: |	| |::: CARTRIDGE : I/O Cartridge (Disk, RS-232C) |	| | ::::::::::::: RAM Cartridge |	-----		 ROM Cartridge (Game, Application) |			 Slot Expansion Box, Etc.

|

|	----------------- --- Joystick Input +--| PSG AY-3 8910 |---|

|	----------------- --- Audio Output |

|	:::::::::::::::::::::::: :::::::::::::::::::::::::::::::: |::: MSX-AUDIO (FM sound) :::: Audio Memory Maximum of 256K : |	:::::::::::::::::::::::: :::::::::::::::::::::::::::::::: |

|	----------------------

+--| CASSETTE INTERFACE |::::: Cassette |	----------------------

|

|	---------------------

+--| PRINTER INTERFACE |:::::: Printer |	---------------------

|

|	---------------------------------

+--| BATTERY BACKUP RAM + CLOCK IC |

|	---------------------------------

|

|	-------------		 ------------

+--| PPI 8255A |--------+-----| Keyboard |

|	-------------	 |	 ------------

|			 |	 ---------------

|			 +-----| Slot Holder |

|				 ---------------

-------------

| MSX-VIDEO |----------------------- RGB/Video/RF Output -------------

|

|	------------::::::::::::::::::::::::::: +--| VRAM 64K | VRAM 64K : Expansion RAM : |	------------::::::::::::::::::::::::::: |

|	:::::::::::::::: |--: SUMPERIMPOSE :--------+--- Video Input |	::::::::::::::::	|

|				|

|	::::::::::::		|

+--: DIGITISE :------------+

::::::::::::

Note: The dotted lines represent optional features.



2.1.1 Address map



* Memory map



The MSX2 has three kinds of memory: MAIN-ROM, SUB-ROM, and RAM. Each memory resides in an independent 64K address space and is allocated as shown in Figure 1.4 (1) (each 64K space is called a "slot", which consists of four 16K

areas called "pages"). Figures 1.3 (2) and (3) show memory usage when using BASIC and MSX-DOS, respectively.



For each class of memory, Figure 1.5 shows the memory map of Figure 1.4

(1)(a), Figure 1.6 for Figure 1.4 (1)(b), and Figure 1.7 for Figure 1.4

(1)(c). There is also a VRAM map and I/O map whose standards are defined.

They are found in the APPENDIX.



Figure 1.4 MSX2 standard memory

(1) Physical allocation of standard memories

(a)	 (b) 	 (c) 0000H	------------- ------------- -------------

Page 0	| (1) | | (3) | | (4)	 |

| MAIN-ROM | | SUB-ROM | | RAM	 |

4000H	| - - - - - | |-----------| | - - - - - |

Page 1	| (2) | | not	 | | (5)	 |

| MAIN-ROM | | used | | RAM	 |

8000H	|-----------| | - - - - - | | - - - - - |

Page 2	| not | | not	 | | (6)	 |

| used | | used | | RAM	 |

C000H	| - - - - - | | - - - - - | | - - - - - |

Page 3	| not | | not	 | | (7)	 |

| used | | used | | RAM	 |

------------- ------------- -------------

MAIN-ROM	 SUB-ROM	 64K-RAM

SLOT	 SLOT 	 SLOT



(2) CPU memory space when using BASIC		(3) CPU memory space when using MSX-DOS

0000H	------------- -------------		 -------------

Page 0	| (1) | | (3) |		 |	 (4)	|

| MAIN-ROM | | SUB-ROM |		 |	 RAM	|

4000H	| - - - - - | -------------		 | - - - - - |

Page 1	| (2) |	1 and 3 are		 |	 (5)	|

| MAIN-ROM |	switched		 |	 RAM	|

8000H	|-----------|	under certain		 | - - - - - |

Page 2	| (6) |	circumstances		 |	 (6)	|

| RAM |				 |	 RAM	|

C000H	| - - - - - |				 | - - - - - |

Page 3	| (6) |				 |	 (7)	|

| RAM |				 |	 RAM	|

-------------				 -------------



Note: Four pages (4 to 7) of 64K RAM are not always in the same slot.



Figure 1.5 MAIN-ROM memory map

0000H	--------------

| BIOS |

| Entry |

015CH	|------------|

| Additional |

| BIOS Entry |

017AH	|------------|

| Empty |

01B6H	|------------|

| BASIC |

| Interpreter|

7FFDH	|------------|

| BDOS |

7FFFH	| Entry |

8000H	|------------|

|	 |



Figure 1.6 SUB-ROM memory map

0000h	--------------

| BIOS |

| Entry |

01FDH	|------------|

| SLOT |

| Management |

| Control |

0336H	|------------|

| BASIC |

| Interpreter|

3FFFH	| and BIOS |

--------------



Figure 1.7 MAIN-RAM memory map

0000H	 -------------

|	 |

| RAM Disk |

|	 |

| Area |

|	 |

8000H	 |-----------|

|	 |

| User |

| Area |

|	 |

F380H	 |-----------|

| System |

| Work Area |

FD9AH	 |-----------|

| RAM Hook |

| Area |

FFCAH	 |-----------|

| Expanded |

| BIOS call |

| Entry |

FFCFH	 |-----------|

| Interrupt |

| Control |--> Note: Used for the disk | Hook Area |		and RS-232 interface FFD9H	 |-----------|

| Interrupt |

| Control |--> Note: Used for the RS-232

| Program |		interface | Area |

FFE7H	 |-----------|

| New VDP |

| Register |

| Subroutine|

| Area |

FFF7H	 |-----------|

| Main ROM |

| Slot |

| Address |

FFF8H	 |-----------|

| Reserved |

FFFCH	 |-----------|

| Slot |

| Selection |

FFFFH	 | Register |

-------------



2.1.2 Interfacing with peripherals

MSX2 interfacing with peripherals is standarised in detail.



The following is a list of standarised interfaces:

- Display interface

- Audio interface

- Cassette interface

- General-purpose input/output interface - Printer interface



The printer interface was optional on the MSX1 but is standard on the MSX2.



The disk drive interface is still an option but may be considered part of the standard specification because the MSX2 has 64K bytes of RAM.



For detailed information about the cartridge specifications, see the appendix.



2.2 Software Overview



The MSX has two software environments: BASIC mode and DOS mode. BASIC mode enables easy development and execution of MSX-BASIC program and is the mode most often used by most users. A major reason why the use of personal computers has grown is that BASIC is easy to use.



The DOS mode enables various languages, utilities, and applications using MSX-DOS. Most programs in DOS can be executed on different machines. The computers automatically compensate for any differences in hardware. This allows the user to use accumulated software resources efficiently. MSX-DOS

uses the same disk format as MS-DOS, which is popular on 16-bit machines. You should also note that software for CP/M, which has a great deal of applications available for 8-bit machines, can be executed only by doing file conversions.



A remarkable point is that BASIC and DOS use the same disk format in the MSX

machines. This enables the sharing of resources. Both are, as shown in figure 1.8, on the united software environment which has BIOS (Basic I/O System) as a common basis. BDOS (Basic Disk Operating System), which is the basis of the disk operation, is also constructed on this BIOS. MSX offers the same programming environment to BASIC and DOS through common BDOS and BIOS.



Figure 1.8 Software hierarchy of MSX1 and MSX2



------------------------------------

|	 o		 |	 |

|	 |		 |	 |

| BASIC | DISK-BASIC	 | MSX-DOS |----+

|	 |		 |	 |	|

|	 |		 |	 |	|

|	 |	 ------------------|	| Interslot Call |	 |	 |	BDOS	 |	|

|----------------------------------|	|

|		BIOS		 |<---+

|/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\|

|	 Hardware		 |

------------------------------------





MSX2 TECHNICAL HANDBOOK

-----------------------



Edited by:		ASCII Systems Division

Published by:		ASCII Coprporation - JAPAN

First edition:		March 1987



Text files typed by:	Nestor Soriano (Konami Man) - SPAIN

March 1997



Changes from the original:

<i>

- In description of REM statement, [<comment>] field has been added.



- In description of SGN function, "Examines the sign and returns..." has been substitued for "Examines the sign of <expression> and returns..."



- Descriptions for MSX DISK-BASIC statements DSKI$ and DSKO$ have been added.



- Descriptions for new commands on MSX DISK-BASIC version 2 have been added.



- In Table 2.20 (List of intermediate codes), the code "FC" is shown as assigned to "\" as it is actually, and not to "$" as in the original text.



- In List 2.3 (Changing error handling routine), the third line of "command initialize", which is "LD HL,CMDHDAT" in the original, is corrected and substitued by "LD HL,HDAT".



- In section 5, "Notes on Software Development", subsection "BASIC version number", the part "and so on" has been added in point 1.



- In error code list, description of errors 72 to 75 have been added.

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-





CHAPTER 2 - BASIC




The BASIC of MSX2 has been upgraded: the new version is called MSX BASIC

version 2.0. And, when using a disk system, MSX DISK-BASIC can be used, which consists of MSX BASIC version 2.0 and additional instructions for disk operations. The following sections describe these two versions of BASIC.





1. LIST OF INSTRUCTIONS




First of all, the sentence and function for each instruction of BASIC are listed. Each instruction is listed in the format shown in Figure 2.1.



Figure 2.1 Instruction list format

---------------------------------------------------------------

|		 Instruction format		 |

| - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - |

| Instruction type |	 Function or action of instruction |

---------------------------------------------------------------



(a) Syntax of instructions



If there is an "*" followed by a keyword, it indicates that the syntax or function of the instruction has just been modified after version 1.0, or that the instruction has been added to version 2.0.



Descriptions of sentences use the following notational conventions.



* [item] .............. the item is optional * [, item ... ] ....... more items having the same form may appear * [item1 | item2] ..... choose item1 or item2



And <filename>, which is used in the sentence, is a string specifying I/O

devices or files for input/output in the format listed below. <Filename> for a cassette files is a string consisting of any combination of up to 6

characters. <filename> for disk or RAM disk is a string, whose form is "<filename (up to 8 characters)> + <filename extension (up to 3

characters)>". <drive> is one of characters from A to H (depending on the number of drives connected).



"CAS: <filename>" ..... Cassette file "MEM: <filename>" ..... RAM disk "CRT:" ................ Text screen "GRP:" ................ Graphic screen "LPT:" ................ Printer "<drive>:<filename>" .. Disk file

(b) Instruction type



There are four types of instructions:



* Function ............ Returns a certain value depending on the given parameter(s).

* System variable ..... Variables available from BASIC. Generally, assignment is allowed.

* Statement ........... Takes a certain action.

* Command ............. Gives an instruction to BASIC interpreter itself.



(c) Function or action of instruction



The following list gives a brief description of the action for each instruction. More detailed descriptions about instructions which have been modified or added at version 2.0 are given in section 2.



1.1 Instructions of MSX BASIC version 2.0



--- A ---



ABS (<expression>)

Function		Returns absolute value of <expression>.



ASC (<string>)

Function		Returns the code of the first character of <string>.



ATN (<expression>)

Function		Returns arc tangent of <expression> in radians.



AUTO [<linenumber>[, <increment>]]

Command 		Produces line numbers automatically.



--- B ---



* BASE (<expression>)

System variable 	Contains the table address of the screen assigned on VRAM.



BEEP

Statement		Produces beep to the audio terminal.



BIN$ (<expression>)

Function		Converts the value of <expression> to a string of binary expression, then returns its result.



BLOAD "<filename>"[,R[,offset]]

Command 		Loads an assembly language program.



BSAVE "<filename>",<start address>,<end address>[,<execution address>]

Command 		Saves an assembly language program.



--- C ---



CALL <extended statement name>[(<argument>[,<argument>...])]

Statement		Calls the extended statements by inserting various cartridges.



* CALL MEMINI [(<upper limitation of RAM disk>)]

Statement		Specifies the upper limit of memory for Ram disk.



* CALL MFILES

Statement		Lists file names in RAM disk.



* CALL MKILL ("<filename>")

Statement		Deletes a file in RAM disk.



* CALL MNAME ("<old filename>" AS "<new filename>") Statement		Renames a file in RAM disk.



CDBL (<expression>)

Function		Converts the value of <expression> to a double precission real value and returns its result.



CHR$ (<expression>)	Returns a character which has the code of Function		<expression> value.



CINT (<expression>)

Function		Converts the value of <expression> to an integer value and returns its result.



* CIRCLE {(X,Y) | STEP(X,Y)},<radius>[, <colour>[, <start angle>[, <end angle>[, <proportion>]]]]

Statement		Draws a circle whose center is at (X,Y) and whose size depends on <radius>.



CLEAR [<size of string area>[, <upper limitation of memory>]]

Statement		Initialises variables and sets the size of memory area.



CLOAD ["<filename>"]

Command 		Loads a program from cassette.



CLOAD? ["<filename>"]

Command 		Compares a program on cassette with the one in memory.



CLOSE [[#]<filenumber>[, [#]<filenumber>...]]

Command 		Closes a file represented by <filenumber>.



CLS

Statement		Clears screen.



* COLOR [<foreground colour>[, <background colour>[, <border colour>]]]

Statement		Specifies the colours of each part of the screen.



* COLOR [=NEW]

Statement		Initialises the palette.



* COLOR = (<palette number>, <red brightness>, <green brightness>, <blue brightness>) Statement		Sets the palette colour.



* COLOR = RESTORE

Statement		Puts the contents of the colour palette storage table into the palette register.



* COLOR SPRITE (<sprite plane number>)=<colour> Statement		Sets the colour to the sprite of <sprite plane number> to the specified colour.



* COLOR SPRITE$ (<sprite plane number>)=<string expression> Statement		Sets the colour of each horizontal line of the sprite using <string expression>.



CONT

Command 		Resumes the execution of the program which has been stopped.



* COPY <source> TO <destination> Statement		Transfers the screen data among the screen, array, and disk file.



* COPY SCREEN [<mode>]

Statement		Writes colour bus data into VRAM (optional).



COS (<expression>)

Function		Returns the cosine value of <expression (in radians)>.



CSAVE "<filename>"[, <baud rate>]

Command 		Saves a program to cassette.



CSGN (<expression>)

Function		Converts the value of <expression> to a single precision real value, and returns its result.



CSRLIN

System variable 	Contains the vertical screen location of the cursor.

No assignment is allowed.



--- D ---



DATA <constant>[, <constant>...]

Statement		Prepares data to be read by READ statement.



DEF FN <name> [(<argument>[, <argument>...])]=<function-definitive expression>

Statement		Defines a user-defined function.



DEFINT <character range>[, <character range>...]

Statement		Declares the specified variable(s) as integer type.



DEFSNG <character range>[, <character range>...]

Statement		Declares the specified variable(s) as single precision real type.



DEFDBL <character range>[, <character range>...]

Statement		Declares the specified variable(s) as double precision real type.



DEFSTR <character range>[, <character range>...]

Statement		Declares the specified variable(s) as character type.



DEF USR [<number>]=<start address> Statement		Defines the starting address for the execution of assembly language routine, called by USR function.



DELETE {[<start linenumber>-<end linenumber>] | <linenumber> | -<end linenumber>}

Command 		Deletes the specified portion of the program.



DIM <variable name> (<maximum subscript value>[, <maximum subscript value>...])

Statement		Defines an array variable and allocates it into memory.



DRAW <string expression>

Statement		Draws a line or lines on the screen according to <string expression (DRAW macro)>.



--- E ---



END

Statement		Ens the program, close all files, and returns to the command level.



EOF (<filenumber>)

Function		Checks if the file is finished and returns -1 if at the end of file.



ERASE <array variable name>[, <array variable name>...]

Statement		Deletes the array variable(s).



ERL

System variable 	Contains the error code for the preceding error.

No assignment is allowed.



ERR

System variable 	Contains the line number of the previous error.

No assignment is allowed.



ERROR <error code>

Statement		Puts the program into the error condition.



EXP (<expression>)

Function		Returns the exponent (power) of the natural exponential form of <expression>.



--- F ---



FIX (<expression>)

Function		Returns the value of <expression>, without any decimal fractions.



FOR <variable name> = <initial value> TO <end value> [STEP <increment>]

Statement		Repeats the execution from FOR statement to NEXT

statement for the specified times.



FRE ({<expression> | <string expression>}) Function		Returns the size of unused user's area or unused character area.



--- G ---



* GET DATE <string variable name>[, A]

Statement		Assigns date into a string variable.



* GET TIME <string variable name>[, A]

Statement		Assigns time into a string variable.



GOSUB <linenumber>

Statement		Calls the subroutine at <linenumber>.



GOTO <linenumber>

Statement		Jumps to <linenumber>.



--- H ---



HEX$ (<expression>)

Function		Converts the value of <expression> to a string of hexadecimal expression, then returns its result.



--- I ---



IF <condition> THEN {<statement> | <linenumber>} [ELSE {<statement> |

<linenumber>}]

Statement		Judges the condition. If <condition> is not zero, it is true.



IF <condition> GOTO <linenumber> [ELSE {<statement> | <linenumber>}]

Statement		Judges the condition. If <condition> is not zero, it is true.



INKEY$

Function		Returns a character when a key is being pressed, or when not, returns null string.



INP (<port number>)

Function		Reads the port specified by <port number> and returns its result.



INPUT ["<prompt statement>";]<variable name>[, <variable name>...]

Statement		Assigns data input from keyboard into the specified variable(s).



INPUT #<filenumber>, <variable name>[, <variable name>...]

Statement		Reads data from the file and assigns the data into the specified variable(s).



INPUT$ (<number of characters>[, [#]<filenumber>]) Function		Reads the specified size of string from the keyboard or file.



INSTR ([<expression>,]<string expression 1>,<string expression 2>) Function		Searches <string expression 2> from the left of <string expression 1>, and returns its location if found, otherwise zero. <Expression> is the character location to start searching.



INT (<expression>)

Function		Returns the largest integer less than <expression>.



INTERVAL {ON | OFF | STOP}

Statement		Allows, suppresses, or suspends the timer interrupt.



--- K ---



KEY <key number>,<string>

Command 		Redefines a function key.



KEY LIST

Command 		Displays the contents of function keys.



KEY (<key number>){ON | OFF | STOP}

Statement		Allows, supresses, os suspends the function key interrupt.



KEY {ON | OFF}

Statement		Specifies whethter to display the contents of function keys at the bottom of the screen.



--- L ---



LEFT$ (<string expression>,<expression>) function		Gets <expression> characters from the left of <string expression>.



LEN (<string expression>)

Function		Returns the number of characters of <string expression>.



[LET] <variable name> = <expression> Statement		Assigns the value of <expression> to the variable.



* LINE [{(X1,Y1) | STEP(X1,Y1)}] - {(X2,Y2) | STEP(X2,Y2)}[, <colour> [, {B|BF}[, <logical operation>]]]

Statement		Draws a line or a rectangle on the screen.



LINE INPUT ["<prompt statement>";]<string variable name> Statement		Assigns a whole line of string data from the keyboard into the string variable.



LINE INPUT# <filenumber>, <string variable name> Statement		Reads data in lines from the file and assigns the data into the string variable.



LIST [[<linenumber>] - [<linenumber>]]

Command 		Displays the program in memory on the screen.



LLIST [[<linenumber>] - [<linenumber>]]

Command 		Sends the program in memory to the printer.



LOAD "<filename>" [,R]

Command 		Loads a program saved in ASCII format.



* LOCATE [<X-coordinate>[, <Y-coordinate>[, <cursor switch>]]]

Statement		Locates the cursor on the text screen.



LOG (<expression>)

Function		Returns the natural logarithm of <expression>.



LPOS (<expression>)

System variable 	Contains the location of the printer head.

No assignment is allowed.



LPRINT [<expression>[{; | ,}<express]ion>...]

Statement		Outputs characters or numerical values to the printer.



LPRINT USING <form>; <expression>[{; | ,}<expression>...]

Statement		Outputs characters or numerical values through the printer according to <form>.



--- M ---



MAXFILES = <number of files>

Statement		Sets the number of files to be opened.



MERGE "<filename>"

Command 		Merges the program in memory with the program saved in ASCII format (in external storage device).



MID$ (<string expression>, <expression 1>[, <expression 2>]) Function		Returns <expression 2> character(s) starting from the <expression 1>th position of <string expression>.



MID$ (<string variable name>, <expression 1>[, <expression 2>]) = <string expression> Statement		Defines <string expression> using <expression 2> character(s) from the <expression 1>th position of <string variable name>.



MOTOR [{ON | OFF}]

Statement		Turns the motor of cassette ON and OFF.



--- N ---



NEW

Command 		Deletes the program in meory and clears variables.



NEXT [<variable name>[, <variable name>...]]

Statement		Indicates the end of FOR statement.



--- O ---



OCT$ (<expression>)

Function		Converts the value of <expression> to the string of octal expression and returns its result.



ON ERROR GOTO <linenumber>

Statement		Defines the line to begin the error handling routine.



ON <expression> GOSUB <linenumber>[, <linenumber>...]

Statement		Executes the subroutine at <linenumber> according to <expression>.



ON <expression> GOTO <linenumber>[, <linenumber>...]

Statement		Jumps to <linenumber> according to <expression>.



ON INTERVAL = <time> GOSUB <linenumber> Statement		Defines the timer interrupt interval and the line to begin the interrupt handling routine.



ON KEY GOSUB <linenumber>[, <linenumber>...]

Statament		Defines the line to begin the function key interrupt handling routine.



ON SPRITE GOSUB <linenumber>

Statement		Defines the line to begin the piled-sprite interrupt handling routine.



ON STOP GOSUB <linenumber>

Statament		Defines the line to begin the CTRL+STOP key interrupt handling routine.



ON STRING GOSUB <linenumber>[, <linenumber>...]

Statement		Defines the line to begin the trigger button interrupt handling routine.



OPEN "<filename>" [FOR <mode>] AS #<filenumber> Statement		Opens the file in the specified mode.



OUT <port number>,<expression> Statement		Sends data to the output port specified by <port number>.



--- P ---



* PAD (<expression>)

Function		Examines the state of tablet, mouse, light pen, or track ball specified by <expression>, then returns its result.



* PAINT {(X,Y) | STEP(X,Y)}[, <colour>[, <border colour>]]

Statement		Paints the area surrounded by specified <border colour> using <colour>.



PDL (<paddle number>)

Function		Returns the state of the paddle which has the specified number.



PEEK (<address>)

Function		Returns the contents of one byte of the memory specified by <address>.



PLAY <string expression 1>[, <string expression 2>[, <string expression 3>]]

Statement		Plays the music by <string expression (music macro)>.



PLAY (<voice channel>)

Function		Examines whethter the music is being played and returns its result (if in play, -1 is returned).



POINT (X,Y)

Function		Returns the colour of the dot specified by coordinate (X,Y).



POKE <address>,<data>

Statement		Writes one byte of <data> into the memory specified by <address>.



POS (<expression>)

System variable 	Contains the horizontal location of the cursor on the text screen. No assignment is allowed.



* PRESET {(X,Y) | STEP(X,Y)}[, <colour>[, <logical operation>]]

Statement		Erases the dot specified by coordinate (X,Y) on the graphic screen



PRINT [<expression [{; | ,}<expression>...]

Statement		Displays characters of numbers on the screen.



PRINT USING <form>; <expression>[{; | ,}<expression>...]

Statement		Displays characters or numbers on the screen according to <form>.



PRINT #<filenumber>, [<expression>[{; | ,}<expression>...]]

Statement		Writes characters or numbers to the file specified by <file number>.



PRINT #<filenumber>, USING <form>; <expression>[{; | ,}<expression>...]

Statement		Writes characters or numbers to the file specified by <file number> according to <form>.



PSET {(X,Y) | STEP(X,Y)}[, <colour>[, <logical operation>]]

Statement		Draws the dot in the coordinate specified by (X,Y) on the graphic screen.



* PUT KANJI [(X,Y)],<JIS kanji code>[, <colour>[, <logical operation> [, <mode>]]]

Statement		Displays the kanji on the screen (KANJI ROM is required).



* PUT SPRITE <sprite plane number>[, {(X,Y) | STEP(X,Y)}[, <colour>[, <sprite pattern number>]]]

Statement		Displays the sprite pattern.



--- R ---



READ <variable name>[, <variable name>...]

Statement		Reads data from DATA statement(s) and assigns the data to the variable(s).



REM [<comment>]

Statement		Puts the comment in the program.



RENUM [<new linenumber>[, <old linenumber>[, <increment>]]]

Command 		Renumbers the line numbers.



RESTORE [<linenumber>]

Statement		Specifies the line to begin reading DATA by READ

statement.



RESUME {[0] | NEXT | <linenumber>}

Statement		Ends the error recovery routine and resumes execution of the program.



RETURN [<linenumber>]

Statement		Returns from a subroutine.



RIGHT$ (<string expression>, <expression>) Function		Gets <expression> characters from the right of <string expression>.



RND [(<expression>)]

Function		Returns a random number between 0 and 1.



RUN [<linenumber>]

Command 		Executes the program from <linenumber>.



--- S ---



SAVE "<filename>"

Command 		Saves the program in ASCII format.



* SCREEN <screen mode>[, <sprite size>[, <key click switch>[, <cassette baud rate>[, <printer option>[, <interlace mode>]]]]]

Statement		Sets the screen mode and so on.



* SET ADJUST (<X-coordinate offset>, <Y-coordinate offset>) statement		Changes the display location of the screen. Ranges from -7 to 8.



* SET BEEP <timbre>, <volume> Statement		Selects the BEEP tone. Ranges from 1 to 4.



* SET DATE <strign expression>[, A]

Statement		Sets a date. "A" is the specification of alarm.



* SET PAGE <display page>, <active page> Statement		Specifies the page to display and the page to read and write data to.



* SET PASSWORD <string expression> Statement		Sets a password.



* SET PROMPT <string expression> Statement		Sets a prompt (up to 8 characters).



* SET SCREEN

Statement		Reserves the parameters of the current settings of SCREEN statement.



* SET TIME <string expression>[, A]

Statement		Sets time. "A" is the alarm specification.



* SET VIDEO [<mode>[, <Ym>[, <CB>[, <sync>[, <voice>[, <video input>[, <AV

control>]]]]]]]

Statement		Sets superimposing and other modes (optional).



SGN (<expression>)

Function		Examines the sign of <expression> and returns its result (positive=1, zero=0, negative=-1).



SIN (<expression>)

Function		Returns the sine of <expression> in radians.



SOUND <register number>,<data> Statement		Writes data to the register of PSG.



SPACE$ (<expression>)

Function		Returns a string containing <expression> spaces.



SPC (<expression>)

Function		Produces <expression> spaces; used in the instructions of PRINT family.



SPRITE {ON | OFF | STOP}

Statement		Allows, supresses, or suspends the piled-sprite interrupt.



SPRITE$ (<sprite pattern number>) System variable 	Contains the sprite pattern.



SQR (<expression>)

Function		Returns the square root of <expression>.



STICK (<joystick number>)

Function		Examines the direction of the joystick and returns its result.



STOP

Statement		Stops the execution of the program.



STRIG (<joystick number>)

Function		Examines the state of the trigger button and returns its result.



STRIG (<joystick number>) {ON | OFF | STOP}

Statement		Allows, supresses, or suspends interrupts from the trigger button.



STR$ (<expression>)

Function		Converts the value of <expression> to a string decimal expression and returns its result.



STRING$ (<expression 1>, {<string expression> | <expression 2>}

Function		Converts the leading character of <string expression> or the character containing the code <expression 2> to a string whose length is <expression 1>, and returns the string.



SWAP <variable name>, <variable name> Statement		Exchanges the value of two variables.



--- T ---



TAB (<expression>)

Function		Produces the specified spaces in PRINT instructions.



TAN (<expression>)

Function		Returns the tangent of <expression> in radians.



TIME

System variable 	Contains the value of the interval timer.



TRON

Command 		Keeps displaying the line numbers of the program currently being executed.



TROFF

Command 		Cancels TRON and stops displaying the line numbers.



--- U ---



USR [<number](<argument>)

Function		Calls the assembly language routine.



--- V ---



VAL (<string expression>)

Function		Converts <string expression> to a numerical value and returns its result.



VARPTR (<variable name>)

Function		Returns the address containing the variable.



VARPTR (#<filenumber>)

Function		Returns the starting address of the file control block.



* VDP (<register number>)

System variable 	Writes/reads data to/from the VDP registers.



* VPEEK (<address>)

Function		Reads data from <address> in VRAM.



* VPOKE (<address>)

Statement		Writes data to <address> in VRAM.



--- W ---



WAIT <port number>, <expression 1>[, <expression 2>]

Statement		Stops the execution until data of the input port grows to the specified value.



* WIDTH <number>

Statement		Specifies the number of characters per line in the display screen.





1.2 Instructions of MSX DISK-BASIC




Note: Instructions marked with "**" have been added to version 2 of MSX

DISK-BASIC and are not available in version 1.



--- B ---



* BLOAD "<filename>"[{[, R] | [, S]}[, <offset>]]

Command 		Loads the assembly language program or screen data from a file.



* BSAVE "<filename>", <start address>, <end address>[, {<execution address> | S}]

Command 		Saves the assembly language program or screen data in a file.



--- C ---



CLOSE [[#]<filenumber>[, [#]<filenumber>...]]

Statement		Closes the file specified by <filenumber>.



** CALL CHDRV ("<drive name>:")

Command 		Sets the drive specified by <drive name> as the default drive.



** CALL CHDIR ("<directory path>") Command 		Changes to the directory specified by <directory path>.



CALL FORMAT

Command 		Formats the floppy disk.



** CALL MKDIR ("<directory name>") Command 		Creates the directory with the name specified in <directory name> in the current directory.



** CALL RAMDISK (<size in kilobytes>[, <variable name>]) Command 		Tries to crate the DOS 2 RAM disk of the specified size, and returns in the variable (if specified) the actual size of the RAM disk created.



** CALL RMDIR ("<directory name>") Command 		Deletes the directory specified in <directory name>.

If the directory is not empty, "File already exists"

error will be returned.



CALL SYSTEM

Command 		Returns to MSX-DOS.



** CALL SYSTEM [("<filename>")]

Command 		Returns to MSX-DOS and executes the DOS command <filename> if it is specified.



COPY "<filename 1>"[ TO "<filename 2>"]

Command 		Copies the contents of <filename 1> to the file specified by <filename 2>.



CVD (<8-byte string>)

Function		Converts the string to the double precision real value and returns its result.



CVI (<2-byte string>)

Function		Converts the string to the integer value and returns its result.



CVS (<4-byte string>)

Function		Converts the string to the single precision real value and returns its result.



--- D ---



DSKF (<drive number>)

Function		Returns the unused portions of the disk in clusters.



DSKI$ (<drive number>, <sector number>) Function		Reads the specified sector of the specified drive to the memory area indicated by address &HF351, and returns a null string.



DSKO$ (<drive number>, <sector number>) Statement		Writes 512 bytes starting from address indicated by &HF351 to the specified sector of the specified drive.



--- E ---



EOF (<filenumber>)

Function		Checks if the file has ended and returns -1 if at the end of file.



--- F ---



FIELD [#]<filenumber>, <field width> AS <string variable name>[, <field width> AS <string variable name>...]

Statement		Assigns the string variable name to the random input/output buffer.



FILES ["<filename>"]

Command 		Displays the name of the file matched with <filename> on the screen.



** FILES ["<filename>"][,L]

Command 		Displays the name of the file matched with <filename> on the screen, and also the attributes and the size of the file if "L" is specified.



--- G ---



GET[#]<filenumber>[, <record number>]

Statement		Reads one record from the random file to the random input/output buffer.



--- I ---



INPUT #<filenumber>, <variable name>[, <variable name>...]

Statement		Reads data from the file.



INPUT$ (<the number of characters>[, [#]<filenumber>]) Function		Gets the string of the specified length from the file.



--- K ---



KILL "<filename>"

Command 		Delets the file specified by <filename>.



--- L ---



LFILES ["<filename>"]

Command 		Sends the name of the file matched with <filename> to the printer.



** LFILES ["<filename>"][,L]

Command 		Sends the name of the file matched with <filename> to the printer, and also the attributes and the size of the file if "L" is specified.



LINE INPUT #<file number>, <string variable name> Statement		Reads lines of data from the file to the string variable.



LOAD "<filename>"[, R]

Command 		Loads the program into memory.



LOC (<filenumber>)

Function		Returns the record number of the most recently accessed location of the file.



LOF (<filenumber>)

Function		Returns the size of the specified file in bytes.



LSET <string variable name>=<string expression> Statement		Stores data padded on the left in the random input/output buffer.



--- M ---



MAXFILES = <the number of files> Statement		Declares the maximum number of files that can be opened.



MERGE "<filename>"

Command 		Merges the program in memory with the program saved in ASCII format.



MKD$ (<double precision real value>) Function		Converts the double precision real value to the character code corresponding to the internal expression.



MKI$ (<integer value>)

Function		Converts the integer value to the character code corresponding to the internal expression.



MKS$ (<single precision real value>) Function		Converts the single precision real value to the character code corresponding to the internal expression.



--- N ---



NAME "<filename 1>" AS "<filename 2>"

Command 		Renames the name of a file.



--- O ---



OPEN "<filename>"[FOR <mode>] AS #<filenumber>[LEN = <record length>]

Statement		Opens the file.



--- P ---



PRINT #<filenumber>, [<expression>[{; | ,}<expression>...]]

Statement		Sends data to the sequential file.



PRINT #<filenumber>, USING <form>; <expression>[{; | ,}<expression>...]]

Statement		Sends data to the sequential file according to the form.



PUT [#]<filenumber>[, <record number>]

Statement		Sends data of the random input/output buffer to the random file.



--- R ---



RSET <string varibale name>=<string expression> Statement		Stores data padded on the right in the random input/output buffer.



RUN "<filename>"[, R]

Command 		Loads a program from the disk and executes it.



--- S ---



SAVE "<filename>"[, A]

Command 		Saves a program. The program is saved in ASCII format when "A" is specified.



--- V ---



VARPTR (#<filenumber>)

Function		Returns the starting address of the file control block.



2. DIFFERENCES IN MSX BASIC VERSION 2.0



A great deal of functions in MSX BASIC version 2.0 have been added or modified when compared with MSX BASIC version 1.0. They are either the functions that are added or modified with the version-up of VDP (Video Display Processor) or the functions that are added or modified because of the various hardware features such as RAM disk, clock, or memory switch; especially, the alternation of VDP affects, most of the statement for the screen display.



This section picks up these statements and indicates the additions or the modifications. In the following descriptions, "MSX1" means MSX BASIC version 1.0 and "MSX2" for MSX BASIC version 2.0.





2.1 Additions or Modifications to Screen Mode




* SCREEN <screen mode>[, <sprite size>[, <key click switch>[, <cassette baud rate>[, <printer option>[, <interlace mode>]]]]]



<Screen mode> and <interlace mode> have been modified.



<Screen mode> may be specified from 0 to 8. Modes from 0 to 3 are the same as MSX1 and the rest have been added. When specifying a screen mode, in BASIC it is called "SCREEN MODE", which is somewhat different from "screen mode" which is used by VDP internally. Table 2.1 shows these correspondences and meanings. The difference between screen modes 2 and 4 is only in the sprite display functions.



Table 2.1 Correspondances of BASIC screen (SCREEN) modes and VDP screen modess

-----------------------------------------------------------------------------

|	 |	 |			 Meaning		 |

| BASIC | VDP |----------------------------------------------|

| mode | mode |	 Dots or | Display colours | Screen |

|	 |	 |	 characters | at a time	| format |

|--------------+-------------+----------------+-----------------+-----------|

| SCREEN 0 (1) | TEXT 1 |	40 x 24 chars | 2 from 512	| Text	 |

|--------------+-------------+----------------+-----------------+-----------|

| SCREEN 0 (2) | TEXT 2 |	80 x 24 chars | 2 from 512	| Text	 |

|--------------+-------------+----------------+-----------------+-----------|

| SCREEN 1 | GRAPHIC 1 |	32 x 24 chars | 16 from 512	| Text	 |

|--------------+-------------+----------------+-----------------+-----------|

| SCREEN 2 | GRAPHIC 2 | 256 x 192 dots | 16 from 512	| High res. |

|	 |	 |		 | 		| graphics |

|--------------+-------------+----------------+-----------------+-----------|

| SCREEN 3 | MULTICOLOUR |	64 x 48 dots | 16 from 512	| Low res. |

|	 |	 |		 | 		| graphics |

|--------------+-------------+----------------+-----------------+-----------|

| SCREEN 4 | GRAPHIC 3 | 256 x 192 dots | 16 from 512	| High res. |

|	 |	 |		 | 		| graphics |

|--------------+-------------+----------------+-----------------+-----------|

| SCREEN 5 | GRAPHIC 4 | 256 x 212 dots | 16 from 512	| Bit map |

|	 |	 |		 | 		| graphics |

|--------------+-------------+----------------+-----------------+-----------|

| SCREEN 6 | GRAPHIC 5 | 512 x 212 dots | 4 from 512	| Bit map |

|	 |	 |		 | 		| graphics |

|--------------+-------------+----------------+-----------------+-----------|

| SCREEN 7 | GRAPHIC 6 | 512 x 212 dots | 16 from 512	| Bit map |

|	 |	 |		 | 		| graphics |

|--------------+-------------+----------------+-----------------+-----------|

| SCREEN 8 | GRAPHIC 7 | 256 x 212 dots | 256		| Bit map |

|	 |	 |		 | 		| graphics |

-----------------------------------------------------------------------------



Specifying <interlace mode> enables to set the interlace functions of VDP

(see Table 2.2). In the alternate screen display mode, the display page specified in "SET PAGE" must be odd. In this case the display page and the page of which the number is smaller by one is displayed alternately.



Table 2.2 Differences of display function in the interlace mode

-----------------------------------------------------------------

| Interlace mode |		 Display function		|

|------------------+--------------------------------------------|

|	 0	 | Normal non-interlaced display (default)	|

|	 1	 | Interlaced display 			|

|	 2	 | Non interlaced, Even/Odd alternate display |

|	 3	 | Interlaced, Even/Odd alternate display	|

-----------------------------------------------------------------



* SET PAGE <display page>, <active page>

This statement is new. It allows users to set the page to display and the page to read and write data to. This is valid when the screen mode is between 5 and 8, and the value specified depends on the VRAM capacity and the screen mode (see Table 2.3).



Table 2.3 Page values to be specified depending on the screen mode and the VRAM capacity

------------------------------------------

| Screen mode | VRAM 64K | VRAM 128K |

|-------------+------------+-------------|

| SCREEN 5 | 0 to 1 | 0 to 3	 |

| SCREEN 6 | 0 to 1 | 0 to 3	 |

| SCREEN 7 | Unusable | 0 to 1	 |

| SCREEN 8 | Unusable | 0 to 1	 |

------------------------------------------



See the VRAM map in the APPENDIX for the page assignment on VRAM.



2.2 Additions or Modifications for the Colour Specification

* COLOR [<foreground colour>[, <background colour>[, <border colour>]]]



In MSX2, with its colour palette feature, the ranges and meanings of values specifying colours in the screen mode are different (see Table 2.4). The <background colour> except that of the text display changes when the CLS

statement is executed. If the display mode is 0, specification of a <border colour> is ignored.



The "border colour" in screen mode 6 has special meanings. Figure 2.2 shows the bitwise meanings of <border colour> in the mode. In this mode, by changing the flag (bit 4), the colour of vertical lines at odd X-coordinates and the colour of those at even coordinates can be specified differently.



When the flag is 0 (the value of border colour is one of the values from 0 to 15), different colours cannot be specified and the border colour is set as the colour of vertical odd lines. When the flag is 1 (the value of border colour is one of the values from 16 to 31), the border colours are set as the colour of vertical odd lines and that of vertical even lines; when these two colours are different, the screen shows a vertically-striped pattern.



Figure 2.2 Bitwise meanings for the border colour on screen mode 6



4 	 3	 2 	 1	 0

---------------------------------------------------------------

| flag | colour of even lines |	colour of odd lines |

---------------------------------------------------------------

Bits 7 to 5 are unused



* COLOR = (<palette number>, <red brightness>, <green brightness>, <blue brightness>)

This statement sets the colour of the specified palette. See Table 2.4 for the specification of <palette number>. Note that nothing happens and no error occurs wwhen the screen mode is 8, which has no palette feature. Though palette number 0 is ordinally fixed to a transparent colour (that is, border space is seen transparently), it can be dealt in the same way as other palettes by changing the register of VDP:

VDP(9)=VDP(9) OR &H20	 (when dealing as with other palettes) VDP(9)=VDP(9) AND &HDF	 (when fixing it to a transparent colour)

Table 2.4 Colour specifications for the screen mode.



--------------------------------------------------------

| Screen mode | Colour specification | Range of number |

|-------------+----------------------+-----------------|

| SCREEN 0 | Palette number |	 0 to 15 |

| SCREEN 1 | Palette number |	 0 to 15 |

| SCREEN 2 | Palette number |	 0 to 15 |

| SCREEN 3 | Palette number |	 0 to 15 |

| SCREEN 4 | Palette number |	 0 to 15 |

| SCREEN 5 | Palette number |	 0 to 15 |

| SCREEN 6 | Palette number |	 0 to 3 |

| SCREEN 7 | Palette number |	 0 to 15 |

| SCREEN 8 | Colour number |	 0 to 255 |

--------------------------------------------------------



Brightness of each colour can be set to one of eight steps from 0 to 7 and combinig them enables to display 512 colours; 8 (red) x 8 (green) x 8 (blue).



* COLOR=RESTORE



This statement resets the colour palette register according to the contents of the colour palette storage table (see APPENDIX VRAM MAP). For example, if image data written under unusual colour palette settings is BSAVEd, the original images cannot be reproduced because BLOADing the data does not change the colour palettes. Therefore, the image data should be BSAVEd with the colour palette storage table. To obtain the colours of the original images, BLOAD the data and reset the palettes with the COLOR=RESTORE

instruction.



* COLOR [=NEW]



This statement initialises the colour palette to the same state as when the power of the computer is turned on (see Table 2.5). It is a good idea to place this statement at the beginning and the end of the program.



Table 2.5 Initial colours of colour palettes and palette setting values

------------------------------------------------------------------

| Palette | Colour	 | Brightness | Brightness | Brightness |

| number |		 | of red | of blue | of green |

|---------+---------------+------------+------------+------------|

| 0	 | transparent |	0 | 0	 |	 0	 |

| 1	 | black	 |	0 | 0	 |	 0	 |

| 2	 | bright green |	1 | 1	 |	 6	 |

| 3	 | light green |	3 | 3	 |	 7	 |

| 4	 | deep blue	 |	1 | 7	 |	 1	 |

| 5	 | bright blue |	2 | 7	 |	 3	 |

| 6	 | deep red	 |	5 | 1	 |	 1	 |

| 7	 | light blue	 |	2 | 7	 |	 6	 |

| 8	 | bright red	 |	7 | 1	 |	 1	 |

| 9	 | light red	 |	7 | 3	 |	 3	 |

| 10	 | bright yellow |	6 | 1	 |	 6	 |

| 11	 | pale yellow |	6 | 3	 |	 6	 |

| 12	 | deep green	 |	1 | 1	 |	 4	 |

| 13	 | purple	 |	6 | 5	 |	 2	 |

| 14	 | grey	 |	5 | 5	 |	 5	 |

| 15	 | white	 |	7 | 7	 |	 7	 |

------------------------------------------------------------------



2.3 Additions or Modifications for the Character Display

* LOCATE [<X-coordinate>[, <Y-coordinate>[, <cursor switch>]]]



This statement specifies the location to display a character in the text display screen.



Since an 80-character display feature has been added to the screen mode 0, the X-coordinate value can be specified up to 79.



2.4 Additions or Modifications for the Graphics Display

* LINE [{(X1,Y1) | STEP(X1,Y1)}] - {(X2,Y2) | STEP(X2,Y2)}[, <colour> [, {B|BF}[, <logical operation>]]]

* PSET {(X,Y) | STEP(X,Y)}[, <colour>[, <logical operation>]]

* PRESET {(X,Y) | STEP(X,Y)}[, <colour>[, <logical operation>]]



The specifiable coordinate range of these statements varies according to the screen mode (see Table 2.6).



Table 2.6 Range of coordinates for each screen mode

-------------------------------------------------

| Screen mode | X-coordinate | Y-coordinate	|

|-------------+----------------+----------------|

| SCREEN 2 | 0 to 255 | 0 to 191	|

| SCREEN 3 | 0 to 255 | 0 to 191	|

| SCREEN 4 | 0 to 255 | 0 to 191	|

| SCREEN 5 | 0 to 255 | 0 to 211	|

| SCREEN 6 | 0 to 511 | 0 to 211	|

| SCREEN 7 | 0 to 511 | 0 to 211	|

| SCREEN 8 | 0 to 255 | 0 to 211	|

-------------------------------------------------



The logical operation feature is new. When <logical operation> is specified, a logical operation is done between the specified <colour> and the original colour, and the colour of its result will be used to draw. Logical operation types are listed in Table 2.7. <Colour> is specified by the palette number, except for screen mode 8.



Table 2.7 Logical operation

-----------------------------------------------------------------------------

| Logical operation	 |		 Function to draw		 |

|-------------------------+-------------------------------------------------|

| PSET (default) ,TPSET | Use "specified colour" |

| PRESET	 ,TPRESET | Use "NOT (specified colour)" |

| XOR		 ,TXOR	 | Use "(background colour) XOR (specified colour)"|

| OR		 ,TOR	 | Use "(background colour) OR (specified colour)" |

| AND		 ,AND	 | Use "(background colour) AND (specified colour)"|

-----------------------------------------------------------------------------



Note: The list above assumes that <colour> is (specified colour) and that the original colour of the place to be drawn is (background colour). Specifying a logical operation preceded by "T" causes nothing to be done when <colour> is transparent (colour 0).



* CIRCLE {(X,Y) | STEP(X,Y)},<radius>[, <colour>[, <start angle>[, <end angle>[, <proportion>]]]]



The coordinate range to be specified depends on the screen mode (see Table 2.6). <colour> is specified by the palette number, except for screen mode 8.



* PAINT {(X,Y) | STEP(X,Y)}[, <colour>[, <border colour>]]



The coordinate range to be specified depends on the screen mode (see Table 2.6). <Colour> is specified by the palette number, except for screen mode 8.

The specification of <border color> is invalid in screen modes 2 and 4.





2.5 Additions or modifications for VDP access




* BASE (<expression>)



This system variable contains the starting address of each table assigned to VRAM. The contents of <expression> and the screen mode tables correspond as listed in Table 2.8.



The starting address of the table can be read for each <expression>, but can be written only when <expression> is a value from 0 to 19 (that is, from screen mode 0 to screen mode 3).



Note that the table of screen mode 4 changes as you change the table address of screen mode 2.



Address returned for screen mode from 5 to 8 is the offset value from the starting address of the active page.



Table 2.8 Correspondences between BASE set values and VRAM table

------------------------------------------------------

| Expression | Screen mode |	 Table	 |

|------------+-------------+-------------------------|

| 0 |	 0	 | Pattern name table |

| 1 |	 0	 | N/A		 |

| 2 |	 0	 | Pattern generator table |

| 3 |	 0	 | N/A		 |

| 4 |	 0	 | N/A		 |

| 5 |	 1	 | Pattern name table |

| 6 |	 1	 | Colour table	 |

| 7 |	 1	 | Pattern generator table |

| 8 |	 1	 | Sprite attribute table |

| 9 |	 1	 | Sprite generator table |

| 10 |	 2	 | Pattern name table |

| 11 |	 2	 | Colour table	 |

| 12 |	 2	 | Pattern generator table |

| . |	 .	 |		.	 |

. 	 .			.

. 	 .			.

|	 |		 |			 |

| 43 |	 8	 | Sprite attribute table |

| 44 |	 8	 | Sprite generator table |

------------------------------------------------------



* VDP (<n>)



This allows the value of VDP register to be read and written. <n> is slightly different from the actual VDP register number. Their correspondances are listed in Table 2.9.



Table 2.9 Correspondances with VDP register

---------------------------------------------------

| n	 | VDP register number | Access mode |

|----------+------------------------+-------------|

| 0 to 7 | 0 to 7 (same as MSX1) | Read/write |

| 8	 | Status register 0 | Read only |

| 9 to 24 |	 8 to 23	 | Read/write |

| 33 to 47 |	 32 to 46	 | Write only |

| -1 to -9 | Status register 1 to 9 | Read only |

---------------------------------------------------



* VPEEK (<address>)

* VPOKE <address>, <data>



When the screen mode is from 5 to 8, the offset value from the starting address of the active page should be set for <address>. Valid range for the <address> value is from 0 to 65535 and the valid range for the data value is from 0 to 255.



* BSAVE <filename>, <start address>, <end address>, S

* BLOAD <filename> ,S



These are statements of DISK BASIC, used to save/load the contents of VRAM

to/from disk files. Both can be used in any screen mode, note, however, that only the active pages are valid when the screen mode is from 5 to 8. No cassette tapes can be used. Valid value range of <address> is from -32768 to -2, or from 0 to 65534 (&HFFFE).



* COPY (X1,Y1) - (X2,Y2)[, <source page>] TO (X3,Y3)[, <destination page> [, <logical operation>]]

* COPY (X1,Y1) - (X2,Y2)[, <source page>] TO {<array variable name> |

<filename>}

* COPY {<array variable name> | <filename>}[, <direction>] TO (X3,Y3) [, <destination page>[, <logical operation>]]

* COPY <filename> TO <array variable name> * COPY <array variable name> TO <filename>

The COPY statements transfer screen data and are valid when the screen mode is from 5 to 8. VRAM, array variables, and disk files can be used with these statements, and data can be transferred among these at will.



(X1,Y1) - (X2,Y2) means that the rectangular area, with a diagonal formed by these two coordinates is to be transferred. <Source page> and <destination page> indicate the page to be transferred from and the page to be transferred to, respectively, and if these pages are omitted, the active pages are assumed. <Direction> indicates the direction for writing the screen data to the screen, and is specified by a number from 0 to 3 (see Figure 2.3).



Figure 2.3 Directions for writing the screen data

Original Screen 	 Direction = 0	 Direction = 1



-----			-----			-----

| O |	 ---> 	| O |			| O |

-----			-----			-----

|				|			 |



Direction = 2	 Direction = 3



|			 |

-----			-----

| O |			| O |

-----			-----



<Array variable> is of the integer type, or single precision real type, or double precision real type. It should be prepared with enough area to get the screen data. Its size can be calculated by expression 1 as shown below.

<Pixel size> is the number of bits to be used to express one dot on the screen. It is 4 when the screen mode is 5 or 7, 2 for mode 6, and 8 for mode 8. Screen data is stored in the format shown in figure 2.4.



Expression 1



INT ((<pixel size>*(ABS(X2-X1)+1)*(ABS(Y2-Y1)+1)+7)/8)+4 bytes

Figure 2.4 Screen data format

------------------------------------

| horizontal width low-order byte | 0

|----------------------------------|

| horizontal width high-order byte | 1

|----------------------------------|

| vertical height low-order byte | 2

|----------------------------------|

| vertical height high-order byte | 3

|----------------------------------|

|				 | 4

|				 | .

| screen data (*)		 | .

|				 | .

|				 | n bytes

------------------------------------



(*) If the length of data cannot be divided by byte, excess bits are to be 0.



<Logical operation> specifies a logical operation between the data which resides on the destination and the data to be transferred. See table 2.7 for the parameters to specify.



When operations preceded by "T" are specified, the transparent portions of the source will not be transferred.





2.7 Additions or Modifications for Sprite




The sprites used in screen mode 4-8 of MSX2 are called sprite mode 2, which has upgraded a great deal as compared with MSX1. On MSX1, for example, one sprite could treat only one colour, while in this mode of MSX2 different colours can be specified for each horizontal line and so multi-coloured characters can be realised with one sprite. Additionally, it is a good idea to combine two sprites as though they were one sprite to paint each dot with different colours. And, on MSX1, when more than five sprites are arrayed on a horizontal line, the sprites after the fifth one were not displayed, but on MSX2 up to eight sprites can be displayed, so a higher flexibility is offered.



Colours which can be specified for sprites are shown in Table 2.4 (colour statement) except for screen mode 8. The sprite in screen mode 8, not capable of using the palette, uses the colour number for the specification, and only 16 colours can be used (see Table 2.10).



Table 2.10 Sprite colours in screen mode 8



-------------------------------------------------------------------------

| 0: Black	 | 1: Deep Blue | 2: Deep Red | 3: Deep Purple	|

|-----------------+-----------------+-----------------+-----------------|

| 4: Deep Green | 5: Turquoise | 6: Olive	 | 7: Grey 	|

|-----------------+-----------------+-----------------+-----------------|

| 8: Light Orange | 9: Blue	 | 10: Red	 | 11: Purple	|

|-----------------+-----------------+-----------------+-----------------|

| 12: Green	 | 13: Light Blue | 14: Yellow | 15: White	|

-------------------------------------------------------------------------



* PUT SPRITE <sprite plane number>[, {(X,Y) | STEP(X,Y)}[, <colour>[, <sprite pattern number>]]]



In screen modes 1 through 3, Y-coordinate was 209 for erasing the display of the specified sprite and was 208 for erasing the displays of the specified sprite and all sprites following it, but in screen modes 4 through 8, where the limit of Y-coordinate has been increased to 212 dots, the values to be specified are now 217 and 216, respectively.



* COLOR SPRITE$ (<sprite plane number>) = <string expression>

This statement specifies a colour for each horizontal line (see Figure 2.5).



<String expression> consists of one to sixteen characters. Bits 0 throgh 3 of the character's ASCII code are used for the colour specification, and bits 4

throgh 7 are used to specify each function of the sprite (see Table 2.11).

These specifications are valid only for screen modes 4 through 8.



COLOR SPRITE$ = CHR$ (colour of the first line) + CHR$ (colour of the second line) + ...... + CHR$ (colour of the eight line)

Figure 2.5 Relation of the sprite and <string expression>

---------------------------------

Line 1 --> | * | | | * | * | | | * |

|---+---+---+---+---+---+---+---|

Line 2 --> | * | * | | | | | * | * |

|---+---+---+---+---+---+---+---|

| | | | | | | | |

|---+---+---+---+---+---+---+---|

| * | * | | | | | * | * |

|---+---+---+---+---+---+---+---|

| | | * | | | * | | |

|---+---+---+---+---+---+---+---|

| * | | | * | * | | | * |

|---+---+---+---+---+---+---+---|

| * | * | | | | | * | * |

|---+---+---+---+---+---+---+---|

Line 8 --> | | | * | * | * | * | | | The colour for each line --------------------------------- can be set.



Table 2.11 Bitwise meanings of string expression

-------------------------------------------------------------------------

| b7 | If 1, move the sprite to left by 32 dots.			|

|----------+------------------------------------------------------------|

|	 | If 1, move the sprites of the successive planes together.	|

| b6 | The priority and conflict of sprites are ignored, and when |

|	 | sprites are piled up, they are displayed in the colour	|

|	 | which is OR-ed with their colour numbers. *		|

|----------+------------------------------------------------------------|

| b5 | If 1, the conflict of sprites are ignored. 		|

|----------+------------------------------------------------------------|

| b4 | Unused.							|

|----------+------------------------------------------------------------|

| b0 to b3 | Palette number.						|

-------------------------------------------------------------------------



* For example, assuming that bit 6 of sprite plane 1 is "0" and bit 6 of sprite plane 2 is "1", only by moving sprite plane 1, will sprite plane 2 be displayed displayed to be piled at the same location.



* COLOR SPRITE (<sprite plane number>) = <expression>

This statement sets the whole sprite of the specified plane to the <expression>, this uses <expression> for colour specification. The format of the colour specification is the same as shown in Table 2.11, but the specification for b7 is disabled. These are valid for screen modes 4 through





8.





2.8 Additions for Optional Features




* SET VIDEO [<mode>[, <Ym>[, <CB>[, <sync>[, <voice>[, <video input>[, <AV

control>]]]]]]]



This statement is for the superimposer or the digitiser which are optional, so it can be used only for machines which have these features.



<Mode> sets the superimposing mode and can be set to the value listed in Table 2.12.



When <Ym> is 1, the brightness of the television is halved.



When <CB> is 1, the colour bus of VDP is prepared for input, and, when 0, it is prepared for output.



When <sync> is 1, "external sync" is selected, and, when 0, "internal sync"

is selected.



<Voice> specifies whether to mix external signal for output, and values are listed in Table 2.13.



<Video input> is used to alternate the input of external video signals. When it is 0, the RGB multiconnector is selected; when it is 1, external video signal connector is selected.



<AV control> specifies AV control terminal output of the RGB multiconnector.

When it is 0, the output is OFF; when it is 1, the output is ON.



Table 2.12 Input values for SET VIDEO <mode>.



----------------------------------------

| Mode | S1 | S2 | TP | Display screen |

|------+----+----+----+----------------|

| 0 | 0 | 0 | 0 | Computer |

| 1 | 0 | 1 | 1 | Computer |

| 2 | 0 | 1 | 0 | Superimpose |

| 3 | 1 | 0 | 0 | Television |

----------------------------------------



Note: In the case of mode 0, external sync cannot be used. In other modes the compoalte output of VDP is not available. S1, S0, and TP are the names of flags in the VDP register.



Table 2.13 Input values for SET VIDEO <voice>

----------------------------------------------

| Voice | Function for external voice signal |

|-------+------------------------------------|

| 0	| No mixing			 |

| 1	| Right channel mixed		 |

| 2	| Left channel mixed		 |

| 3	| Both channels mixed		 |

----------------------------------------------



* COPY SCREEN [<mode>]



This statement is used for writing data from the colour bus to VRAM, for example, after digitising. This is valid for screen modes 5 to 8.



In mode 0, one field of signals is digitised and written to the display page; in mode 1, two successive fields (that is, one frame) of signals are written to (display page - 1)th page and the display page, so the display page should be an odd page when the mode is 1. The default mode is 0.





2.9 Additions for Timer Features




* GET DATE <string variable name> [,A]



This statement is for reading the date from the timer and assigning it to the string variable. The format of date to be read is as follows:

YY/MM/DD	(YY = lower two digits of year, MM = month, DD = day)

e.g.)	85/03/23	(March 23, 1985)



When option A is specified, the alarm date is read.



* SET DATE <string expression>[, A]



This statement sets date to timer. The form of parameter and option is the same as "GET DATE"



e.g.) SET DATE "85/03/23"



* GET TIME <string variable>[, A]



This statement is for reading time from the timer and assigning it to a string variable. The form of time to be read is as follows:

HH:MM:SS	(HH = hour, MM = minute, SS = second)

e.g.) 22:15:00		(22 hours 15 minutes 0 seconds)

When A is specified, the time for the alarm is read.



* SET TIME <string expression>[, A]



This statement sets the time to the timer. The form of parameter and option is the same as "GET TIME".



e.g.) SET TIME "22:15:00"



* The Alarm



Since the alarm feature is optional, the action taken at the specified time depends on the machine (ordinarily nothing happens).



When the alarm is to be set in both "SET DATE" and "SET TIME", "SET TIME"

should be done first (when "SET TIME" is done, date of the alarm set by "SET

DATE" will be erased).



The minimum setting for alarm is in minutes (setting in seconds is ignored).





2.10 Additions for Memory Switch




Using "SET" instructions, various settings described below can be stored to the battery-powered RAM in CLOCK-IC. Settings based on these are done automatically at system startup (when the system is powered or reset). "SET

TITLE", "SET PROMPT", and "SET PASSWORD" use the same RAM, so only the most recent instruction is valid.



* SET ADJUST (<X-coordinate offset>, <Y-coordinate offset>)

This statement sets the location to display on the screen. The coordinate offset is from -7 to 8.



* SET BEEP <timbre>, <volume>

This statement sets BEEP sound. <Timbre> and <volume> are from 1 to 4.



Table 2.14 shows the correspondance of <timbre> and to the actual sound.



Table 2.14 Input values for <timbre> of SET BEEP



------------------------------------------

| Timbre |	 Sound		 |

|--------+-------------------------------|

| 1	 | High tone beep (same as MSX1) |

| 2	 | Low tone beep		 |

| 3	 | 2 - tone beep		 |

| 4	 | 3 - tone beep		 |

------------------------------------------



* SET TITLE <string expression>[, <title colour>]



This statement specifies the title and the colour of the initial screen at system startup. <Title> is set by a string of up to 6 characters and <colour> is one of the values on Table 2.15. When <title> is 6 characters, keyboard input is awaited just after the title screen is displayed.



Table 2.15 Available colours in SET TITLE



-----------------------------------------------------

| Color 	| 1	 | 2	 | 3 | 4 |

|---------------+--------+--------+--------+--------|

| Screen color	| Blue	 | Green | Red | Orange |

-----------------------------------------------------



* SET PROMPT <prompt>



This statement sets the prompt. <Prompt> can have up to 6 characters.



* SET PASSWORD <password>



This statement sets a system password. <Password> is a string expression up to 255 characters. Once this statement is done, input of the password is requested for invoking the system. When the correct password is given, the system is normally invoked; otherwise, correct password input is requested.

When the system is invoked by pressing both graphic key and stop key, no password input is requested (in this case, the password setting has been done by the key cartridge; however, password input is always required for system startup). The password is disabled by specifying a null character in SET

TITLE.



* SET SCREEN



This statement records the current parameters of the "SCREEN" statement. At the system startup, they are automatically set. Items to be recorded are the following:



Screen number of text mode			Key click switch Screen width of text mode			Printer option Foreground, background, and border colours	Cassette baud rate Function key switch				Display mode





2.11 Additions for RAM Disk




On MSX1 RAM from 0000H to 7FFFH was used only by DOS. On MSX2, however, this portion can be used as a RAM disk of up to 32K bytes. The format of the file name for RAM disk is described below, where <filename> is a string which consists of 1 to 8 characters and <extension> is one which consists of 1 to 3 characters. Note that ";" (colon), "." (period), control characters of character codes 00H-1FH, and graphic symbols consisting of two bytes cannot be used.



MEM: <filename>[.<extension>]



The following are executable operations for the RAM disk:

1. Load/save a BASIC program (always saved in ASCII format) SAVE, LOAD, RUN, MERGE



When any of the above commands is executed from the program, control returns to the command level.



2. Read/write a sequential file OPEN, CLOSE

PRINT #, PRINT USING #

INPUT #, LINE INPUT #, INPUT$

EOF, LOC, LOF



The RAM disk does not support the following instructions:

1. Random file Read/Write 2. BLOAD, BSAVE





3. COPY




* CALL MEMINI [(<size>)]



This statement specifies the amount of memory to be used as a RAM disk, initialises the RAM disk, and deletes all files. When the RAM disk is to be used, this statement should always be executed.



<Size> is "the amount of memory to be used as RAM disk minus 1". By default, the maximum size is allocated for RAM disk. "CALL MEMINI(0)" causes the RAM

disk feature to be disabled.



* CALL MFILES



This statement displays file names on the RAM disk.



* CALL MKILL ("<filename>")



This statement deletes the specified file.



* CALL MNAME ("<old filename>" AS "<new filename>")

This statement renames the specified file.





2.12 Other Additions




* PAD (<expression>)



This function returns status to touch pad (touch panel), light pen, mouse, or track ball.



When <expression> is 0 to 7, it returns the status to touch pad as on MSX1, and, when <expression> is 8 to 11, it returns the status to light pen. Since the coordinates and the value of the switch are read when "PAD(8)" is executed, other data should be read after confirming that the value of PAD(8) is -1 (see Table 2.16).



Table 2.16 <Expression> returning status to light pen

---------------------------------------------------------------------

| Expression |		 The value returned		 |

|------------+------------------------------------------------------|

| 8 | -1 when data of light open is valid; otherwise, 0 |

| 9 | X - coordinate of light pen			 |

| 10 | Y - coordinate of light pen			 |

| 11 | -1 when switch of light pen is pressed; otherwise, 0 |

---------------------------------------------------------------------



This statement returns the status of the mouse or the track ball connected to port 1 when <expression> is 12 to 15 or connected to port 2 when it is 16 to 19 (see Table 2.17). The mouse and track ball are automatically distinguished from each other.



Table 2.17 <Expression> returning status to mouse or track ball

---------------------------------------

| Expression |	 The value returned |

|------------+------------------------|

| 12, 16 | - 1; for input request |

| 13, 17 | X - coordinate	 |

| 14, 18 | Y - coordinate	 |

| 15, 19 | 0 (unused)	 |

---------------------------------------



Coordinate data is read when PAD(12) or PAD(16) is examined. Coordinate data should be obtained after examining these. The STRIG function is used with the joystick to input the status of the trigger button.





3. INTERNAL STRUCTURE OF BASIC




Knowledge of how the BASIC interpreter controls and executes programs is necessary for more advanced use of BASIC. The internal structure of BASIC is discussed next.





3.1 User's Area




The lowest address of the user's area was different in the MSX1 machine whose amount of RAM was 8K, 16K, 32K, or 64K; in MSX2, it is always 8000H, because MSX2 machines have at least 64K of RAM. It can be obtained from the content of BOTTOM (FC48H).



The highest address of the user's area when no disk drives are connected is F380H; when disk drives are connected (using DISK-BASIC), it depends on the number of disk drives or on the disk capacity. It can be obtained from the content of HIMEM (FC4AH) after reset and before executing CLEAR statement.



Figure 2.6 shows the state of memory when MSX is invoked.



Figure 2.6 State of memory for BASIC mode

0000 --------------------

|			|

|	 BASIC	|

|	 Interpreter	|

|			|

8000 |------------------| <-- (BOTTOM) 	 --+

|			|			 |

|	 User area	|		 --+ |

|			|		 | |

|------------------| <-- (HIMEM)	 | |32K

|	Disk work area	|	 --+ |16K |

F380 |------------------|		 | 8K | |

| System work area |		 | | |

FFFF --------------------	 --+ --+ --+



Note: Though the machine has more than 32K bytes of RAM, only 32K bytes are used for BASIC. On MSX2, however, another 32K bytes can be used as a RAM disk by BASIC.



When developping a program on MSX2, we recommend you create it at addresses 8000H to DE3FH as if to install a 2DD-2 drive whose highest address of the user's area is the lowest. The work area of the disk can grow even larger, therefore, HIMEM of the application program should be checked to prevent disasters even in the worst situation. The following are ways to prevent this:



1. Make the work area relocatable





2. Get the work area from BOTTOM


3. Stop after instructing to reduce the number of drives

On MSX, even when disks are mounted, they can be cut off by resetting while pressing the SHIFT key. When only one drive is mounted, the normal invocation causes the work area for two drives to be allocated (mainly for 2 drive simulator): in such a case, invoking the works area for only one drive is possible by resetting while pressing the CTRL key. If these steps are taken, more user's area can be allocated.





3.2 Detailed View of the User's Area




Figure 2.7 shows how the user's area will be used in BASIC, and Table 2.18

shows the work area with information about where these areas start. This work area is read-only (the initialising routine sets it when reset), so actions when it is changed are not guaranteed.



Figure 2.7 State of the user's area

BOTTOM --> ---------------------- The lowest of the user's area |			 | (8000H on MSX2) TXTTAB --> |--------------------|

|		 | |

|	 BASIC V |

|	program area	 |

|			 |

VARTAB --> |--------------------| Depends on the amount of text | Simple variable | |

|	 area V |

ARYTAB --> |--------------------|

| Array variable | |

|	 area V |

STREND --> |--------------------| Depends on the number of variables |		 | |

|		 V |

|	 Free area	 |

|		 ^ |

|		 | |

SP --> |--------------------| Area pointed by SP register | Stack	 ^ |

| area	 | |

STKTOP --> |--------------------| --+

| String	 ^ | | Set by 1st parameter | area	 | | | of CLEAR

MEMSIZ --> |--------------------| --+

| File	 ^ |

| control block | |

HIMEM --> |--------------------| Set by 2nd parameter of CLEAR

|			 |

| Assembly language |

| area		 |

|			 |

---------------------- The highest of the user's area (depends on the presence of disks)

Table 2.18 Work areas with start and end addresses of each area

Area name		 Start address	 End address ----------------------------------------------------------------------------

User's area | [BOTTOM (FC48H)] | ([HIMEM (FC4AH)] when reset) - 1

Program area	 | [TXTTAB (F676H)] | [VARTAB (F6C2H)] - 1

Simple variable area | [VARTAB (F6C2H)] | [ARYTAB (F6C4H)] - 1

Array variable area | [ARYTAB (F6C4H)] | [STREND (F6C6H)] - 1

Free area	 | [STREND (F6C6H)] | [SP register] - 1

Stack area	 | [SP register]	 | [STKTOP (F674H)] - 1

String area	 | [STKTOP (F674H)] | [MEMSIZ (F672H)] - 1

(start of unused area) | [FRETOP (F69BH)] |

File control block | [MEMSIZ (F672H)] | [HIMEM (FC4AH)] - 1

Assembly language area | [HIMEM (FC4AH)] | to the end of the user's area ----------------------------------------------------------------------------



Roles of each user's area are described below.



* BASIC program area



A program written in BASIC is stored from the lowest address (8000H on MSX2) of the user's area and its size depends on the amount of the program.



* Variable area



The variable area is located just after the BASIC program area. It is secured to store the name and the value of the variables used when executing the program. The variables storage formats are shown in Figure 2.8 (simple variables) and Figure 2.9 (array variables). Using array variables without declaring in the DIM statement causes the area to be allocated as an array with ten indexes. However, arrays which are more than four dimensional must be declared.



Figure 2.8 Storage format of simple variables

------ ------------- -------------

Integer variable | 02 | |	| | | | |

------ ------------- -------------

Name of	 Integer variable



------ ------------- -------------------------

Single precision | 04 | |	| | | | |	 |	 |

real variable	 ------ ------------- -------------------------

Name of	 Single precision variable	 real number

------ ------------- -------------------------

Double precision | 08 | |	| | | | |	 |	 |

real variable	 ------ ------------- -------------------------

Name of	 | | |	 |	 |

variable	 -------------------------

Double precision real number



------ ------------- ------ -------------

String variable | 03 | |	| | | | | |	 |

------ ------------- ------ -------------

Name of	 Number Address for variable	 of	 string characters storage

^			 ^

|			 |

Variable	 Address returned type	 by VARPTR function

Figure 2.9 Storage format of array variables

------	 ------------- -------------

| |	 |	| | |	 | |

------	 ------------- -------------

variable variable	 length

type	 name	 of data

(1 byte) (2 bytes)	 (2 bytes)



+---------------------------- data ----------------------------+

|								 |



------	 ----------	 ----------	---------- -----------

| |	 |	| . . . |	 |	| | . . . |	 |

------	 ----------	 ----------	---------- -----------

number	 (largest index for each	 variable data of	 dimension) + 1

dimension (number of dimensions)

(1 byte) x 2 bytes



e.g.) DEFINT A : DIM AA (2,3)



+---------------------- (*) -----------------------+

|							|

02 41 41 1D 00 02 04 00 03 00 00 00 00 00	 00 00

| |	 |	 |	 |	 |	 |	 |	 | ... |	|

-----------------------------------------------------------	---------

Inte- Varia- Number 2 di- (index (index AA(0,0) AA(1,0)	 AA(2,3) ger ble of men- of 2nd of 1st |				|

type name bytes sion dimen- dimen- +------ Variable data--------+

"AA" of (*) array sion)+1 sion)+1



Note: variable data format is the same as the storage format of simple variables. The lower of the 2-byte value is stored first, and the higher byte last.



* Free area



If the program area or the variable area grows too large or a lot of data is stacked and the free area runs out, an "OUT OF MEMORY" error occurs. The amount of free area can be checked by examining PRINT FRE(0) using the FRE

function in BASIC.



* Stack area



This is the stack area used by BASIC. It is used in order from high-order address when executing GOSUB or FOR.



* String area



This area is used to reserve the contents of string variables and used from high-order address. The space in this area can be specified by the first parameter of the CLEAR statement in BASIC. The default is 200 bytes.

Exhausting the space in this area causes a "OUT OF STRING SPACE" error. The amount of unused area can be checked by examining PRINT FRE("") using the FRE

function in BASIC



* File control block



File information is stored in this area with 10BH (267) bytes allocated for each file. The amount of space for files can be specified by the MAXFILES

statement of BASIC. At reset, the area for one file (MAXFILES = 1) is allocated. Another space is always allocated for SAVE and LOAD instructions, so actually area for two files is allocated. Table 2.19 shows the format of file control block.



Table 2.19 File control block (FCB) format

Offset Label		 Meaning --------------------------------------------------------------

| + 0	| FL.MOD |	 Mode of the file opened	 |

| + 1	| FL.FCA |	 Pointer (low) to FCB for BDOS	 |

| + 2	| FL.LCA |	 Pointer (high) to FCB for BDOS |

| + 3	| FL.LSA |	 Backup character		 |

| + 4	| FL.DSK |	 Device number			 |

| + 5	| FL.SLB |	 Internal use for the interpreter |

| + 6	| FL.BPS |	 FL.BUF location		 |

| + 7	| FL.FLG |	 Flag containing various information |

| + 8	| FL.OPS |	 Virtual head information	 |

| + 9...| FL.BUF |	 File buffer (256 bytes)	 |

--------------------------------------------------------------



* Assembly language area



Use this area to write programs in assembly language or to operate from memory directly. To do these, this area should be reserved by CLEAR

statement.



* Work area for disk



Figure 2.10 shows the work area allocated when a disk is mounted. Note that this area does not exist when no disk is mounted. Labels to the right of this figure shows the address information which resides there.



Figure 2.10	Work area for disk

:	 User's :

:		area	 :

BLDCHK + 1 (F377H + 1)	--> |------------------------| --+

|	BLOAD, BSAVE routine | |

|	 (19H bytes) | |

FCBBASE (F353H)	--> |------------------------| | Reserved when a |	 FCB entry	 | | disk is mounted | (25H * (FILMAX) bytes) | |

HIMSAV (F349H)	--> |------------------------| |

|	 Disk interface | |

|	 work area	 | |

F380H	--> |------------------------| --+

:	 System	 :

:	 work area :





3.3 Storage format of BASIC programs




Programs are stored in memory as shown in Figure 2.11 and the meaning of its contents are described below.



Figure 2.11	Text storage format

Text start code (8000H) ------

| 00 |

------

Code for the

Link pointer Line number		 Text 	 end of line (EOL) -----------	 ----------- --------------	 --------- ------

| XX | XX |	 | XX | XX | | XX | XX | . . . | XX | | 00 |

-----------	 ----------- --------------	 --------- ------

|	 List of the first line number +-------+

|

| -----------	 ----------- --------- ---------	 ------

+->| XX | XX |	 | XX | XX | | XX |	. . .	| XX |	 | 00 |

-----------	 ----------- --------- ---------	 ------

|

+-------+

|

|	.	 . 		 .

+->	.	 . 		 .

.	 . 		 . Line number .	 . 		 .

.	 . 		 .



|

+-------+

|

| -----------	 ----------- --------- ---------	 ------

+->| XX | XX |	 | XX | XX | | XX |	. . .	| XX |	 | 00 |

-----------	 ----------- --------- ---------	 ------

|	 List of the last line number +-------+

|

| -----------

+->| 00 | 00 |	 Code for the end of text (EOT) -----------



Note: Link pointers and line numbers are stored with their low bytes first and high bytes last.



* Link pointer



The text pointer to the next line is given in the form of an absolute address.



* Line number



This stores the line number of the program, normally the values from 0 to 65529 (from 0000H to FFF9H). It is possible to make line numbers of 65530 or more, but LIST command does not list them.



* Text



The program body is stored here in the intermediate code format. Reserved words (keywords), operators, numeric values are converted to the intermediate codes, and others (such as variable names or string constantes) are stored as character codes. Table 2.20 lists the intermediate codes and Figure 2.12

shows the numeric formats in text.



See the appendix at the end of this book for character codes. Graphic characters are stored in 2 bytes (2 characters) of "CHR$(1) + (graphic character code + 64)", so be careful when defining graphic characters.



Table 2.20 List of intermediate codes

------------------- ------------------- -------------------

| >	 | EE | | ERR	| E2 | | PAINT | BF |

| =	 | EF | | ERROR	| A6 | | PDL | FF A4 |

| <	 | F0 | | EXP	| FF 8B | | PEEK | FF 97 |

| +	 | F1 | | FIELD	| B1 | | PLAY | C1 |

| -	 | F2 | | FILES	| B7 | | POINT | ED |

| *	 | F3 | | FIX	| FF A1 | | POKE | 98 |

| /	 | F4 | | FN	| DE | | POS | FF 91 |

| ^	 | F5 | | FOR	| 82 | | PRESET | C3 |

| \	 | FC | | FPOS	| FF A7 | | PRINT | 91 |

| ABS	 | FF 86 | | FRE	| FF 8F | | PSET | C2 |

| AND	 | F6 | | GET	| B2 | | PUT | B3 |

| ASC	 | FF 95 | | GOSUB	| 8D | | READ | 87 |

| ATN	 | FF 8E | | GOTO	| 89 | | REM | 3A 8F |

| ATTR$ | E9 | | HEX$	| FF 9B | | RENUM | AA |

| AUTO	 | A9 | | IF	| 8B | | RESTORE | 8C |

| BASE	 | C9 | | IMP	| FA | | RESUME | A7 |

| BEEP	 | C0 | | INKEY$	| EC | | RETURN | 8E |

| BIN$	 | FF 9D | | INP	| FF 90 | | RIGHT$ | FF 82 |

| BLOAD | CF | | INPUT	| 85 | | RND | FF 88 |

| BSAVE | D0 | | INSTR	| E5 | | RSET | B9 |

| CALL	 | CA | | INT	| FF 85 | | RUN | 8A |

| CDBL	 | FF A0 | | IPL	| D5 | | SAVE | BA |

| CHR$	 | FF 96 | | KEY	| CC | | SCREEN | C5 |

| CINT	 | FF 9E | | KILL	| D4 | | SET | D2 |

| CIRCLE | BC | | LEFT$	| FF 81 | | SGN | FF 84 |

| CLEAR | 92 | | LEN	| FF 92 | | SIN | FF 89 |

| CLOAD | 9B | | LET	| 88 | | SOUND | C4 |

| CLOSE | B4 | | LFILES	| BB | | SPACE$ | FF 99 |

| CLS	 | 9F | | LINE	| AF | | SPC( | DF |

| CMD	 | D7 | | LIST	| 93 | | SPRITE | C7 |

| COLOR | BD | | LLIST	| 9E | | SQR | FF 87 |

| CONT	 | 99 | | LOAD	| B5 | | STEP | DC |

| COPY	 | D6 | | LOC	| FF AC | | STICK | FF A2 |

| COS	 | FF 8C | | LOCATE	| D8 | | STOP | 90 |

| CSAVE | 9A | | LOF	| FF AD | | STR$ | FF 93 |

| CSNG	 | FF 9F | | LOG	| FF 8A | | STRIG | FF A3 |

| CSRLIN | E8 | | LPOS	| FF 9C | | STRING$ | E3 |

| CVD	 | FF AA | | LPRINT	| 9D | | SWAP | A4 |

| CVI	 | FF A8 | | LSET	| B8 | | TAB( | DB |

| CVS	 | FF A9 | | MAX	| CD | | TAN | FF 8D |

| DATA	 | 84 | | MERGE	| B6 | | THEN | DA |

| DEF	 | 97 | | MID$	| FF 83 | | TIME | CB |

| DEFDBL | AE | | MKD$	| FF B0 | | TO | D9 |

| DEFINT | AC | | MKI$	| FF AE | | TROFF | A3 |

| DEFSNG | AD | | MKS$	| FF AF | | TRON | A2 |

| DEFSTR | AB | | MOD	| FB | | USING | E4 |

| DELETE | A8 | | MOTOR	| CE | | USR | DD |

| DIM	 | 86 | | NAME	| D3 | | VAL | FF 94 |

| DRAW	 | BE | | NEW	| 94 | | VARPTR | E7 |

| DSKF	 | FF A6 | | NEXT	| 83 | | VDP | C8 |

| DSKI$ | EA | | NOT	| E0 | | VPEEK | FF 98 |

| DSKO$ | D1 | | OCT$	| FF 9A | | VPOKE | C6 |

| ELSE	 | 3A A1 | | OFF	| EB | | WAIT | 96 |

| END	 | 81 | | ON	| 95 | | WIDTH | A0 |

| EOF	 | FF AB | | OPEN	| B0 | | XOR | F8 |

| EQV	 | F9 | | OR	| F7 | -------------------

| ERASE | A5 | | OUT	| 9C |

| ERL	 | E1 | | PAD	| FF A5 |

------------------- -------------------



Figure 2.12	Numeral formats in text

----------------

Octal number (&O)	| 0B | XX : XX |

----------------

----------------

Hexadecimal number (&H)	| 0C | XX : XX |

----------------



---------------- Absolute address of the Line number (after RUN)	| 0D | XX : XX | destination line for the ---------------- branch instruction in memory.



Destination line number ---------------- for the branch instruction.

Line number (before RUN)	| 0E | XX : XX | After RUN, identification ---------------- code is made 0DH and the line number is changed to the absoulte address.

-----------

Integer from 10 to 255 (%)	| 0F : XX |

-----------

------

Integer from 0 to 9 (%)	| | 11 to 1A ------

----------------

Integer from 256 to 32767 (%)	| 1C | XX : XX |

----------------

--------------------------

Single precision real (!)	| 1D | XX : XX : XX : XX |

--------------------------

--------------------------

Double precision real (#)	| 1F | XX : XX : XX : XX : --------------------------

: XX : XX : XX : XX |

---------------------

------------------

Binary (&B)	| "&"| "B"| . . . Characters of "0" or "1"

------------------ following "&B"



Numbers called "identification codes" are assigned numeric values to distinguish them from reserved words and variable names, and by referring to them the following values can be recognised.



The high and low bytes of a 2-byte numeric value are stored in reverse.

Signed numeric values have only the intermediate codes + or - preceding the identifying codes, numeral values themselves are always stored as positive values. Floating-point notations are almost the same as the descriptions of Math-Pack (Mathematical Package) in the APPENDIX, note that numerical values are always stored as positive. Binary numbers (&B) do not have identifying codes and are stored as ASCII codes.





4. LINKING WITH ASSEMBLY LANGUAGE PROGRAMS




As described so far, MSX BASIC version 2.0 has powerful features, but, if you wish to save execution time even more or to make full use of MSX2 hardware, you should use assembly language. The following sections show how to call assembly language programs from BASIC and gives the information you will need.





4.1 USR Function




To call the assembly language routine from BASIC, follow the steps described below. The value in parenthesis of the USR function is passed to the assembly language routine as an argument. The argument may be either an expression or a string expression.



1. Specify the starting address of the assembly language program for the execution, using DEF USR statement.

2. Call the assembly language program by USR function.

3. Execute RET (C9H) when returning from the assembly language routine to BASIC.



e.g.) To call the assembly language program whose starting address is C000H:

DEFUSR=&HC000

A=USR(0)



4.2 Data Exchange by the Argument and Return Value of USR Function

When the argument is passed from BASIC to the assembly language program, its type can be checked by examining the contents of register A in the assembly language program (see Table 2.21). Since the object value is stored in the form as shown in Figure 2.13 according to the argument type, you can get the value according to the format. As an example, List 2.1 shows a program which receives an argument of the string type.



Table 2.21	Argument types assigned to register A

--------------------------------------

| 2 | 2-byte integer type	 |

| 3 | String type		 |

| 4 | Single precision real type |

| 8 | Double precision real type |

--------------------------------------



Figure 2.13	How values are passed as arguments

2-byte integer type			 + 0	 + 1 2 + 3

Address pointed at by HL register --> -----------------------------

| XX | XX | Low | High |

-----------------------------

Note: "XX" may be anything

Single precision real type		 + 0	 + 1 2 + 3

Address pointed by HL register --> -----------------------------

|Expo- |Man- |Man- |Man- |

|nent |tissa |tissa |tissa |

-----------------------------



Double precision real type		 + 0	 + 1	 7

Address pointed by HL register --> --------------- --------

|Expo- |Man- | . . . |Man- |

|nent |tissa | . . . |tissa |

--------------- --------



String type				 + 0	 + 1 2	These three Address pointed by DE register --> ----------------------	bytes are | | Low | High |	called the ----------------------	string ^ |	 |	descriptor.

Number of characters --+ +-------------+

Points to the address of the string



List 2.1 Example of the argument of string type =========================================================================



;************************************************************

; List 2.1 print string with USR function ;	 to use, do DEF USR=&HB000 : A$=USR("STRING") ;************************************************************

;

CHPUT	EQU	00A2H		;character output



ORG	0B000H



RDARG:	CP	3

RET	NZ		;parameter is not string

PUSH	DE

POP	IX		;IX := string descriptor LD	A,(IX+0)	;get string length LD	L,(IX+1)	;get string pointer (low) LD	H,(IX+2)	;get string pointer (high) OR	A

RET	Z		;if length = 0



RD1:	PUSH	AF

LD	A,(HL)		;get a characetr CALL	CHPUT		;put a character POP	AF

DEC	A

RET	Z

INC	HL

JR	RD1



END



=========================================================================



On the other hand, these values passed as arguments can be passed to BASIC as USR function values by changing them in the assembly language program. In this case the type of return value can alse be changed to types other that of the argument from BASIC by changing VALTYP (F663H). Note that the amount of characters for a string cannot be changed.





4.3 Making New Commands




In MSX the reserved words "CMD" and "IPL" are currently unused and by changing the pointers to these words (FE0DH and FE03H) to jump to your own assembly language routine, new commands can be built. List 2.2 shows a simple example.



List 2.2 Making CMD command

=========================================================================



;*****************************************************************

; List 2.2 make CMD command ( turn on/off the CAPS LOCK ) ; to initialize command:		DEF USR=&HB000 : A=USR(0) ; to use command:			CMD

;*****************************************************************

;

CHGCAP	EQU	0132H		;CAPS LAMP on/off

CAPST	EQU	0FCABH		;CAPS LOCK status

HCMD	EQU	0FE9DH		;CMD HOOK



ORG	0B000H



;----- CMD initialize ----- Note: Executing this section adds the CMD command



LD	BC,5		;NEW HOOK SET

LD	DE,HCMD

LD	HL,HDAT

LDIR

RET



;----- new HOOK data ----- Note: 5-byte data to be written into hook (FE0DH)



HDAT:	POP	AF

JP	CAPKEY

NOP



;----- executed by CMD ----- Note: Actual CMD command

CAPKEY: CALL	CHGCAP

LD	A,(CAPST)

CPL

LD	(CAPST),A

RET



END



=========================================================================



The first "POP AF" written to the pointer in this case, discards the error handling addresses stacked at "CMD" execution. Without this, the "RET"

command would jump to the error handling routine isntead of returning to BASIC. It is a way to use this address for printing errors inside of user routine.



These pointers are reserved for future expansion, so should not be used with application programs on the market.





4.4 Expansion of CMD command




For more sophisticated expansions of statements it is useful if arguments can be passed to the CMD command. As the HL register points to the next location after "CMD" in the BASIC text when the assembly language routine is called, it can be done by appreciating the successive string. The following is a list of internal routines, useful for these.



* CHRGTR (4666H/MAIN) ---- Extract one character from text (see Figure 2.14) Input:	 HL <-- Address pointing to text Output: HL <-- Address of the extracted character A <-- Extracted character Z flag <-- ON at the end of line (: or 00H) CY flag <-- ON if 0 to 9

Purpose: Extract one character from the text at (HL + 1). Spaces are skipped.



Figure 2.14	Input/output state of CHRGTR



---------------------------------------------------------------------------

| Input 								 |

|									 |

| ------------------------------------------------- BASIC text		 |

| . . . | A |	| = | 0 | : |	| B | = | 0 | . . . (in intermediate code |

| ------------------------------------------------- format, actually)	 |

|	 ^								 |

|	 |								 |

|	 HL								 |

|-------------------------------------------------------------------------|

| First execution							 |

|			-----						 |

|		 +-> A | = |						 |

|		 |	-----						 |

| -------------------------------------------------			 |

| . . . | A |	| = | 0 | : |	| B | = | 0 | . . . spaces are skipped	 |

| -------------------------------------------------			 |

|		 ^							 |

|		 |							 |

|		 HL							 |

|-------------------------------------------------------------------------|

| Second execution							 |

|			 ----- -----				 |

|		 +-> A | 0 | CY | 1 |				 |

|		 | ----- -----				 |

| ------------------------------------------------- CY flag is ON	 |

| . . . | A |	| = | 0 | : |	| B | = | 0 | . . . when reading a number |

| -------------------------------------------------			 |

|		 ^ 						 |

|		 | 						 |

|		 HL						 |

|-------------------------------------------------------------------------|

| Third execution							 |

|				-----	 -----				 |

|			 +-> A | : | Z | 1 |				 |

|			 |	-----	 -----				 |

| ------------------------------------------------- Z flag is ON	 |

| . . . | A |	| = | 0 | : |	| B | = | 0 | . . . when reading	 |

| ------------------------------------------------- the end of line	 |

|			 ^						 |

|			 |						 |

|			 HL						 |

---------------------------------------------------------------------------



* FRMEVL (4C64/MAIN) ---- Evaluate an expression in text (see Figure 2.15) Input:	 HL <-- Starting address of the expression in text Output: HL <-- Address after the expression [VALTYP (F663H)] <-- Value 2, 3, 4 or 8 according to the expression [DAC (F7F6H)]	 <-- Result of the evaluation of the expression Purpose: Evaluate an expression and make output according to its type.



Figure 2.15	Input/output state of FRMEVL



-----------------------------------------------------------------------------

| Input 								 |

|									 |

| ----------------------------------------------------------------------- |

| ...| B | = | A | * | 3 | + | 1 | 0 | 0 | / | 2 | 0 | : | C | = | 0 |... |

| ----------------------------------------------------------------------- |

|		^							 |

|		|							 |

|		HL							 |

|---------------------------------------------------------------------------|

| Output								 |

|									 |

| ----------------------------------------------------------------------- |

| ...| B | = | A | * | 3 | + | 1 | 0 | 0 | / | 2 | 0 | : | C | = | 0 |... |

| ----------------------------------------------------------------------- |

|	 | 				 | ^		 |

|	 +---------------------------------------+ |		 |

|				 |			HL		 |

|			 --------------				 |

|		 DAC | calculated |				 |

|			 |	result	 |				 |

|			 --------------				 |

|				----- The case of double precision	 |

|		 VALTYP	| 8 | real number, for example 	 |

|				-----					 |

-----------------------------------------------------------------------------



* FRMQNT (542F/MAIN) ---- Evaluate an expression un 2-byte integer type.

Input:	 HL <-- Starting address of the expression in text Output: HL <-- Address after the expression DE <-- Result of evaluation of the expression Purpose: Evaluate an expression and make output in integer type (INT). When the result is beyond the range of 2-byte integer type, an "Ovwrflow" error occurs and the system returns to the BASIC command level.



* GETBYT (521C/MAIN) ---- Evaluate an expression in 1-byte integer type.

Input:	 HL <-- Starting address of the expression in text Output: HL <-- Next address of expression A, E <-- Result of expression evaluation (A and E contains the same value.) Purpose: Evaluate an expression and make 1-byte integer output. When the result is beyond the range of 1-byte integer type, an "Illegal function call"

error occurs and the execution returns to BASIC command level.



* FRESTR (67D0/MAIN) ---- Register a string.

Input:	 [VALTYP (F663H)] <-- Type (if not string type, an error occurs) [DAC (F7F6H)]	 <-- Pointer to string descriptor Output: HL <-- Pointer to string descriptor Purpose: Register the result of the string type obtained by FRMEVL and obtain its string descriptor. When evaluating a string, this is generally combined with FRMEVL described above to use as follows:

.

.

.

CALL	FRMEVL

PUSH	HL

CALL	FRESTR

EX	DE,HL

POP	HL

LD	A,(DE)

.

.

.



* PTRGET (5EA4/MAIN) ---- Obtain the address for the storage of a variable (see Figure 2.16).

Input:	 HL <-- Starting address of the variable name in text [SUBFLG (F6A5H)] <-- 0: Simple variable, other than 0: array variable Output: HL <-- Address after the variable name DE <-- Address where the contents of the objective variable is stored

Purpose: Obtain the address for the storage of a variable (or an array variable). Allocation of the area is also done when the area for the objective variable has not been allocated. When the value of [SUBFLG] is set to other than 0, the starting address of the array is obtained, other than individual elements of the array.



Figure 2.16	Input/output state of PTRGET



-------------------------------------------------------------------------

| Input 	---------------------------------			|

|		. . . | A | A | = | B | B | . . .			|

|		---------------------------------			|

|			^						|

|			|						|

|			HL						|

|				-----					|

|			SUBFLG	| 0 |					|

|				-----					|

|-----------------------------------------------------------------------|

| Output	---------------------------------			|

|		. . . | A | A | = | B | B | . . .			|

|		---------------------------------			|

|				^					|

|				|					|

|				HL					|

|									|

|		 ----------- address where the contents		|

|		DE | XX | XX | of variable AA reside			|

|		 ----------- 					|

-------------------------------------------------------------------------



-------------------------------------------------------------------------

| Input 	---------------------------------------------		|

|		. . . | A | A | ( | 3 | ) | = | B | B | . . .		|

|		---------------------------------------------		|

|			^						|

|			|						|

|			HL						|

|				-----					|

|			SUBFLG	| 0 |					|

|				-----					|

|-----------------------------------------------------------------------|

| Output	---------------------------------------------		|

|		. . . | A | A | ( | 3 | ) | = | B | B | . . .		|

|		---------------------------------------------		|

|					 ^				|

|					 |				|

|					 HL				|

|									|

|		 ----------- address where the contents		|

|		DE | XX | XX | of variable AA(3) reside		|

|		 ----------- 					|

-------------------------------------------------------------------------



-------------------------------------------------------------------------

| Input 	---------------------------------------------		|

|		. . . | A | A | ( | 3 | ) | = | B | B | . . .		|

|		---------------------------------------------		|

|			^						|

|			|						|

|			HL						|

|				-----					|

|			SUBFLG	| 1 |					|

|				-----					|

|-----------------------------------------------------------------------|

| Output	---------------------------------------------		|

|		. . . | A | A | ( | 3 | ) | = | B | B | . . .		|

|		---------------------------------------------		|

|					 ^				|

|					 |				|

|					 HL				|

|									|

|		 ----------- starting address of			|

|		DE | XX | XX | array variable AA(n)			|

|		 ----------- 					|

-------------------------------------------------------------------------



* NEWSTT (4601H/MAIN) ---- Execute a text Input:	 HL <-- Address of the text to be executed Output: ----

Purpose: Execute a text. The state of the text is necessary to be as same as shown in Figure 2.17.



Figure 2.17	Memory setting for NEWSTT



Intermediate codes of BASIC are contained here.

+-----------------+

|		 |

3AH 94H	 00H

-------------------------

| : | NEW | | . . .

-------------------------

^ 	word

| 	stop

HL



Since these internal routines are for BASIC texts, the same error handling as BASIC is done when an error occurs. In this case, by changing H.ERROR

(FFB1H), the user can handle the error (the E register contains the error number) (see List 2.3).



List 2.3 Changing error handling routine =========================================================================



;****************************************************************

; List 2.3 Your own error

;	 To use,	do DEF USR=&HB000 : A=USR(0) ;****************************************************************

;

HERR	EQU	0FFB1H		;error hook

SYNERR	EQU	2		;syntax error code

CHPUT	EQU	0A2H		;character output

NEWSTT	EQU	4601H		;run

READYR	EQU	409BH



ORG	0B000H

Note:

;----- command initialize ----- When this portion is executed, the error handling routine is changed.



LD	BC,5		;SET NEW HOOK

LD	DE,HERR

LD	HL,HDAT

LDIR

RET



HDAT:	JP	ERROR

NOP

NOP

Note:

;----- error routine -----	Error handling body

ERROR:	LD	A,E		;when in error, E holds error code CP	SYNERR		;syntax error ?

RET	NZ		;no



LD	HL,DATA1	;yes LOOP:	LD	A,(HL)		;put new error message CP	"$"

JR	Z,EXIT

PUSH	HL

CALL	CHPUT

POP	HL

INC	HL

JR	LOOP



EXIT:	JP	READYR		;BASIC hot start



DATA1:	DEFM	OOHPS!! 	;new error message DB	07H,07H,07H,"$"



END



=========================================================================





4.5 Interrupt usage




The Z80 CPU has INT and NMI interrupt terminals. The MSX, however, uses only INT. The INT terminal gets 60 [Hz] signals, so timer interrupts are executed 60 times per 1 second. As the interrupt mode of Z80 is set to 1, 38H is called when an interrupt occurs and then the system control jumps to the timer interrupt routine, where various operations such as key input are done.



The timer interrupt routine jumps to hook H.TIMI (FD9FH) in mid course. Using this hook enables the user to add a function to this timer interrupt routine.

Thogh there is ordinarily only a RET command, be careful when peripherals such as disks are connected and this hook is already in use. In this case, careless modifications causes peripherals to be disabled, so prearrangement is necessary to make machines to execute that normally. List 2.4 is an example of this handling and the interrupt usage.



List 2.4 Correct usage of timer interrupt hook =========================================================================



;*************************************************************

; List 2.4 How to use HOOK safety

;	 This routine uses TIMER INTERRUPT HOOK

;				 and turn on/off CAPS LOCK

;	 To start, do DEF USR=&HB000 : A=USR(0) ;	 To end,	 do DEF USR=&HB030 : A=USR(0) ;*************************************************************

;

CHGCAP	EQU	0132H		;CAPS LAMP on/off

CAPST	EQU	0FCABH		;CAPS LOCK status

TIMI	EQU	0FD9FH		;timer interrupt hook JPCODE	EQU	0C3H

TIMER	EQU	020H



ORG	0B000H



;----- interrupt on ----- Note: restore the former hook when changing the hook

INTON:	DI

LD	HL,TIMI 	;OLD HOOK SAVE

LD	DE,HKSAVE

LD	BC,5

LDIR



LD	A,JPCODE	;NEW HOOK SET

LD	(TIMI),A

LD	HL,INT

LD	(TIMI+1),HL

EI

RET



ORG	0B030H



;----- interrupt off ----- Note: restore the reserved hook and exit

INTOFF: DI

LD	HL,HKSAVE

LD	DE,TIMI

LD	BC,5

LDIR

EI

RET



;----- interrupt routine -----



INT:	PUSH	AF

LD	A,(CAPST)

OR	A

JR	Z,CAPON



CAPOFF: LD	A,(COUNT1)

DEC	A

LD	(COUNT1),A

JR	NZ,FIN

LD	A,TIMER

LD	(COUNT1),A

XOR	A

LD	(CAPST),A

LD	A,0FFH

CALL	CHGCAP

JR	FIN



CAPON:	LD	A,(COUNT2)

DEC	A

LD	(COUNT2),A

JR	NZ,FIN

LD	A,TIMER

LD	(COUNT2),A

LD	A,0FFH

LD	(CAPST),A

XOR	A

CALL	CHGCAP



FIN:	POP	AF

CALL	HKSAVE		;old HOOK call

RET



COUNT1: DEFB	TIMER

COUNT2: DEFB	TIMER



HKSAVE: NOP			;old HOOK save area

NOP

NOP

NOP

RET



END



=========================================================================





5. NOTES ON SOFTWARE DEVELOPMENT




There are some matters, when developing the software for MSX, that should be followed so as to make the software work without any problems on any MSX

machines. The following describes these matters and introduces information that will help you develop software.



* BIOS



The purpose of BIOS is to separate the hardware and the software and to make the software still valid if the hardware changes. Applications for sale which manage input and output should use BIOS (except for VDP).



BIOS is called through the jump table which begins at 0000H of MAIN-ROM.

Though MSX2 has a jump table on SUB-ROM, it is used for calling the extended functions. The branch destination of the jump table or, the contents of BIOS

may be modified for the hardware modification or the extension of the function, so applications should not call them directly. Thogh this book has some examples that call addresses other than the BIOS jump table, you should consider them for information only (see BIOS list in APPENDIX). Applications can call Math-Pack and internal routines for the extended statements described above. These will not be changed in the future.



* Work area



F380H to FFFFH of MAIN-RAM cannot be used, as it is a work area for BIOS and BASIC interpreter. Free space in the work area cannot be used, because it is reserved for the future use. See "3.1 User's area" for the work area of the disk.



* Initialisation of RAM and stack pointer

The contents of RAM are unpredictable when the machine is powered and areas other than system work are are not initialised. Applications should initialise the work area. There was once an application which expected the contents of RAM to be 00H and was unusable.



The value of the stack pointer when the INIT routine (see Section 7 of Chapter 5) in the ROM cartridge is called is unpredictable and the value when disk interface has been initialised is smaller than when not. For these reasons some programs which did not initialise the stack pointer had unpredictable results. Programs which are invoked by the INIT routine and continue processing (that is, programs which do not need to use peripherals such as disks or BASIC interpreter) should initialise the stack pointer.



* Work area of extended BIOS



When using extended BIOS calls, a stack should be placed above C000H so that CPU can refer to the work area even if the slot is switched over. For the same reason, FCB of RS-232C should be above 8000H.



* Work area of device drivers, etc.



Special attention should be paid for the allocation of the work area of programs which reside in memory with another program at the same time, programs such as the device driver or a subroutine called from BASIC.



The INIT routine of the cartridge changes BOTTOM (FC48H), reserves the area between the old BOTTOM and new BOTTOM as its work area, and records the address of the work area to 2-byte area SLTWRK (FD09H) allocated for each slot. For more details, see Section 7 of Chapter 5.



* Hook



When using the RS-232C cartridge, change the hook for an interrupt. For example, if another cartridge uses an interrupt hook, the RS-232C cartridge cannot use the same hook. To prevent this, the previous contents of the hook (inter-slot call command for the interrupt handling routine of RS-232C

cartridge, in the example above) should be copied to another location, and, when called by the hook, it should be called so that all cartridges intending to use the hook can receive control (see Figure 2.18). For more details, see Section 7 of Chapter 5.



Figure 2.18	Initialisation of the hook

Initialisation of the hook of program 1



------------- -------> -------------

| Hook | <---+ | Program 1 |

-------------	 +--- -------------



Initialisation of the hook of program 2



------------- -------> ------------- ---> -------------

| Hook | <---+ | Program 2 | ---+ | Program 1 |

-------------	 +--- ------------- <------- -------------



* VRAM capacity



The capacity of VRAM can be found by evaluating bits 1 and 2 of MODE (FAFCH) (see Table 2.22).



Table 2.22 Getting the information about the VRAM capacity

----------------------------------

| [FAFCH]	|		 |

|---------------| VRAM Capacity |

| Bit 2 | Bit 1 |		 |

|-------+-------+----------------|

| 0	| 0	| 16K (MSX1)	 |

| 0	| 1	| 64K (MSX2)	 |

| 1	| 0	| 128K (MSX2)	 |

----------------------------------



* BASIC version number



The following methods can be used for applications to find out the version number of BASIC.



1. Read the contents of 2DH of MAIN-ROM (00H = version 1.0, 01H = version 2.0, and so on).

2. In version 2.0 or later versions, EXBRSA (FAF8H) contains the slot address of SUB-ROM. When it has none (00H), the version is version 1.0.



* International MSX



There are different kinds of MSX for various countries. The following items are different by country:



- Keyboard arrangement, character set, PRINT USING format - Timer interrupt frequency



The version of machine can be found by reading the ID byte information in ROM

(see Figure 2.19) and the correspondence for MSX of each country will be accomplished (see Table 2.23).



Figure 2.19	Contents of ID byte

-------

| 2BH | b0 --+

------- 	| character generator

b1	|

| 0: Japan	1: United States, etc.

b2	| 2: USSR

|

b3 --+



b4 --+

| date format

b5	|

| 0:Y/M/D	1:M/D/Y 2:D/M/Y

b6 --+



b7	 interrupt period (VSYNC) 0:60Hz	1:50Hz



-------

| 2CH | b0 --+

------- 	| keyboard

b1	|

| 0:Japan	1:United States, etc.

b2	| 2:France	3:United Kingdom | 4:Germany	5:USSR		6:Spain b3 --+



b4 --+

|

b5	| information about PRINT USING

| or others

b6	|

|

b7 --+



Table 2.23 MSX format for each country

-----------------------------------------------------------------------------

|	 |		 |	 | 	 PRINT USING 	 |

|	 |		 | Date |-------------------------------------|

| Country |	 TV set |	 | Initial | String | Re- | Curren- |

|	 |		 | format | screen	 | length | place | cy	 |

|	 |		 |	 | mode	 | specif.| char. | symbol |

|-----------+--------------+----------+----------+--------+-------+---------|

| Japan | NTSC (60Hz) | YY/MM/DD | Screen 1 | &	 | @	 | (yen) |

| UK	 | PAL (50Hz) | DD/MM/YY | Screen 0 | \	 | &	 | (pound) |

| Internat. | PAL (50Hz) | MM/DD/YY | Screen 0 | \	 | &	 |$(dollar)|

| US	 | NTSC (60Hz) | MM/DD/YY | Screen 0 | \	 | &	 |$(dollar)|

| France | SECAM (50Hz) | DD/MM/YY | Screen 0 | \	 | &	 |$(dollar)|

| Germany | PAL (50Hz) | DD/MM/YY | Screen 0 | \	 | &	 |$(dollar)|

| USSR	 | NTSC (60Hz) | MM/DD/YY | Screen 0 | \	 | &	 |$(dollar)|

| Spain | PAL (50Hz) | MM/DD/YY | Screen 0 | \	 | &	 |$(dollar)|

-----------------------------------------------------------------------------



* Escape sequence



MSX has the escape sequence feature (see Appendix), which can be used in the PRINT statement of BASIC, and in console output of BIOS or BDOS call (MSX-DOS). The escape sequence feature is a subset of DEC VT52 terminal and Heathkit H19 terminal.



* Returning to BASIC



- Warm start



After selecting a slot of MAIN-ROM, jump to 409BH of MAIN-ROM. If the work area of BASIC has not been destroyed, the BASIC prompt will be displayed. The contents of register and stack at the jump are ignored.



Another way is to execute the next command in internal routine NEWSTT (see 4.4 of Chapter 4) (see Figure 2.20)



Figure 2.20	Input setting of NEWSTT for the warm start

3AH	81H 00H

----------------------

| : | END |	 |	 = (:END)

----------------------

^	 word

|	 stop

HL



* Auto start



In the case of simple game cartridges which do not use the BIOS or BASIC work areas, the program can be invoked by writing a starting address for the program to "INIT" in ROM header. But using this method prevents the initial settings of another cartridge, so disk drives cannot be used.



To prevent this, the hook "H.STKE" is at FEDAH; write the inter-slot call command in the program to be invoked at the execution on "INIT" routine of the cartridge, and return to the system by RET command. Then after initialising all cartridges and after preparing the DISK BASIC environment if there is a disk, the hook is called, so the objective program can be invoked.

This method is also effective when there is no disk (see APPENDIX).



Error code list



1. NEXT without FOR		There is no FOR statement corresponding with the NEXT statement.



2. Syntax error 		There is an error in syntax.



3. RETURN without GOSUB 	The RETURN statement does not correspond to the GOSUB statement.



4. Out of DATA			There is no data to be READ by the READ

statement.



5. Illegal function call	There is an error in the function or numeric value specification.



6. Overflow			The numeric value has overflow.



7. Out of memory		The free area has been exhausted.



8. Undefined line number	There is no such a line number in the program.



9. Subscript out of range	The subscript value of the array variable exceeds the declared range.



10. Redimensioned array 	The array is declared twice.



11. Division by zero		The attempt to divide by zero is made. The negative exponent of zero is done.



12. Illegal direct		The statement which cannot be executed in the direct mode is carried out directly.



13. Type mismatch		There is a conflict in the data types.



14. Out of string space 	The string space is exhausted.



15. String too long		The length of the string is longer than 255

characters.



16. String formula too complex	The specified string is too complex.



17. Can't CONTINUE The CONT command cannot be executed.



18. Undefined user function	An attempt was made to use the user-defined function which has not been defined by DEF FN statement.



19. Device I/O error		An error occurred in input/output of device.



20. Verify error		The program on cassette and the one in memory are not the same.



21. No RESUME			There is no RESUME statement in the error handling routine.



22. RESUME without error	The RESUME statement is used other than in the error handling routine.



23. Undefined.



24. Missing operand		Necessary parameters are not specified.



25. Line buffer overflow	There are too many characters for the input data.



26 to 49. Undefined.



50. FIELD overflow		The field size defined in FIELD statement exceeds 256 bytes.



51. Internal error		An error occurred inside BASIC.



52. Bad file number		File number which has not been OPENed is specified. The specified file number exceeds the number specified in MAXFILES statement.



53. File not found		The specified file is not found.



54. File already open		The file has already been OPENed.



55. Input past end		The attempt to read the file is made after reading the end of it.



56. Bad file name		There is an error in the specification of the file name.



57. Direct statement		Data other than the program is found while loading the ASCII format program.



58. Sequential I/O only 	Random access to the sequential file is made.



59. File not OPEN		The specified file has not been OPENed yet.



60. Bad FAT			Unusual disk format.



61. Bad file mode		An incorrect input/output operation is made in the OPENed mode.



62. Bad drive name		There is an error in the drive name specification.



63. Bad sector number		There is an error in the sector number.



64. File still open		The file has not been closed.



65. File already exists 	The file name specified in NAME statement already exists on the disk.



66. Disk full			The free area of the disk has been exhausted.



67. Too many files		The number of files exceeds 112 (the directory space has been exhausted).



68. Disk write protected	The disk is protected from writing.



69. Disk I/O error		Some trouble occurred in the disk input/output.



70. Disk offline		The diskette is not in.



71. Rename accross disk 	NAME statement is done across different disks.



72. File write protected	The file has the read-only attribute set.



73. Directory already exists	The directory name specified in CALL MKDIR

statement already exists.



74. Directory not found 	The specified directory is not found.



75. RAM disk already exists	Attempt to create the DOS 2 RAM disk when it already exists is made.



76 to 255. Undefined.



* Note: Errors with codes 72 to 75 are added from version 2 of MSX

DISK-BASIC. In version 1 they are undefined.



Use larger numbers first for user error definition.





MSX2 TECHNICAL HANDBOOK

-----------------------



Edited by:		ASCII Systems Division

Published by:		ASCII Coprporation - JAPAN

First edition:		March 1987

<i>

Text files typed by:	Nestor Soriano (Konami Man) - SPAIN

March 1997



Changes from the original:



- Remarks (1) and (2) about the FCB format in version 2 of MSX-DOS have been added.



- Description of function call 06H is modified. The name of this function in the original text is "String output", and the setup description is "E

register <-- starting address of string to send to the console. When 0FF is specified, the character will be sent to the console as character code."



- In description of function calls 13H (Deleting files) and 23H (File size acquisition), the original text has "DE register <-- starting address of opened FCB" in setup field. Instead of this, the correct setup explanation is set.



- In description of function 26H (Random writing to the disk 2), the correct term "FCB" is set instead of "DMA" in DE register setup explanation.



- In description of function 27H (Random readout 2), the phrase "When this number is almost one, the data which has been read is set in the area indicated by DMA" has been added.

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-





CHAPTER 3 - MSX-DOS




Large capacity storage devices with high-speed access are necessary for business applications. That is why a disk operating system was added to the MSX machine. The DOS (disk operating system) is also required to handle the large amount of data on the disk effectively. MSX-DOS is derived from MS-DOS

which is used widely on 16-bit machines. Thus, it represents the most powerful DOS environment for Z-80 based machines. Chapter 3 describes the basic operations of MSX-DOS and the use of the system calls.





1. OVERVIEW




What kind of software is MSX-DOS? What does it offer to users? The following sections describe and introduce the features, functions, and software configurations of MSX-DOS.





1.1 Features of MSX-DOS




* Consolidation of disk operating environment

MSX-DOS is the disk operating system for MSX computers. It works with any version of MSX and can be operated on both the MSX1 and MSX2 without any problem. Disk operation on MSX is always done via MSX-DOS. This is also true concerning MSX DISK-BASIC, which uses BDOS calls for disk input/output.

MSX-DOS and DISK-BASIC use the same disk format so that file conversion between BASIC and DOS is not necessary. This greatly increases operating efficiency and allows more effective use of file resources when MSX-DOS is used as the software development environment.



* Compatibility with MS-DOS



MSX-DOS, created on the basis of MSX-DOS (ver 1.25) which is a disk operating system for 16-bit personal computers, uses the same file format as MS-DOS. It is compatible with MS-DOS at the file level so that MSX-DOS can read and write files written on MS-DOS disks. In turn MS-DOS can read and write files created by MSX-DOS. Both disk operating systems use similar commands, so users who are familiar with MSX-DOS can easily use MS-DOS when upgrading to 16-bit machines.



* Using CP/M applications



MSX-DOS has system call compatibility with CP/M and can execute most programs created on CP/M without any modification. Most CP/M applications can thus be easily used with MSX-DOS. This opens up a large library of existing software which can be run on the MSX machines.





1.2 MSX-DOS Environment




* System requirements



To use MSX-DOS, a minimum configuration of 64K bytes RAM, a CRT, one disk drive, and a disk interface ROM is required. If less than 64K bytes RAM is installed, MSX-DOS cannot be used. MSX computers can only use MSX-DOS if they have 64K bytes RAM or more. Since MSX2 computers always have 64K bytes or more of RAM, they can always run MSX-DOS. A limited disk basic is used on those machines with less than 64K bytes RAM. Disk interface ROM is always supplied with the disk drive, and, on MSX machines with an internal disk drive, it resides inside the machine. For those machines using disk cartridges, it is in the cartridge.



* System supported



MSX-DOS supports up to eight disk drives. On a one-drive system, it has a 2-drive simulation feature (it uses one drive as two drives by replacing diskettes temporarily). It supports keyboard input, screen output, and printer output.



* Media supported



MSX-DOS, which has a flexible file manager that does not depend on the physical structure of the disk, supports various media and uses 3.5 inch double density disks as standard. Either a one-sided disk called 1DD or two-sided disk called 2DD is used. Each of them uses either an 8-sector track format so four kinds of media can be used. The Microsoft formats for these four types are shown below.



Table 3.1 Media supported by MSX-DOS



----------------------------------------------------------------------

|			 | 1DD, 9 | 2DD, 9 | 1DD, 8 | 2DD, 8 |

|			 | sectors | sectors | sectors | sectors |

|----------------------------+---------+---------+---------+---------|

| media ID		 |	0F8H | 0F9H	 | 0FAH | 0FBH |

| number of sides	 |	 1 | 2	 | 1 |	2 |

| tracks per side	 |	 80 | 80	 | 80 | 80 |

| sectors per track	 |	 9 | 9	 | 8 |	8 |

| bytes per sector	 |	 512 | 512	 | 512 | 512 |

| cluster size (in sectors) |	 2 | 2	 | 2 |	2 |

| FAT size (in sectors) |	 2 | 3	 | 1 |	2 |

| number of FATs	 |	 2 | 2	 | 2 |	2 |

| number of recordable files |	 112 | 112	 | 112 | 112 |

----------------------------------------------------------------------



Note: See chapter 3 for the meanings of the above words.





1.3 MSX-DOS System Resources




* Memory map



MSX-DOS consists of the following modules: COMMAND.COM, MSXDOS.SYS, and a disk interface ROM. It resides in memory as shown in Figure 3.1 when MSX-DOS

is active. COMMAND.COM and MSXDOS.SYS are disk files until MSX-DOS is booted and then read into RAM after that. Disk interface ROM includes a disk driver, DOS kernel, and DISK-BASIC interpreter.



Figure 3.1 MSX-DOS memory map

0000H	-----------------------

| system scratch area |

0100H	|---------------------| ---	 4000H ---------------------

|		 | ^		 |	disk driver |

|		 | |		 |	DOS kernel |

|		 | |		 |	DISK BASIC |

|		 | |		 |	interpreter |

|		 | TPA	 7FFFH ---------------------

|		 | |

|		 | |		 disk interface ROM

|---------------------| |

| COMMAND.COM | V

(0006H) |---------------------| ---

| MSXDOS.SYS |

|---------------------|

| work area |

FFFFH	-----------------------



The area 00H to FFH of RAM is called the system scratch area, which is used by MSX-DOS for exchanging data with other programs. This area is important when using system calls, which are described later. The area which begins at 0100H and ends where the contents of 0006H of RAM indicates is calles the TPA (Transient Program Area). This area is accessible by the user. MSXDOS.SYS

always resides at a higher address than TPA (when destroyed, the result is unpredictable), and COMMAND.COM is placed in TPA.



* COMMAND.COM



The main operation of MSX-DOS is to accept typing commands from the keyboard and execute them. In this case the program COMMAND.COM is responsible for the process from getting a string to interpreting and executing it, or accepting commands from the user interface. Programs executed by COMMAND.COM consists of internal commands, batch commands, and external commands.



Internal commands are inside COMMAND.COM and on RAM. Typing an internal acommand causes COMMAND.COM to call and execute it immediately.



For the external command, COMMAND.COM loads the routine from disk to TPA and executes it (the execution of external commands always begins at 100H). In this case COMMAND.COM frees its own area for the external command. That is, COMMAND.COM might erase itself and writes the external command onto it, when the external command is small enough and does not use the high-end of TPA, COMMAND.COM would not be destroyed. When the external command ends with "RET", MSXDOS.SYS examines whether COMMAND.COM has been destroyed (by using checksum) and, if so, re-loads COMMAND.COM onto RAM and passes the control to COMMAND.COM.



Batch commands are carried out by getting command line input from a batch file instead of from the keyboard. Each step of the batch file can execute any internal command or external command. It is possible that the batch command executes another batch command, but the control will not return to the caller after the called batch command is done.



* MSXDOS.SYS



MSXDOS.SYS, core of MSX-DOS, controls disk access and communications with peripherals. These MSXDOS.SYS functions are opened as "BDOS (Basic Disk Operating System)" so that the user can use them. Each routine opened is called a "system call", which is useful in developping software for managing the disk (see chapter 4). Each execution is, however, not done by MSXDOS.SYS

itself but DOS kernel. MSXDOS.SYS is an intermediation which arranges input/output requests from COMMAND.COM or external commands and passes them to the DOS kernel.



MSXDOS.SYS includes a portion called BIOS other than BDOS, as shown in Figure 3.2. BIOS, which has been prepared to be compatible with CP/M, is not normally used.



Figure 3.2 MSXDOS.SYS



-------------- --+

| BDOS |	 |

|------------|	 | MSXDOS.SYS

| BIOS |	 |

-------------- --+



* DOS kernel



The DOS kernel is the fundamental input/output routine which resides in the disk interface ROM and executes BDOS functions of MSXDOS.SYS. Actually, any system call function can be executed using the DOS kernel. DISK-BASIC

executes system calls by calling the DOS kernel directly.



* Procedure for invoking MSX-DOS



MSX-DOS is invoked by the following procedure:

1. Resetting MSX causes all the slots to be examined first, and when two bytes, 41H and 42H, are written in the top of the examined slot, the slot is interpreted as connected to a certain ROM. When connected with ROM, the INIT

(initialize) routine whose address is set to the header portion of ROM is carried out. In the case of the INIT routine of the disk interface ROM, the work area for the drive connected to the interface is allocated first.



2. When all slots have been examined, FEDAH (H.STKE) is then referred to.

Unless the contents of this address is C9H (unless a certain routine is set to the hook of H.STKE during INIT routine), the environment for DISK-BASIC is prepared and execution jumps to H.STKE.



3. When the contents of H.STKE is C9H in the examination above, the cartridge with TEXT entry is searched in each slot and, if found, the environment for DISK-BASIC is prepared, and then the BASIC program at the cartridge is carried out.



4. Then, the contents of the boot sector (logical sector #0) is transferred to C000H to C0FFH. At this time, when "DRIVE NOT READY" or "READ ERROR"

occurs, or when the top of the transferred sector is neither EBH nor E9H, DISK-BASIC is invoked.



5. The routine at C01EH is called with CY flag reset. Normally, since code "RET NC" is written to this address, nothing is carried and the execution returns. Any boot program written here in assembly language is invoked automatically.



6. RAM capacity is examined (contents of RAM will not be destroyed). Less than 64K bytes causes DISK-BASIC to be invoked.



7. The environment for MSX-DOS is prepared and C01EH is called with a CY flag set. MSXDOS.SYS is loaded from 100H, and the execution jumps to 100H. After this, MSX-DOS transfers itself to a high order address. If MSXDOS.SYS does not exist, DISK-BASIC is invoked.



8. MSXDOS.SYS loads COMMAND.COM from 100H and jumps to its start address.

COMMAND.COM also transfers itself to a high order address and then begins to execute. If COMMAND.COM does not exist, the message "INSERT A DISKETTE"

appears and the execution waits for the correct diskette to be inserted in the drive.



9. At the first boot for MSX-DOS, when a file named "AUTOEXEC.BAT" exists, it is carried out as a batch file. When MSX-DOS is not invoked and DISK-BASIC

starts, if a BASIC program named "AUTOEXEC.BAS" exists, it will be carried out.





2. OPERATION




This section describes how to type command line input from the keyboard. This is the basis of MSX-DOS operations. Several examples of actual use and their explanations will be given for the commands used in MSX-DOS.





2.1 Basic Operations




* Message at startup



When MSX-DOS is invoked, the following message appears on the screen:

Figure 3.3 Screen at atartup

-----------------------------------

|				 |

| MSX-DOS version 1.03	 |

| Copyright 1984 by Microsoft |

|				 |

| COMMAND version 1.11	 |

|				 |

-----------------------------------



The upper two lines show the version of MSXDOS.SYS and its copyright. The last line shows the version of COMMAND.COM.



* Prompt



Then, a prompt (input request symbol) appears under the version description.

The prompt for MSX-DOS consists of two characters: the default drive name plus ">".



* Default drive



The term "default drive" as the first character of the prompt is the drive to be accessed automatically when the drive name is omitted. When the default drive is A, for example, referring to a file "BEE" on drive "B" needs to be typed as "B:BEE". A file "ACE" on drive A, however, can be typed simply as "ACE" omitting the drive name.



ex.1) A>DIR B:BEE	 (<-- referring to "BEE" on drive B) ex.2) A>DIR ACE	 (<-- referring to "ACE" on drive A)

* Changing default drive



When using systems with more than one drive, typing "B" causes the default drive to be changed to B. When changing the default drive to C to H, "C" or the appropiate letter is needed. Specfification of a drive which does not exist causes an error.



ex.1) A>B:

B>	(<-- Default drive has been changed to B)

ex.2) A>K:

Invalid Drive Specification A>	(<-- Drive K does not exist.

Default drive is not changed.)

* Command input



When a prompt is displayed it indicates that MSX-DOS requests a command to be input. By typing in a command, MSX-DOS can get an instruction.



Three forms of commands exist as shown in Table 3.2. The COMMAND.COM program interprets and executes these commands. MSX-DOS operations are repeats of the actions "give a command - make COMMAND.COM execute it".



Table 3.2 Three forms of commands

-------------------------------------------------------------------------

| (1) Internal | Command inside COMMAND.COM. Assembly routine on RAM.	|

| command | Thirten commands are prepared as described later.	|

|--------------+--------------------------------------------------------|

| (2) External | Assembly routine on disk. It is loaded from disk at	|

| command | execution. Its file name has an extension "COM". |

|--------------+--------------------------------------------------------|

| (3) Batch | Text file containing one or more commands. Commands	|

| command | are executed orderly (batch operation). File names	|

|	 | have the extension "BAT". |

-------------------------------------------------------------------------



* File name convention



Files handled by MSX-DOS are expressed by a "file spec" which is described below:



(1) File spec is expressed in the form "<drive>:<file name>".



(2) <drive> is a character from A to H. When specifying the default drive, it can be omitted as well as the colon ":" following it.



(3) <file name> is expressed in the form of "<filename>.<extension>".



(4) <filename> is a string containing one or more (up to 8) characters. When more than 8 characters are sepcified, the ninth and subsequent characters are ignored.



(5) <extension> is a string containing up to 3 (including zero) characters.

When more than 3 characters are specified, 4th and subsequent chartacters are ignored.



(6) <extension> can be omitted as well a preceding period ".".



(7) Characters which are available in <filename> and <extension> are shown in Table 3.3.



(8) Cases are not sensitive. Capital letters and small letters have the same meaning.



Table 3.3 Available characters for file name

---------------------------------------------------------------------------

| Available | A to Z	 0 to 9 $ &	# % (	) - @ ^ { } ' ` ! |

| characters | characters corresponding to character codes 80H to FEH |

|-------------+-----------------------------------------------------------|

| Unavailable | ~ * + , .	/ : ; = ? [ ]			 |

| characters | characters corresponding to character codes 00H to 20H |

|	 | and 7FH, FFH						 |

---------------------------------------------------------------------------



* Wildcards



Using a special character called a "wildcard" in the description of <filename> and <extension> of the file specification causes files with common characters to be specified. Wildcards are "?" and "*".



(1) "?" is a substitution for one character.

ex) "TEXT", "TEST", "TENT" <-- "TE?T"

"F1-2.COM", "F2-6.COM" <-- "F?-?.COM"



(2) "*" is a substitution for a string with any length.

ex) "A", "AB", "ABC" <-- "A*"

"files with an extension .COM" <-- "*.COM"

"all files" <-- "*.*"



When comparing existing file names and file names with wildcards, the portion less than 8 characters of <filename> and the portion less than 3 characters of <extension> are considered to be padded with spaces (" "). Thus, a specification "A???.??" is not expanded to "ABCDE.123" but to "AZ.9", as shown in Figure 3.4.



Figure 3.4 Wildcard expansion

--------------------------------- -------------

ABCDE.123 --> | A | B | C | D | E | | | | | 1 | 2 | 3 |

--------------------------------- -------------

^ ^	^ ^	^ ^	^ ^	 ^	^ ^

| |	| |	| |	| |	 |	| |

O O	O O	X O	O O	 O	O X

| |	| |	| |	| |	 |	| |

V V	V V	V V	V V	 V	V V

--------------------------------- -------------

A???.?? --> | A | ? | ? | ? | | | | | | ? | ? | |

--------------------------------- -------------

^ ^	^ ^	^ ^	^ ^	 ^	^ ^

| |	| |	| |	| |	 |	| |

O O	O O	O O	O O	 O	O O

| |	| |	| |	| |	 |	| |

V V	V V	V V	V V	 V	V V

--------------------------------- -------------

AZ.9 --> | A | Z | | | | | | | | 9 | | |

--------------------------------- -------------



An asterisk (*) is interpreted as either 8 question marks or 3 question marks (?) depending on if it is in the file name position or file extension position. For example, a file name "A*B" is not interpreted as "any strings which begin with A and end with B". It is interpreted as "any strings which begin with A", as shown below.



A*B		("*" is expanded to 8 "?"s) |

V

A????????B	(Characters after 8th are deleted) |

V

A???????



* Device name



MSX-DOS does not need special commands for data input/output with peripherals. This means that it considers each objective device as a certain file (device file) and input/output actions are done by reading or writing to or from this file. This enables MSX-DOS users to treat input/output devices in the same way as files on a disk. Five devices are supported as standard by MSX-DOS as shown in Table 3.4 and are specified with proper names. For this reason, these names can not be used to specify disk files. These device names with drive specifications or extensions are also treated as simple device names.



Table 3.4 Device names

--------------------------------------------------------------------------

| Device name | 	 Input/output device to be specified		 |

|-------------+----------------------------------------------------------|

|	 | Reserved name for input/output expansion		 |

| AUX | which normally has the same effect as NUL		 |

|	 | 							 |

|-------------+----------------------------------------------------------|

|	 | 							 |

| CON | Console (keyboard for input, screen for OUTPUT)	 |

|	 | 							 |

|-------------+----------------------------------------------------------|

|	 | 							 |

| LST | Printer (ouput only; cannot be used for input) 	 |

|	 | 							 |

|-------------+----------------------------------------------------------|

|	 | 							 |

| PRN | Printer (same as LST)					 |

|	 | 							 |

|-------------+----------------------------------------------------------|

|	 | Special device used as a dummy when the result is not	 |

| NUL | desired to be displayed on the screen or put in a file. |

|	 | When used for input, always EOF.			 |

--------------------------------------------------------------------------



* Input functions using a template



A "template" is a character buffer area and can be used for command input.

The template contains the previous command line most recently entered. It is possible to use the template for easier command entry. By taking advantage of this template feature, it is easy to execute previous commands again or to execute the command partially modified. The keys listed in Table 3.6 are used for the template operation.



* Other special keys



In addition to the template operation keys, the following control keys are also available. These special key functions also support some other system calls described later.



Table 3.5 Special key functions

---------------------------------------------------------------

|	|		 Function 		 |

|-------+-----------------------------------------------------|

| ^C	| stops command currently executed		 |

| ^S	| pauses screen output until any key is pressed |

| ^P	| send characters to the printer at the same time |

|	|	they appear on the secreen		 |

| ^N	| resets ^P and send characters only to the secreen |

| ^J	| feeds a line on the screen and continue input |

---------------------------------------------------------------



Table 3.6 Template functions

-------------------------------------------------------------------------

| Name | Keys used |		 Functions			|

|----------+--------------+---------------------------------------------|

| COPY1 | RIGHT, ^\	 | Gets one character from the template and	|

|	 |		 | displays it in the command line		|

|----------+--------------+---------------------------------------------|

|	 |		 | Gets characters before the character to be	|

| COPYUP | SELECT, ^X | typed next (by keyboard) from the template	|

|	 |		 | and displays them on the command line	|

|----------+--------------+---------------------------------------------|

|	 |		 | Gets all characters from the location which |

| COPYALL | DOWN, ^_	 | the template is currently referring to the	|

|	 |		 | end of the line and displays them on the	|

|	 |		 | command line				|

|----------+--------------+---------------------------------------------|

| SKIP1 | DEL	 | Skips one character of the template 	|

|----------+--------------+---------------------------------------------|

| SKIPUP | CLS, ^L	 | Skips template characters before the	|

|	 |		 | character to be typed next (by keyboard)	|

|----------+--------------+---------------------------------------------|

| VOID	 | UP, ESC, ^^, | Discards current line input not changing	|

|	 | ^U, ^[	 | the template				|

|----------+--------------+---------------------------------------------|

|	 |		 | Discards one character input and returns	|

| BS	 | LEFT, BS,	 | the location referred by the template	|

|	 | ^H, ^]	 | by one character				|

|----------+--------------+---------------------------------------------|

|	 |		 | Switches insert mode/normal input mode,	|

| INSERT | INS, ^R	 | in insert mode, displays keyboard input	|

|	 |		 | on the command line with fixing the 	|

|	 |		 | location referred by the template		|

|----------+--------------+---------------------------------------------|

| NEWLINE | HOME, ^K	 | Transfers the contents of current command	|

|	 |		 | line to the template			|

|-------------------------+---------------------------------------------|

|			 | Feeds a line on screen but continues	|

|	 Return	 | getting input. Transfers the contents of	|

|	 key		 | current command line to the template	|

|			 | and executes it				|

|-------------------------+---------------------------------------------|

|	 Keys other	 | Displays a character corresponding to the	|

|	 than above	 | key on the command line and skips one	|

|			 | character of the template			|

-------------------------------------------------------------------------



Table 3.7 Template operation examples

---------------------------------------------------------------------------

|		 |			 | Contents of template ("-" |

| Keyboard input | Command line display | indicates location currently |

|		 |			 | referred to)		 |

|-------------------+----------------------+------------------------------|

| DIR ABCDE	 | A>DIR ABCDE	 | ---------			 |

|		 |			 |				 |

| RETURN	 | A>		 | DIR ABCDE			 |

|		 |			 | -				 |

| DOWN		 | A>DIR ABCDE	 | DIR ABCDE			 |

|		 |			 |	 - 		 |

| LEFT LEFT LEFT | A>DIR AB		 | DIR ABCDE			 |

|		 |			 |	 -			 |

| INS XYZ	 | A>DIR ABXYZ	 | DIR ABCDE			 |

|		 |			 |	 -			 |

| RIGHT RIGHT RIGHT | A>DIR ABXYZCDE	 | DIR ABCDE			 |

|		 |			 |	 - 		 |

| UP		 | A>		 | DIR ABCDE			 |

|		 |			 | -				 |

| DOWN		 | A>DIR ABCDE	 | DIR ABCDE			 |

|		 |			 |	 - 		 |

| UP		 | A>		 | DIR ABCDE			 |

|		 |			 | -				 |

| XXX		 | A>XXX		 | DIR ABCDE			 |

|		 |			 |	-			 |

| DOWN		 | A>XXX ABCDE	 | DIR ABCDE			 |

|		 |			 |	 - 		 |

| HOME		 | A>XXX ABCDE	 | XXX ABCDE			 |

|		 |			 | -				 |

---------------------------------------------------------------------------



* Disk errors



When an error occurs during disk access, MSX-DOS retries sometimes. Still more errors cause MSX-DOS to display the following message and inquire what to do with them. Press one of the keys A, R, or I.



Figure 3.5 Error display

-----------------------------------------------------------------------

|								 |

|	<error type> error <action> drive <drive name>	 |

|	------------	 -------- 	 ------------	 |

|	 |			 |			|	 |

| ----------------- -----------	 ----------	 |

| | Write protect | | Reading |	 | A to H |	 |

| | Not ready | | Writing |	 ----------	 |

| | Disk	 | -----------			 |

| ----------------- 					 |

|								 |

|	Abort, Retry, Ignore?					 |

|								 |

|---------------------------------------------------------------------|

|								 |

| Abort: stops the disk access and ends the command execution |

| Retry: tries again						 |

| Ignore: stops the disk access and continues the command execution |

|								 |

-----------------------------------------------------------------------



The following error might occur other than listed above. It indicates that the pointer in FAT is pointing to a cluster which does not exist. When this error occurs, the diskette will be unusable.



Bad FAT





2.2 Internal commands




Internal commands are assembly language programs grouped together in COMMAND.COM. It is not necessary to read them from the disk so they are executed fast. Following are 13 internal commands. This section describes their use.



BASIC ........... jumps to MSX DISK-BASIC

COPY ............ copies a file DATE ............ displays or modifies date DEL ............. deletes a files DIR ............. displays a list of files FORMAT .......... formats a disk MODE ............ modifies number of characters to be displayed in one line

PAUSE ........... pauses a batch command operation REM ............. puts a comment line in a batch command REN ............. renames a file name TIME ............ displays or modifies time TYPE ............ prints the contents of a file VERIFY .......... turns on/off the verify mode

* BASIC



form:	BASIC [<file spec>]



Starts DISK-BASIC. This is not done by loading BASIC onto RAM but by selecting BASIC-ROM in 0000H to 7FFFH by switching the slot, so it starts immediately. When <file spec> is specified, the corresponding BASIC program is automatically read and executed. To return to the MSX-DOS environment from BASIC, execute "CALL SYSTEM".



* COPY



This command copies the contents of one file to another. Specifying parameters enables various options.



(1) File duplication



form	COPY <file spec 1> <file spec 2>

Duplicates the file specified by <file spec 1> into a file specified by <file spec 2>. Files having the same names cannot be created on the same disk. On different disks, specifying the same names is possible.



examples:



A>COPY ABC XYZ	<-- copies file "ABC" and makes a file "XYZ".



A>COPY B:ABC XYZ	<-- copies a file "ABC" on drive B and makes a file "XYZ".



A>COPY B:ABC C:XYZ	<-- copies a file "ABC" on drive B and makes a file "XYZ" on drive C.



When copying files, either ASCII or binary mode may be selected. The "/A"

swith specifies ASCII mode and the "/B" switch specifies binary mode. If no mode is specified, binary mode is selected by default (except when combining files, described in (4) below, when ASCII is the default mode). Table 3.8

shows the differences between the ASCII and the binary modes.



Table 3.8 ASCII mode and binary mode

-----------------------------------------------------------------------------

|	 |	 Read from source file	| Write to destination file |

|-----------+-----------------------------------+---------------------------|

|ASCII mode | ignore after 1AH (file end mark)	| add one byte 1AH to end |

|Binary mode| read as long as physical file size| write without modification|

-----------------------------------------------------------------------------



examples:



A>COPY/A ABC XYZ	<-- ABC to XYZ (both files are in ASCII mode)

A>COPY ABC/A XYZ/B	<-- reads ABC in ASCII mode and writes it to XYZ

in binary mode



(2) File duplication to another disk drive

form	COPY <file spec> [<destination drive>:]



Copies a file specified by <file spec> to <destination drive> under the same file name. When <destination drive> is omitted, it is copied to the default drive. The drive name included in the <file spec> must not be the same as the <destination drive>.



More than one file can be copied by using wildcards in the <file spec>. In this case, the file name is displayed on the screen each time the file is copied.



examples:



A>COPY *.COM B:	<-- copies any files with extension "COM"

on default drive to drive B



A>COPY B:ABC 	<-- copies a file ABC to default drive

(3) Simultaneous duplication of many files

form	COPY <file spec 1> <file spec 2> ------------- -------------

|		 |

wildcard description wildcard description

When <file spec 2>, the destination, is described using wildcards, the portions corresponding to wildcards are replaced with corresponding characters in <file spec 1>. For example, when

COPY AB-07.021 FL?X*.V??



is executed, it is interpreted as shown in figure 3.6 and a file "FL-X7.V21"

is created.



Figure 3.6 Wildcard specification of destination file

--------------------------------- -------------

| F | L | ? | X | ? | ? | ? | ? | | V | ? | ? | <file spec 2> --------------------------------- -------------

| | | 		 |

V V V 		 V

--------------------------------- ------------- Only wildcard portion | F | L | - | X | 7 |	| |	| | V | 2 | 1 | is replaced with --------------------------------- ------------- <file spec 1> ^	 ^ ^ ^ ^ 	 ^ ^

|	 | | | | 	 | |

--------------------------------- -------------

| A | B | - | 0 | 7 |	| |	| | 0 | 2 | 1 | <file spec 1> --------------------------------- -------------



Using wildcards in the specification of <file spec 1> enables the duplication of many files at the same time.



examples:



A>COPY *.ASM *.MAC		<-- makes files with extension "MAC" from any files with extension "ASM"



A>COPY A*.* B:Z*.*		<-- Any files beginning with the character A are copied to files beginning with the character Z on drive B



(4) File concatenation



form	COPY <multiple file spec> <file name> --------------------

|

wildcard specification, or multiple file spec connected by "+"



When one destination file receives more than one source file, the contents of all source files are concatenated and stored to the specified destination file. When specifying more than one source file, wildcards are available, and file specs can also be copied by using the plus sign.



When files are concatenated, ASCII mode is selected by default and 1AH is considered the file end mark. Thus, concatenating binary files including data 1AH by the COPY command causes data after 1AH to be discarded. To prevent this, specify /B switch and use COPY command in binary mode.



If more than one wildcard appears in the specification of source files, the second wildcard and after are expanded referring to original file names, as in paragraph (3) above. This permits concatenation of similar files at the same time.



examples:



A>COPY X+Y+Z XYZ		<-- concatenates X, Y, AND Z and stores in a file XYZ



A>COPY *.LST ALL		<-- concatenates any files with extension "LST" and stores in a file ALL



A>COPY /B *.DAT ALL		<-- concatenates any ".DAT" files in binary mode



A>COPY ASC/A+BIN/B AB/B	<-- concatenates an ASCII file ASC and a binary file BIN and stores in a file AB



A>COPY *.LST+*.REF *.PRN	<-- concatenates files named same with extension "LST" and extension "REF"

and makes a file with extension "PRN"



* DATE



form	DATE [<month>-<day>-<year>]

-	 -

|	 |

-------

|

"/" and "." are also allowed.



Sets the date in the internal CLOCK-IC. For MSX machines without a CLOCK-IC, it is written to the specific work area. Creations or modifications of files on MSX-DOS cause this date information to be recorded for each file.



When the DATE command is executed without specifying <month>/<day>/<year>, the date currently set is displayed with a request for a new date as shown below. Pressing only the RETURN key here leaves the date unchanged.



Current date is <day of week> <month>-<day>-<year> Enter new date:



The format of the date to be set by the DATE command has three fields: <year>, <month>, and <day>. Each field is separated by "-", "/", or ".". Each field can have the following numerical values:

<year>: 	1980 to 2079

0 to 79 (considered as 2000 to 2079) 80 to 99 (considered as 1980 to 1999) <month>:	1 to 12

<day>:		1 to 31



Foreign versions of MSX-DOS have different date formats: <month>-<day>-<year> or <day>-<month>-<year>.



* DEL



form	DEL <file spec>

ERASE is also allowed

Deletes the specified file. Wildcards can be used to specify more than one files.



Since "DEL *.*" causes all files on the diskette to be deleted, in this case, an acknowledgement is required.



A>DEL *.*

Are you sure (Y/N)?



Pressing "Y" or "y" causes all files to be deleted.



"ERASE" may be used the same way as the DEL command.



* DIR



form	DIR [<file spec>] [/W] [/P]



The following information about the specified at <file spec> is listed from the left side in one line.



<file name> <file size> <date> <time>

The fields <date> and <time> show when the file was created or last modified. When this information is longer than one line, items displayed near the right side are omitted.



In addition to the usual wildcards, the following abbreviations for <file spec> can be used.



Abbreviation			Formal notation

DIR			=	DIR *.*

DIR <drive>:		=	DIR <drive>:*.*

DIR <filename>		=	DIR <filename>.*

DIR .<extension>	=	DIR *.<extension>

When the /W switch is specified, only <filename>s are padded to one line.

When the /P switch is specified, the listing is stopped after each display page to wait for any key input.



examples:



A>DIR		<-- displays information for all files on drive A

A>DIR B:		<-- displays information for all files on drive B



A>DIR TEST		<-- displays information for all files having <filename> "TEST"



A>DIR /W		<-- displays all file names of drive A

* FORMAT



form	FORMAT



Formats a diskette in MSX-DOS format. In other words, directories and FAT are initialised and any files are erased. Since MSX-DOS has the same disk format as MS-DOS, the formatted diskette is also read or written by MS-DOS.



When executing the FORMAT command, an inquiry

Drive name? (A,B)	(<-- Depends on number of drives)

is made for the name of the drive containing a disk to be formatted.

Answering "A" or "B" causes the menu to be displayed when a drive that can select one-sided and two-sided formats is being used. After specifying the type of format,



Strike a key when ready

is displayed to wait for a key input. Pressing any key starts formatting. See the disk drive manual for the format menu.



* MODE



form	MODE <characters per line>



Sets the number of characters to be displayed in one line on the screen.

<characters per line> can have a value from 1 to 80 and the screen mode depends on that value:



<characters per line>		Screen mode 1 to 32 		GRAPHIC 1 (SCREEN 1) 33 to 40 		TEXT 1 (SCREEN 0:WIDTH 40) 41 to 80 		TEXT 2 (SCREEN 0:WIDTH 80)

* PAUSE



form	PAUSE [<comment>]



MSX-DOS has a "batch operation" feature which automatically executes a series of commands written in a text file. During the batch operation, you may want to stop command execution temporarily. One example would be for the user to exchange disks. PAUSE can be used in such cases.



When this command is executed,



Strike a key when ready...



is displayed and a key input is expected. Pressing any key other than Ctrl-C

here ends the PAUSE command and proceeds to the next one. Pressing CTRL-C

abandons the batch operation. Any kind of comments can follow "PAUSE". This makes it possible to display the purpose of the request for the key input.



* REM



form	REM [<comment>]



REM is used to write a comment in the batch command. It does nothing as a command. A space between "REM" and <comment> is required.



* REN



form	REN <file spec> <file name> RENAME is also allowed

REN changes the file name specified by <file spec>. Wildcards can be used in both <file spec> and <file name>. Specifying wildcards for <file name> causes these wildcards to be replaced with corresponding characters of the <file spec> (see COPY command).



Any attempt to change a file name to a name already in use will cause an error.



examples:



A>REN ABC XYZ <-- changes the file name "ABC" to "XYZ"



A>REN B:ABC XYZ <-- changes the file name "ABC" on drive B to "XYZ"



A>REN *.BIN *.COM <-- changes any files with the extension "BIN" to "COM"



* TIME



form	TIME [<hour>[:<minute>[:<second>]]]



TIME sets the time for the internal CLOCK-IC. Nothing happens to machines that do not have a CLOCK-IC. When a file is created on MSX-DOS, time information set here is recorded for each file.



Executing the TIME command without specifying the time causes the current time setting to be displayed as shown below. Then there is an input request for a new time. Pressing only the RETURN key does not change the time.



Current time is <hour>:<minute>:<second>:<second/100><p or a> Enter new time:



The punctuation mark ":" separates the three TIME command fields of <hour>, <minute>, and <second>. Fields after <minute> or <second> may be omitted or considered to be 0. Each field can have the following values:

<hour>: 0 to 23

12A		 (represents midnight) 0A to 11A	 (represents midnight to 11 o'clock in the morning) 12P		 (represents noon) 1P to 11P	 (represents 1 o'clock to 11 o'clock in the evening) <minute>: 0 to 59

<second>: 0 to 59



examples:



A>TIME 12		<-- sets time to 12:00:00



A>TIME 1:16P 	<-- sets time to 13:16:00



* TYPE



form	TYPE <file spec>



The command TYPE displays the contents of a file specified by <file spec>.

Using wildcards in <file spec> causes the first of the corresponding files to be displayed. This command is for ASCII files, and displaying binary files causes unreadable control characters to be sent to the screen.



* VERIFY



form	VERIFY [ON|OFF]



VERIFY sets/resets the verify mode. When the verify mode is turned ON, after data is written to the disk, it is always read to ensure that it was written correctly. This is why disk access takes longer. "VERIFY OFF" is set by default.





2.3 Batch Command Usage




MSX-DOS has a batch feature that allows a series of commands listed in the order of operation to be executed automatically. The file containing this procedureis called a "batch file" and the series of operations defined by a batch file is called a "batch command".



A batch file uses the extension ".BAT". Typing only the file name (the extension ".bat" is not typed) at the command line prompt causes MSX-DOS to execute the commands in the file line by line.



For example, let us consider the following operation:

1. Copy all files on drive A with the extension ".COM" onto drive B.

2. List all "COM" files on drive B.

3. Delete all "COM" files on drive A.



This operation could be achieved by issuing the following commands to MSX-DOS:



A>COPY A:*.COM B:

A>DIR B:*.COM /W

A>DEL A:*.COM



If these three lines are combined into a batch file called "MV.BAT", the command line input "MV" will automatically execute the operation shown above.

The following list illustrates this.



A>COPY CON MV.BAT -+

COPY A:*.COM B: | creates "MV.BAT"

DIR B:*.COM /W	 |

DEL A:*.COM	 -+

^Z		 Ctrl-Z + RETURN key input



A>TYPE MV.BAT	 -+

COPY A:*.COM B: | to confirm the contents of "MV.BAT"

DIR B:*.COM /W	 |

DEL A:*.COM	 -+



A>MV		 invokes the batch command "MV"

A>COPY A:*.COM B: reads the first line automatically and executes it .

.

.

A>DIR B:*.COM /W reads the second line automatically and executes it .

.

.

A>DEL A:*.COM	 reads the third line automatically and executes it .

.

.



A batch operation may be interrupted by pressing Ctrl-C. When Ctrl-C is entered during batch operations, the request shown in Figure 3.7 is displayed on the screen.



Figure 3.7 Interrupt of the batch operation

-----------------------------------

|				 |

| Terminate batch file (Y/N)? |

|				 |

-----------------------------------



Selecting "Y" here terminates the batch command and returns to MSX-DOS.

Selecting "N" reads the next line of the batch file and continues the execution of the batch command.



* Batch variables



For more flexible use of the batch command, any string can be passed as parameters from the command line to the batch command. Parameters passed are referred to with the symbols "%n" where n is any number from 0 to 9. These "%n" symbols are called batch variables.



Batch variables %1, %2, ... correspond to parameters specified in the command line from left to right, and %0 is for the name of the batch command itself.



Figure 3.8 Examples for batch variables usage

-----------------------------------------------------------------

|								|

| A>COPY CON TEST.BAT ......... creates a batch command 	|

| REM %0 %1 %2 %3						|

| ^Z								|

|	 1 file copied						|

| A>TYPE TEST.BAT						|

| REM %0 %1 %2 %3 ...... a batch command to display 3 arguments |

|								|

| A>TEST ONE TWO THREE FOUR ...... executes the batch command,	|

| A>REM TEST ONE TWO THREE	 giving arguments to it	|

| A>								|

|								|

-----------------------------------------------------------------



* AUTOEXEC.BAT



The batch file named "AUTOEXEC.BAT" is used as a special autostart program at MSX-DOS startup. When MSX-DOS is invoked, COMMAND.COM examines whether AUTOEXEC.BAT exists and, if so, executes it.





2.4 External Commands




External commands exist on the diskette as files with the extension ".COM", and typing the external command name (except for the extension) causes the command to be executed in the following manner.



1. loads an external command after 100H





2. calls 100H




* Developing external commands



Assembly language routines created to work in memory at location 100H and saved under file names with the extension ".COM" are called external commands and can be executed from MSX-DOS.



For example, consider a program to produce a control code "0CH" by using one-character output routine (see system calls) and clear the screen. This is an 8-byte program as shown below.



List 3.1 Contents of CLS.COM

=========================================================================



1E 0C		LD	E,0CH	 ; E := control-code of CLS

0F 02		LD	C,02H	 ; C := function No. of CONSOLE OUTPUT

CD 05 00	CALL	0005H	 ; call BDOS

C9		RET



=========================================================================



Writing these 8 bytes to a file named CLS.COM produces the external command "CLS" to clear the screen. The following sample program uses the sequential file access feature of BASIC to make this command. After this program is run, the CLS command is created on the diskette. Confirm that the command actually works after returning to MSX-DOS.



List 3.2 Creating CLS.COM



=========================================================================



100 '***** This program makes "CLS.COM" *****

110 '

120 OPEN "CLS.COM" FOR OUTPUT AS #1

130 '

140 FOR I=1 TO 8

150 READ D$

160 PRINT #1,CHR$(VAL("&H"+D$));

170 NEXT

180 '

190 DATA 1E,0C,0E,02,CD,05,00,C9



=========================================================================



* Passing arguments to an external command

When creating an external command, there are two ways to pass arguments from the command line to the external command. First, when passing the file names to the command line as arguments, use 5CH and 6CH in the system scratch area.

COMMAND.COM, which always considers the first and second parameters as file names when external commands are executed, expands them to a drive number (1

byte) + file name (8 bytes) + extension (3 bytes) and stores them in 5CH and 6CH. These are in the same format as the first 12 bytes of FCB, so setting these address as first addresses of FCB permits various operatuons.



However, since in this method only 16 bytes differ from the starting addresses of two FCBs, either 5CH or 6CH (only) can be used as a complete FCB. Next, when passing arguments other than file names (numbers, for instance) or creating an external command handling more than three file names, COMMAND.COM stores the whole command line, which invoked the external command, except for the command line itself in the form of number of bytes (1

byte) + command line body, so it can be used by interpreting it in the external command properly. See list 3.3 of section 4 for an example of passing arguments using this DMA area.





3. STRUCTURE OF DISK FILES




Information about the structure of data on the disk and how it is controlled is important when acessing the disk using system calls. This section begins with a description about "logical sectors" which are the basic units for exchanging data with the disk on MSX-DOS, and proceeds to the method of handling data with "files" which is more familiar to programmers.





3.1 Data units on the disk




* Sectors



MSX-DOS can access most types of disk drives including th 3.5 inch 2DD and hard disks. For handling different media in the same way, the system call consider "logical sector" as the basic units of data on the disk. A logical sector is specified by numbers starting from 0.



* Clusters



As long as system calls are used, a sector may be considered the basic unit of data as considered above. In fact, however, data on the disk is controlled in units of "clusters" which consists of multiple sectors. As described later in the FAT section, a cluster is specified by a serial number from 2 and the top of the data area corresponds to the location of cluster #2. For getting information about how many sectors a cluster has, use the system call function 1BH (acquiring disk information).



* Conversion from clusters to sectors



In a part of the directory or FCB, described later, the data location on the disk is indicated by the cluster. To use system calls to access data indicated by cluster, the relation of the correspondence between the cluster and the sector needs to be calculated. Since cluster #2 and the top sector of the data area reside in the same location, this can be done as follows:

1. Assume the given cluster number is C.

2. Examine the top sector of the data area (by reading DPB) and assume it is





S0.


3. Examine the number of sectors equivalent to one cluster (using function 1BH) and assume it is n.

4. Use the formula S = S0 + (C-2) * n to calculate sector numbers.



In MSX-DOS, sectors in the disk are divided into four areas, as shown in Table 3.9. The file data body written to the disk is recorded in the "data area" portion. Information for handling data is written in three areas.

Figure 3.9 shows the relation of the locations of these areas. The boot sector is always in sector #0, but the top sectors (FAT, directory, and data area) differ by media, so DPB should be referred to.



Table 3.9 Disk contents

----------------------------------------------------------------------------

| boot sector | MSX-DOS startup program and information proper to the disk |

| FAT	 | physical control information of data on the disk	 |

| directory | control information of files on the disk		 |

| data area | actual file data					 |

----------------------------------------------------------------------------



Figure 3.9 Relation of locations of elements in the disk

+- ----------------------- <-- sector #0

| | boot sector |

| |---------------------| <-- sector #? -+

| | 	FAT	 |		 | Top sectors of these data whole |---------------------| <-- sector #? | areas can be acquired by of a | directory	 |		 | referring to DPB.

disk |---------------------| <-- sector #? -+

| | 		 |

| | data area	 |

| | 		 |

+- ----------------------- <-- last sector

* DPB (drive parameter block) and boot sector

On MSX-DOS, the area "DPB" is allocated in the work area of memory for each connected drive, and information proper to each drive is recorded there.

MSX-DOS can handle most types of disk drives, because the differences between media can be compensated for by the process corresponding to each drive.



Information written on DPB, which is originally on the boot sector (sector #0) of the disk, is read at MSX-DOS startup. Note that the differences between the contents of the boot sector and DPB, as shown in Figures 3.10 and 3.11. Data is arranged differently in the boot sector and the DPB.



Figure 3.10	Information of the boot sector

|		|

|---------------| -+

0B	|		| |-- 1 sector size (in bytes)

0C	|		| |

|---------------| -+

0D	|		| ---- 1 cluster size (in sectors) |---------------| -+

0E	|		| |-- Number of unused sectors by MSX-DOS

0F	|		| |

|---------------| -+

10	|		| ---- Number of FATs

|---------------| -+

11	|		| |-- Number of directory entries 12	|		| | (How many files can be created) |---------------| -+

13	|		| |-- Number of sectors per disk

14	|		| |

|---------------| -+

15	|		| ---- Media ID

|---------------| -+

16	|		| |-- Size of FAT (in sectors)

17	|		| |

|---------------| -+

18	|		| |-- Number of tracks per sector 19	|		| |

|---------------| -+

1A	|		| |-- Number of sides used

1B	|		| | (either one or two)

|---------------| -+

1C	|		| |-- Number of hidden sectors

1D	|		| |

|---------------| -+

|		|



Figure 3.11	DPB structure

-----------------

BASE -> |		| ---- drive number

|---------------|

+1	|		| ---- media ID

|---------------| -+

+2	|		| |-- sector size

+3	|		| |

|---------------| -+

+4	|		| ---- directory mask

|---------------|

+5	|		| ---- directory shift

|---------------|

+6	|		| ---- cluster mask

|---------------|

+7	|		| ---- cluster shift

|---------------| -+

+8	|		| |-- top sector of FAT

+9	|		| |

|---------------| -+

+10	|		| ---- number of FATs

|---------------|

+11	|		| ---- number of directory entries |---------------| -+

+12	|		| |-- top sector of data area

+13	|		| |

|---------------| -+

+14	|		| |-- amount of cluster + 1

+15	|		| |

|---------------| -+

+16	|		| ---- number of sectors required for one FAT

|---------------| -+

+17	|		| |-- top sector of directory area +18	|		| |

|---------------| -+

+19	|		| |-- FAT address in memory

+20	|		| |

----------------- -+



Use the system call Function 1BH (disk information acquisition) to access the DPB. This system call returns the DPB address in memory and other information for each drive written on the boot sector (see section 4 "System call usage"

for the detailed usage).



* FAT (file allocation table)



In MSX-DOS, a "cluster" is the data unit for writing to the disk. Files larger than a cluster are written across multiple clusters. But in this case adjacent clusters are not always used. In particular, after creating and deleting files many times, clusters which are no longer used are scattered at random across the disk. When a large file is created for such cases, the file is broken down into several clusters and these clusters are stored where space is available. The linkage information is kept at the beginning so that the file can be recreated. This is the main function of the FAT.



When a bad cluster is found, FAT is also used to record that location, so access will not be made there any more. Linkage information of clusters and information concerning bad clusters is necessary for managing disk files.

Without this information, the whole disk will be unusable. For this reason, more than one FAT is always prepared in case of accidental erasure.



Figure 3.2 shows an example of a FAT. The first byte is called the "FAT ID"

which contains the value indicating the type of media (the same value as media ID in Table 3.2). The next two bytes contains meaningless dummy values.

From the fourth byte (start address + 3), actual linkage information is recorded in an irregular format of 12 bits per cluster. Each 12-bit area containing linkage information is called a FAT entry. Note that the FAT entry begins with number 2. The number of the FAT entry is also the number of the cluster corresponding to it. Read the 12-bit linkage information recorded in the FAT entry in the way shown in Figure 3.13.



Figure 3.12	FAT example

|4 bits |4 bits |

FAT	-----------------

start address ->| F	 B	| ----- FAT ID

|---------------|

+1 | F	 F	| --+

|---------------| |-- dummy +2 | F	 F	| |

|---------------| --+

+3 | 0	 3	|

|---------------| FAT entry 2 : link = 003H ---+

+4 | 4	| 0	| ------------------------+

|---------------|	V

+5 | 0	 0	| FAT entry 3 : link = 004H ---+

|---------------| ------------------------+

+6 | F	 F	|	V

|---------------| FAT entry 4 : link = FFFH (end) +7 | 6	| F	|

|---------------|

+8 | 0	 0	| FAT entry 5 : link = 006H ---+

|---------------| ------------------------+

+9 | F	 F	|	V

|---------------| FAT entry 6 : link = FFFH (end) +10 |	| F	|

---------



The linkage information is the value indicating the next cluster number. FFFH

means that the file ends with that cluster. The example of Figure 3.12 shows a file of three clusters, (cluster #2 -> cluster #3 -> cluster #4), and a file of two clusters, (cluster #5 -> cluster #6). The linkage from the cluster with the smaller number is only for easy comprehension. In actual practice, numbers are not necessarily ordered.



Figure 3.13	Reading FAT



|		|

|---------------|

| 2	 1	| ----- link = 321H

|---------------|

| 4	| 3	|

|---------------|

| 6	 5	| ----- link = 654H

|---------------|

|	.	|

.

.



* Directory



The FAT as described above, relates the physical location of data on the disk and does not include information about the contents of data written there.

Thus, an information resource other than FAT is required to know what kind of data is in a file. This resource is called a "directory". A directory entry is composed of 32 bytes and records file names, file attributes, date created, time created, number of the top cluster of the file, and file size, as shown in Figure 3.14.



"File attributes" in the directory are used for specifying the invisibility attribute in a file. Specifying "1" in the second bit from the lowest of this byte prevents files specified in the directory from being accessed by the system call (see Figure 3.15). MS-DOS also has a file attribute byte which permits a write-prohibit attribute using another bit, but MSX-DOS does not support this feature.



The date and time are recorded so that two bytes of each are divided into three bitfields, as shown in Figure 3.16 and Figure 3.17. Since only 5 bits are prepared for the "time" bitfield, the minimum unit for time is two seconds. The year (1980 to 2079) is specified by using 0 to 99 in 7 bits.



Figure 3.14	Directory construction

Directory	----------------- -+

header	 -->	|	.	| |

.	 |-- filename (8 characters) .	 |

+7 |		| |

|---------------| -+

+8 |		| |

+9 |		| |-- extension (3 characters) +10 |		| |

|---------------| -+

+11 |		| ---- file attribute |---------------| -+

.	|	.	| |

.		.	 |-- space for compatibility with MS-DOS

.		.	 | (not used by MSX-DOS) |		| |

|---------------| -+

+22 |		| |-- time created +23 |		| |

|---------------| -+

+24 |		| |-- date created +25 |		| |

|---------------| -+

+26 |		| |-- top cluster of the file +27 |		| |

|---------------| -+

+28 |		| |

+29 |		| |-- file size +30 |		| |

+31 |		| |

----------------- -+



Figure 3.15	Invisibility attribute of the file

(11th byte of the directory) ---------------------------------

| . | . | . | . | . | . | X | . |

---------------------------------

|

|	 0 : enables normal acess +----->

1 : disables access

Figure 3.16	Bitfield representing time

(23rd byte of the directory) 	 (22nd byte of the directory) --------------------------------- ---------------------------------

| h4| h3| h2| h1| h0| m5| m4| m3| | m2| m1| m0| s4| s3| s2| s1| s0|

--------------------------------- ---------------------------------

|		 |				 |		 |

+-------------------+-----------------------------+-------------------+

hour (0 to 23)	 minute (0 to 59)	 second /2 (0 to 29) |

"second" value when multiplied by 2 --+



Figure 3.17	Bitfield representing date

(25th byte of the directory) 	 (24th byte of the directory) --------------------------------- ---------------------------------

| y6| y5| y4| y3| y2| y1| y0| m3| | m2| m1| m0| d4| d3| d2| d1| d0|

--------------------------------- ---------------------------------

|			 |			 |		 |

+---------------------------+---------------------+-------------------+

year (0 to 99)		month (1 to 12) day (1 to 31) |

+-- corresponds to 1980 to 2079



The place where this directory information is actually recorded is the directory area on the disk (see Figure 3.9). The location (top sector) is recorded in the DPB. Directory entries (locations of directory storage) are arranged every 32 bytes in the driectory area, as shown in Figure 3.18. When a file is created, the directory is created at the lowest value of unused directory entries. Deleting a file causes E5H to be written to the first byte of the corresponding directory entry, which is empty. After all direcotry entries are exhausted, new files cannot be created even if there is a lot of unused space on the disk. The number of directory entries, that is, the number of files which can be created on one disk is also recorded in the DPB.



Figure 3.18	Organisation of directory area

|------ 32 bytes -------|

-------------------------

BASE -> | MSXDOS.SYS	|

|-----------------------|

+32 | COMMAND.COM	|

|-----------------------|

+64 | E5H | 		| <-- The directory entry whose first |-----------------------| byte is E5H is currently unused +96 |	 TEST		|

|-----------------------|

|	 .		|

.		|

.

|			|

|-----------------------|

+32 * n | 00H | 		| <-- The directory entry whose first |-----------------------| byte is 00H has never been used |			|





3.2 File Access




* FCB (file control block)



Using information recorded in the directory area allows data to be treated as a "file". The advantage of this method is that the data location is not represented by an absolute number such as sector number or cluster number; instead, the file can be specified with a "name". The programmer need only specify the file name and the system will do all the work concerned with accessing the requested file. In other words, the programmer need not understand the details of which sectors the file occupies. In this case, FCB

plays an important role for directories.



FCB is the area for storing information needed to handle files using system calls. Handling one file requires 37 bytes of memory each, as shown in Figure 3.19. Although the FCB can be located anywhere in memory, the address 005CH

is normally used to utilize MSX-DOS features.



Figure 3.19	Organization of FCB



FCB	------

bytes	| 0 | drive number

from	|----|

top	| 1 | file name

|	| |	 filename ..... 8 bytes

V	| 11 |	 extension .... 3 bytes

|----|

| 12 | current block | 13 |	 number of blocks from the top of the file to the |----|	 current block | 14 | record size | 15 |	 1 to 65535

|----|

| 16 | file size | |	 1 to 4294967296

| 19 |

+--	|----|

|	| 20 | date

|	| 21 |	 same form as directory (1)	|----|

|	| 22 | time

|	| 23 |	 same form as directory +--	|----|

|	| 24 | device ID

|	|----|

|	| 25 | directory location |	|----|

|	| 26 | top cluster number of the file (2)	| 27 |

|	|----|

|	| 28 | last cluster number accessed |	| 29 |

|	|----|

|	| 30 | relative location from top cluster of the file |	| 31 |	 number of clusters from top of the file +--	|----|	 to the last cluster accessed | 32 | current record |----|

| 33 | random record | |	 record order from the top of the file | 36 |	 usually stores the last record made random access ------



Notes: FCB usages differ, depending on whether they use CP/M compatible system calls or additional system calls. See the decription below for details.



(1) When using version 2 of MSX-DOS, here is stored the volume-id of the disk, and should not be modified by the program.

(2) When using version 2 of MSX-DOS, here is stored internal information relative to the physical location of the file on the disk. The format of this information is different from shown in figure 3.19, and should not be modified by the program.



* drive number (00H)

Indicates the disk drive containing the file.

(0 -> default drive, 1 -> A:, 2 -> B:...)

* filename (01H to 08H)

A filename can have up to 8 characters. When it has less than 8, the rest are filled in by spaces (20H).



* extension (09H to 0BH)

A extension can have up to 8 characters. When it has less than 3, the rest are filled in by spaces (20H).



* current block (0CH to 0DH)

Indicates the block number currently being referred to by sequential access (see function 14H, 15H in section 4).



* record size (0EH to 0FH)

Specifies the size of data unit (record) to be read or written at one access, in bytes (see function 14H, 15H, 21H, 27H, 28H).



* file size (10H to 13H)

Indicates the size of the file in bytes.



* date (14H to 15H)

Indicates date when a file was last written. The format is the same as the one recorded in the directory.



* time (16H to 17H)

Indicates time when a file was last written. The format is the same as the one recorded in the directory.



* device ID (18H)

When a peripheral is opened as a file, the value shown in Table 3.10 is specified for this device ID field. For normal disk files, the value of this field is 40H + drive number. For example, the device ID for drive A is 40H

(for future expansion, application programs should not use the ID byte).



Table 3.10 Device ID



----------------------------------

| Device name | Device ID |

|--------------------+-----------|

| CON (Console) |	 0FFH	 |

| PRN (Printer) |	 0FBH	 |

| LST (List=Printer) |	 0FCH	 |

| AUX (Auxiliary) |	 0FEH	 |

| NUL (Null)	 |	 0FDH	 |

----------------------------------



* directory location (19H)

Indicates the order of the directory entries of a file in the directory area.



* top cluster (1AH to 1BH)

Indicates the top cluster of the file in the disk.



* last cluster accessed (1C to 1DH)

Indicates the last cluster accessed.



* relative location from top cluster of last cluster accessed (1EH to 1FH) Indicates the relative location from the top cluster of the last cluster accessed.



* current record (20H)

Indicates the record currently being referred to by sequential access (see function 14H, 15H).



* random record (21H to 24H)

Specifies a record to be accessed by random access or random block access.

Specifying a value from 1 to 63 for the record size field described above causes all four bytes from 21H to 24H to be used, where only three bytes from 21H to 23H have meaning when the record size is greater than 63 (see function 14H, 15H, 21H, 22H, 27H, 28H).



* Opening a file



A special procedure is required to open a file when using FCB. "Opening a file" means, at the system call level, transforming the incomplete FCB whose file name field is only defined for the complete FCB, by using information written in the directory area. Figure 3.20 shows the differences between "unopened FCB" and "opened FCB".



Figure 3.20	Before/after opening FCB



before the open 	 after the opem



-----		 -----

0 | S | drive number	 0 | S | default drive (00H) is converted 1 | S | -----		 1 | S |	to real drive (01H to 06H) 2 | S | ^		 2 | S |

3 | S | |		 3 | S |

4 | S | |		 4 | S |

5 | S | |		 5 | S |

6 | S | file name	 6 | S |

7 | S | |		 7 | S |

8 | S | |		 8 | S |

9 | S | |		 9 | S |

10 | S | V		 10 | S |

11 | S | -----		 11 | S |

12 | |		 12 | | \	current block

13 | |		 13 | | /

14 | |		 14 | | \	record size

15 | |		 15 | | /

16 | |		 16 | S | --+

17 | |		 17 | S | | file

18 | |		 18 | S | | size

19 | |		 19 | S | --+

20 | |		 20 | S | \ date

21 | |		 21 | S | /

22 | |		 22 | S | \ time

23 | |		 23 | S | /

24 | |		 24 | S | device ID

25 | |		 25 | S | directory location

26 | |		 26 | S | \ top cluster number number of the file 27 | |		 27 | S | /

28 | |		 28 | S | \ last cluster number accessed 29 | |		 29 | S | /

30 | |		 30 | S | \ relative location from top 31 | |		 31 | S | / cluster of the file 32 | |		 32 | | current record

33 | |		 33 | | --+

34 | |		 34 | | | random

35 | |		 35 | | | record

36 | |		 36 | | --+

-----		 -----



* Closing a file



When a file is opened and written to, the contents of each field of FCB, such as size, is also modified. Unless the updated FCB information is returned to the directory area, directory information and the actual contents of the file might be different at the next file access. This operation to return the updated FCB information to the directory corresponds to closing a file at the system call level.



* Random block access (file management by records)

MSX-DOS has two system calls dealing with random access, "RANDOM BLOCK READ"

and "RANDOM BLOCK WRITE". With these system calls, a file can be divided into data units of any size, which can be handled by numbers, such as 0, 1, 2, ..., from the top. This data unit is called a "record". Record size can be any value of more than one byte. So, treating a whole file as one record (extreme sequential access), treating data with one byte as one record (extreme random access), or treating 128 bytes as one record (the CP/M way) are all possible.



In this case, the FCB fields, "record size" and "random record" are used to specify the record. The value of the record size field is the number of bytes in one record. Random record fields can have any record number to be accessed (for more detailed usage, see descriptions of each system call).



Figure 3.21	File and record

+--		 +- ----------------

|	 record size | | record #0	|

|		 +- |--------------| -----------------

|			 | record #1	| <--- | random record |

|			 |--------------| -----------------

|			 | record #2	|	 point to the whole			 |--------------|	 record currently file			 |	.	|	 accessed

|				.

|				.

|			 |		|

|			 |--------------|

|			 | record #n	|

+--			 ----------------



* Sequential access (file management by fixed-length record + current record + current block)



MSX-DOS can also access files the same way as CP/M for purposes of compatibility. One way is the sequential file which is managed by "current record" and "current block". This uses a 128-byte fixed-length record as the basic unit of data. File access is always done from the top sequentially and the number of records which was accessed is counted at the current record field of FCB. The value of the current record field is reset to 0 when it reaches 128, and the carry is counted in the current block field.



* Random access (file management by fixed-length record + random record)

A second method included to keept compatibility with CP/M is a random access method using random record fields. It can access the record of any location but the record size is fixed at 128 bytes.





4. SYSTEM CALL USAGE




The system calls are a collection of general-purpose subroutines which handle the basic input/output operations of MSX-DOS. Having these system calls gathered into BIOS in a predefined manner permits the basic functions of the MSX disk system to be easily accessed.



There are two purposes of system calls; first, to reduce programming time by preprogramming basic functions; second, to increase portability by the fact that all programs share the same basic functions. Utilizing system calls shortens program development time and makes the developed program highly portable.



To execute a system call, enter the defined function number in the C register of the Z80 CPU and call one of the following addresses:

0005H ................. MSX-DOS

F37DH (&HF37D) ........ MSX DISK-BASIC



For example, when the function number is 01FH and the system call requires 00H to be set in the A register, the following assembler code can be used with MSX-DOS:



LD	A,00H

LD	C,01FH

CALL	0005H

.

.

.



The CALL statement is also used in operations that return values or restore registers from memory. System calls can also be used from DISK-BASIC by using the entry address of F37DH. For this case, store the machine codes in the area allocated by the CLEAR statement and call its start address using the USR function.



* System call format



This section introduces system call usages in the following notation:

----------------------------------------------------------------------------

| Function:	function number 					 |

| Setup:	value needed to be set in register or memory by programmer |

| Return value: value set in register by system call			 |

----------------------------------------------------------------------------



Function:



The function number is used to identify the system call. When using a system call, set the function number in the C register.



Setup:



In this section, "setup:" indicates the value to be set in the named register or memory location before executing system calls.



Return value:



The result obtained by a system call is normally set in a register or memory location. This is called output in this section and "return value:" indicates where and how this output is set.



Is important to note that when using system calls, the contents of registers other than those specified are sometimes destroyed. So, before using system calls, store the contents of registers whose value you do not want to change in an appropriate place (stack, for example) before executing system calls.



There are forty-two MSX system calls. These are listed in Table 3.11, and are described in this section. There are four categories:

* Peripheral I/O

* Environment setting * Absolute READ/WRITE (direct access to sector) * File access using FCB



Table 3.11 List of System Calls

Function no.				Function



00H			system reset 01H			get one character from console (input wait, echo back, control code check) 02H			send one character to console 03H			get one character from auxiliary device 04H			send one character to auxiliary device 05H			send one character to printer 06H			get one character from console (no input wait, no echo back, no control code check)/ one character output

07H			get one character from console (input wait, no echo back, no control code check) 08H			get one character from console (input wait, no echo back, control code check) 09H			send string 0AH			get string 0BH			check input from console 0CH			get version number 0DH			disk reset 0EH			select default drive 0FH			open file

10H			close file 11H			search the first file matched with wildcard 12H			search the second and after the second file matched wildcard 13H			delete file 14H			read sequential file 15H			write sequential file 16H			create file 17H			rename file 18H			get login vector 19H			get default drive name 1AH			set DMA address 1BH			get disk information 1CH-20H		no function 21H			write random file 22H			read random file 23H			get file size 24H			set random record field 25H			no function 26H			write random block 27H			read random block 28H			write random file (00H is set to unused portion) 29H			no function 2AH			get date

2BH			set date

2CH			get time

2DH			set time

2EH			set verify flag 2FH			read logical sector 30H			write logical sector

* Note



System call function numbers are from 00H to 30H; the following seven numbers are blank:



1CH to 20H, 25H, 29H



Calling these blank funtion system calls do nothing except setting 00H in the A register. System calls after function 31H are undefined. Using them may cause unpredictable results (not advisable).



List 3.3 Utility routines

=========================================================================



;**************************************************************

;

; List 3.3 utility.mac

;

; these routines are used in other programs ;

; GETARG, STOHEX, PUTHEX, PUTCHR, DUMP8B

;

;**************************************************************

;

PUBLIC	GETARG		Note: Five utility routines included in PUBLIC	STOHEX		 this program list will be used in PUBLIC	PUTHEX		 sample programs later.

PUBLIC	PUTCHR

PUBLIC	DUMP8B



BDOS:	EQU	0005H

DMA:	EQU	0080H



;----- DE := address of arg(A)'s copy -----



GETARG: PUSH	AF		Note: Nth parameter (N is specified by PUSH	BC		 A register) of the command line PUSH	HL		 stored in default DMA area (0080H to ) is loaded in memory and LD	C,A		 its starting address is returned in LD	HL,DMA		 DE register.

LD	B,(HL)

INC	HL

INC	B



SKPARG: DEC	B

JR	NZ,NOARG

SKP1:	LD	A,(HL)

INC	HL

CALL	TERMCHK

JR	NZ,SKP1

SKP2:	LD	A,(HL)

INC	HL

CALL	TRMCHK

JR	Z,SKP2

DEC	HL

DEC	C

JR	NZ,SKPARG



CPYARG: LD	DE,BUFMEM

CPY1:	LD	A,(HL)

LD	(DE),A

INC	HL

INC	DE

CALL	TRMCHK

JR	NZ,CPY1



DEC	DE

LD	A,"$"

LD	(DE),A

LD	DE,BUFMEM

JR	EXIT



NOARG:	LD	DE,BUFMEM

LD	A,"$"

LD	(DE),A



EXIT:	POP	HL

POP	BC

POP	AF

RET



TRMCHK: CP	09H

RET	Z

CP	0DH

RET	Z

CP	" "

RET	Z

CP	";"

RET



;----- HL := hexadecimal value of [DE] -----



SOTHEX: PUSH	AF		Note: Hexadecimal string indicated by PUSH	DE		 DE register is converted into LD	HL,0000H	 two-byte integer and stored in CALL	STOH1		 HL register.

POP	DE

POP	AF

RET



STOH1:	LD	A,(DE)

INC	DE

SUB	"0"

RET	C

CP	10

JR	C,STOH2

SUB	"A"-"0"

RET	C

CP	6

RET	NC

ADD	A,10



STOH2:	ADD	HL,HL

ADD	HL,HL

ADD	HL,HL

ADD	HL,HL

OR	L

LD	L,A

JR	STOH1



;----- print A-reg, in hexadecimal form (00-FF) -----



PUTHEX: PUSH	AF		Note: Contents of A register is displayed RR	A		 using two hexadecimal digits.

RR	A

RR	A

RR	A

CALL	PUTHX1

POP	AF

PUTHX1: PUSH	AF

AND	0FH

CP	10

JR	C,PUTHX2

ADD	A,"A"-10-"0"

PUTHX2: ADD	A,"0"

CALL	PUTCHR

POP	AF

RET



;----- put character -----



PUTCHR: PUSH	AF

PUSH	BC

PUSH	DE

PUSH	HL

LD	E,A

LD	C,02H

CALL	BDOS

POP	HL

POP	DE

POP	BC

POP	AF

RET



;----- dumps 8bytes of [HL] to [HL+7] in hexa & ASCII form -----



DUMP8B: PUSH	HL		Note: Contents of eight bytes after the LD	B,8		 address indicated in HL register DUMP1:	LD	A,(HL)		 are dumped in both hexadecimal INC	HL		 and character codes.

CALL	PUTHEX

LD	A," "

CALL	PUTCHR

DJNZ	DUMP1

POP	HL

LD	B,8

DUMP2:	LD	A,(HL)

INC	HL

CP	20H

JR	C,DUMP3

CP	7FH

JR	NZ,DUMP4

DUMP3:	LD	A,"."

DUMP4:	CALL	PUTCHR

DJNZ	DUMP2

LD	A,0DH

CALL	PUTCHR

LD	A,0AH

CALL	PUTCHR

RET



;----- work area -----



BUFMEM: DS	256



END



=========================================================================



4.1 Peripheral I/O



The following system calls are intended for input/output operations. Some examples include console I/O (screen/keyboard), auxiliary I/O (external input/output), and printer I/O. Since subroutines such as getting information from the keyboard or controlling printers are necessary for most programs, you will find the system calls described in this section useful for general programming.



* Console input



Function:	01H

Setup:		none

Return value:	A register <-- one character from console

When there is no input (no key pressed and input buffer empty), an input is wait for. Input characters are echoed back to the console. The following control character input is allowed: Ctrl-C causes program execution to be halted and a return to the MSX-DOS command level; Ctrl-P causes any sucessive input to also echoed to the printer until Ctrl-N is accepted; Ctrl-S causes the display to stop until any key is pressed.



Ctrl-C ........ system reset Ctrl-P ........ printer echo Ctrl-N ........ halt printer echo Ctrl-S ........ pause display

* Console output



Function:	02H

Setup:		E register <-- character code to be sent out Return value:	none



This system call displays the character specified by the E register on the screen. It also checks the four control characters, listed above.



* External input



Function:	03H

Setup:		none

Return value:	A register <-- one character from AUX device

This system call checks four control characters.



* External output



Function:	04H

Setup:		E register <-- character code to send to AUX device Return value:	none



This system call checks four control characters.



* Printer output



Function:	05H

Setup:		A register <-- one character from console

This system call does not echo back. It treats control characters in the same way as function 01H.



* Direct console input/output



Function:	06H

Setup:		E register <-- character code to be send to the console When 0FFH is specified, the character will be input from the console.

Return value:	When the E register is set to 0FFH (input), the result of input is in the A register. The value set in the A register is the character code of the key, if it was pressed; otherwise, the value is 00H. When the E register is set to a value other than 0FFH (output), there is no return value.



This system call does not support control characters and does not echo back input. This system call checks four control characters.



* Direct console input - 1



Function:	07H

Setup:		none

Return value:	A register <-- one character from console

This system call does not support control characters, nor echo back.



* Direct console input - 2



Function:	08H

Setup:		none

Return value:	A register <-- one character from console

This system call does not echo back. It treats control characters in the same way as function 01H.



* String output



Function:	09H

Setup:		DE register <-- starting address of string, prepared on memory, to be sent to the console.

Return value:	none



24H ("$") is appended to the end of the string as the end symbol. This system call checks and performs four control character functions, as listed previously.



* String input



Function:	0AH

Setup:		The address of memory where the maximum number of input characters (1 to 0FFH) is set should be set in the DE

register.

Return value:	Number of characters actually sent from console is set in the address, one added to the address indicated by the DE

register; string sent from console is set in the area from the address, two added to the address indicated by the DE

register.



Return key input is considered as the end of console input. However, when the number of input characters exceeds the specified number of characters (contents indicated by DE register, 1 to 255), characters within the specified number of characters will be treated as an input string and set in memory, and the operation ends. The rest of characters including the return key are ignored. Editing with the template is available to string input using this system call. This system call checks and performs four control character function, as listed previously.



* Console status check



Function:	0BH

Setup:		none

Return value:	0FFH is set in the A register when the keyboard is being pressed; otherwise, 00H is set.



This system call checks and performs four control character function, as listed previously.





4.2 Environment Setting and Readout




The following system calls set the MSX system environment; for example, changing the default drive, or setting various default values of the system

* System reset



Function:	00H

Setup:		none

Return value:	none



When this is called in MSX-DOS, the system is reset by jumping to 0000H. When MSX DISK-BASIC call this, it is "warm started". That is, it returns to BASIC

command level without destroying programs currently loaded.



* Version number acquisition



Function:	0CH

Setup:		none

Return value:	HL register <-- 0022H



This system call is for acquiring various CP/M version numbers, on MSX-DOS, however, 0022H is always returned.



* Disk reset



Function:	0DH

Setup:		none

Return value:	none



If there is a sector which has been changed but not written to the disk, this system call writes it to the disk, then it sets the default drive to drive A and sets DMA to 0080H.



* Default drive setting



Funtion:	0EH

Setup:		E register <-- default drive number (A = 00H, B = 01H, ...) Return value:	none



Disk access by the system calls are made to the drive indicated by the default drive number, unless otherwise specified. Note that, when the drive number, which is set in the FCB specified upon calling the system call, is other than 00H, the default drive setting made by this system call is ignored.



* Login vector acquisition



Function:	18H

Setup:		none

Return value:	HL register <-- online drive information

The online drive is the drive connected to MSX normally when the disk system is booted up. Executing this system call causes each drive to be examined whether it is online, and the result is returned in the HL register as shown in Figure 3.22. When the bit is "1", the corresponding drive is online; otherwise it is not.



Figure 3.22	Login vector

------------------------------------------------------------------------

| register name |	 H 	 |		 L	 |

|----------------+--------------------------+--------------------------|

| bit number	 | 7 6 5 4	3 2 1 0 | 7 6 5	4 3 2 1 0 |

|----------------+--------------------------+--------------------------|

| drive name	 | meaningless on MSX-DOS | H: G: F: E: D: C: B: A: |

|----------------+-----------------------------------------------------|

| online/offline | 1 is set for online and 0 for offline in each bit |

------------------------------------------------------------------------



* Default drive acquisition



Function:	19H

Setup:		none

Return value:	A register <-- defaut drive number (A = 00H, B = 01H, ...)

* Setting of address to be transferred to

Function:	1AH

Setup:		DE register <-- address setting to be transferred to (DMA address)

Return value:	none



Though DMA address is initialized to 0080H at system reset, it can be reset to any address by using this system call.



* Disk information acquisition



Function:	1BH

Setup:		E register <-- number of the objective drive (default drive = 00H, A = 01H, B = 02H, ...) Return value:	A register <-- number of logical sectors per one cluster (FFH if E register is set inappropriate) BC register <-- logical sector size DE register <-- amount of clusters IX register <-- DPB starting address IY register <-- FAT starting address on memory

This system call gets the information about the disk in the specified drive.

Specifying 00H for the drive number specifies the default drive. For other than that, specify 01H for drive A, 02H for drive B, and so on.



This system call has been created for MSX-DOS and is not compatible with CP/M.



* Date acquisition



Function:	2AH

Setup:		none

Return value:	HL register <-- year

D register <-- month E register <-- day of month A register <-- day of week

This system call has been created for MSX-DOS and is not compatible with CP/M.



* Date setting



Function:	2BH

Setup:		HL register <-- year

D register <-- month E register <-- day of month Return value:	A indicates whether the system call has done succesfully. If successful, the A register is set to 00H; otherwise, 0FFH.



This system call has been created for MSX-DOS and is not compatible with CP/M.



* Time acquisition



Function:	2CH

Setup:		none

Return value:	H register <-- hour

L register <-- minute D register <-- second E register <-- 1/100 second

This system call has been created for MSX-DOS and is not compatible with CP/M.



* Time setting



Function:	2DH

Setup:		H register <-- hour

L register <-- minute D register <-- second E register <-- 1/100 second Return value:	If successful, the A register is set to 00H; otherwise, 0FFH



This system call has been created for MSX-DOS and is not compatible with CP/M.



* Verify flag setting



Function:	2EH

Setup:		E register <-- 00H, when resetting verify flag E register <-- value other than 00H, when setting the verify flag Return value:	none



Setting the verify flag causes successive writing to the disk to be done in mode "verify on". That is, by reading the contents written on the disk, the check is made to compare them with the contents to be written.



This system call has been created for MSX-DOS and is not compatible with CP/M.



4.3 Absolute READ/WRITE (direct access to sectors)

MSX manages the disk with the "logical sector" as a minimum unit. The logical sector is defined independent of the physical secotrs of the disk, and is numbered from 0 to the maximum logical sector (maximum number depends on the kind of the disks).



Logical sectors enable users of MSX-DOS or MSX DISK-BASIC to access the disk without being concerned about the number of physical sectors per track, where that number depends on the media type of the disk. In fact, by utilizing system calls which use FCB (file control block), the file can be easily handled in detail even without considering logical sectors, so the user does not even need to use logical sectors. But for some purposes, access using logical sectors is desirable, so MSX-DOS ans MSX DISK-BASIC offer system calls which can access logical sectors.



This section describes the system calls which access the disk by use of logical sectors.



* Reading from the disk using logical sectors

Function:	2FH

Setup:		The logical sector number to be read from (for more than one logical sector, the starting logical sector number) should be set in the DE register. The number of logical sectors to be read should be set in the H register, and the drive number (00H for drive A, 01H for drive B, and so on. The same follows for function 30H below) to be used to read should be set in the L register.

Return value:	The contents read are set in the DMA buffer.



This system call reads out a specified number of continuous logical sectors from the specified logical sector of the specified drive and stores the contents in memory after DMA. It then stores the contents of what it has read in memory after DMA. Function 1AH (which specifies the address it is to be transferred to) assures that there is enough available space in memory.



This system call has been created for MSX-DOS and is not compatible with CP/M.



* Writing to the disk using logocal sectors

Function:	30H

Setup:		Contents to be written should be set in memory area after the address indicated by DMA. The logical sector number from where the writing begins should be set in the DE register.

The number of logical sectors to be written should be set in the H register. The drive number to be written to should be set in the L register.

Return value:	none



This system call has been created for MSX-DOS and is not compatible with CP/M.



List 3.4 Cluster dump

=========================================================================



;*********************************************************

;

; List 3.4	cluster dump

;

;		this program must link List 3.3

;

;*********************************************************

;

EXTRN	GETARG		Note: The first 128 bytes of an arbitrary EXTRN	STOHEX		 cluster specified in the command EXTRN	PUTHEX		 line are dumped.

EXTRN	PUTCHR

EXTRN	DUMP8B



BDOS	EQU	0005H



;----- program start -----



LD	A,1

CALL	GETARG		;[DE] := 1st argument of command line CALL	STOHEX		;HL := evaluate [DE] as hexadecimal ; this is the target cluster No.

PUSH	HL

LD	E,00H		;requests the default drive LD	C,1BH		;get disk information CALL	BDOS

POP	HL

CP	0FFH		;fail ?

JR	NZ,L2		;if not fail, A := sector/cluster and goto L2



LD	DE,ERMSG1	;[DE] := 'Cannot get Disk information'

LD	C,09H		;string putput function CALL	BDOS

RET			;error return

L2:	LD	E,(IX+12)	;DE := 1st sector of data area LD	D,(IX+13)

DEC	HL

DEC	HL		;HL := Cluster No. - 2

LD	B,H

LD	C,L		;BC := Cluster No. - 2

LOOP:	DEC	A		;Count N times

JR	Z,RESULT

ADD	HL,BC

JR	LOOP

RESULT: ADD	HL,DE		;HL := sector of target cluster PUSH	HL		;save target sector LD	DE,NEWDMA	;we reserved 1024 bytes area for DMA LD	C,1AH		;Set DMA address function CALL	BDOS

LD	C,19H

CALL	BDOS		;default drive ?

LD	L,A

POP	DE		;DE := target sector LD	H,1		;H := 1 (read 1 sector only) LD	C,2FH		;absolute read function CALL	BDOS		;data will be set into DMA

DUMP:	LD	HL,NEWDMA	;HL := DMA address

LD	DE,0000H	;DE := relative address from cluster top LD	B,16		;dump 16 lines DLOOP:	PUSH	BC

LD	A,D

CALL	PUTHEX

LD	A,E

CALL	PUTHEX

LD	A," "

CALL	PUTCHR

PUSH	HL

LD	HL,8

ADD	HL,DE

EX	DE,HL		;DE := DE+8

POP	HL

CALL	DUMP8B		;8 bytes dump subroutine (in another file) POP	BC

DJNZ	DLOOP

RET			;all work have done.



;----- work area -----



NEWDMA: DS	1024		;Private DMA area

ADRS:	DS	2



ERMSG1: DB	"Cannot get Disk information.$"

ERMSG2: DB	"Cannot read that cluster.$"



END



=========================================================================





4.4 File Access Using FCB




Since accessing a file is difficult when using the system calls described in the previous section (which read and write logical sectors directly), system calls using FCB are needed to easier access the disk by specifying files.



There are three categories of system calls using FCB. First is sequential file access and second is random file access, both are offered to maintain CP/M compatibility. The third is what gives MSX-DOS its power: random block access. This method is not available in CP/M. Random block access has the following features:



* Any record size can be specified * Random access can be made to multiple records * File size can be controlled in bytes

This section describes system calls for file access using FCB, including random block access. Note that the following three functions do not work correctly when FCB is in the address range 4000H to 7FFFH:

1. Function call 11H





2. Function call 12H


3. Input/output for devices (CON, PRN, NUL, AUX)

* Opening files



Function:	0FH

Setup:		DE register <-- starting address of FCB which is not opened Return value:	00H is set in the A register when a file is opened succeessfully; otherwise 0FFH is set. When a file is opened successfully, each field of the FCB is set.



When 00H is specified for a drive number, the default drive set by function 0EH (default drive setting) is used. To open a file on another drive, specify 01H for drive A, 02H for drive B and so on.



When a file is opened by this system call, all FCB fields except record size, current block, current record, and random record are set using information from the directory area on the disk. Fields which are not set should be set by the user after executing this system call, if needed. The state that each field of FCB is set is "the state that file is opened" when using system calls using FCB, and, in this case, system calls which access the file using FCB, described below, can be used.



* Closing files



Function:	10H

Setup:		DE register <-- starting address of opened FCB

Return value:	00H is set in the A register when file is closed scuccessfully; otherwise, 0FFH is set.



By writing the current contents of FCB in memory to the corresponding directory area on the disk, file information can be kept current. When the file is only read, it does not need to be closed by using this system call.



* File search - 1



Function:	11H

Setup:		DE register <-- starting address of FCB which is not opened Return value:	00H is set in the A register when the file is found; otherwise 0FFH is set. When the file is found, the directory entry (32 bytes) of the file on the disk is set in the area indicated by DMA, and FCB drive number is set (thus, 33 bytes are used).



Wildcard characters can be used in the name of the file. For example, a specification "????????.c" causes any file name with an extension of "c" to be searched for, and the directory information of the file first found is written in after DMA. To find all matching files or to see whether there is only one matching file, use function 12H described below.



* File search - 2



Function:	12H

Setup:		none

Return value:	00H is set in the A register when the file is found; otherwise 0FFH is set. When the file is found, the directory entry (32 bytes) of the file on the disk is set in the area indicated by DMA, and the FCB drive number is set (thus, 33 bytes are used).



This system call should be used to search for multiple files meeting the file name specification by wildcard characters in function 11H. So this function should not be used by itself.



This system call allows the directory information of files meeting the specifications in function 11H to be listed in order, one by one.



* Deleting files



Function:	13H

Setup:		DE register <-- starting address of FCB which is not opened Return value:	00H is set in the A register when file is successfully deleted., otherwise 0FFH is set.



Using wildcard characters for the file name may cause more than one file to be deleted. Exercise caution when using wildcards to delete files.



* Sequential readout



Function:	14H

Setup:		DE register <-- starting address of opened FCB

FCB current block <-- starting block for readout FCB current record <-- starting record for readout Return value:	00H is set in the A register when readout is successful; otherwise 01H is set. When successful, one record which has been read is set in the area indicated by DMA.



The FCB current block and record will be updated automatically after the readout. That is, in successive readouts, the current block and record do not need to be set. The record size for readout is fixed at 128 bytes.



* Sequential writing to the disk



Function:	15H

Setup:		DE register <-- starting address of opened FCB

FCB current block <-- starting block for writing FCB current record <-- starting record for writing 128 bytes starting from DMA <-- data to be written Return value:	00H is set in the A register when writing is successful; otherwise 01H is set.



The FCB current block and record will be updated automatically after the readout.



* Creating files



Function:	16H

Setup:		DE register <-- starting address of FCB which is not opened Retu4rn value:	00H is set in the A register when the file is created successfully; otherwise 0FFH is set.



The record size, current block and record, and the random record of the FCB

should be set after executing this system call.



* Renaming files



Function:	17H

Setup:		New file name should be set within 11 bytes after the 18th byte of the FCB (2nd byte of file size field of FCB = 16 bytes after old file name) corresponding to old file name (that is, it should be set in 18th to 28th byte), the FCB address should be set in the DE register.

Return value:	00H is set in the A register when the file name is renamed successfully; otherwise 0FFH is set.



Wildcard characters can be used for both the new and old file names. For example, specifying "????????.o" for the old file name and "????????.obj" for the new file name causes the extension of all files having ".o" to be changed to ".obj".



* Random reading from the disk



Function:	21H

Setup:		DE register <-- starting address of opened FCB

random record in FCB <-- record for readout Return value:	00H is set in the A register when readout is successful; otherwise 01H is set. When successful, the contents of one record which has been read are set in the area indicated by DMA.



The lenght of the record is fixed to 128 bytes.



* Random writing to the disk



Function:	22H

Setup:		DE register <-- starting address of opened FCB

random record in FCB <-- record to be written to 128 bytes starting from DMA <-- data to be written Return value:	00H is set in the A register when writing is successful; otherwise 01H is set.



The lenght of the record is fixed to 128 bytes.



* File size acquisition



Function:	23H

Setup:		DE register <-- starting address of FCB which is not opened Return value:	00H is set in the A register when the function is successful; otherwise 00H is set. When successful, the size of the specified file is set in increments of 128 bytes, in the first three bytes of the random record field.



The file size is calculated in increments of 128 bytes. That is, 2 would be set for files ranging in size from 129 bytes to 256 bytes. Thus a file with 257 bytes would return a value of 3.



* Random record field setting



Function:	24H

Setup:		DE register <-- starting address of opened FCB

FCB current block <-- objective block FCB current record <-- objective record Return value:	Current record position, calculated from the current block and record fields of specified FCB, is set in the random record field.



* Random writing to the disk - 2 (random block access)

Function:	26H

Setup:		DE register <-- the starting address from the FCB

FCB record size <-- size of record to be written FCB random record <-- the record ID number HL register <-- the number of records to be written DMA memory buffer <-- the data to be written Return value:	00H is set in the A register when writing is successful; otherwise 01H is set.



After writing to the disk, the value of the random record field is automatically updated and points to the next record. The size of one record can be set to any value from 1 byte to 65535 bytes by setting the desired value in the FCB record size field. When 0 records are to be written, the file lenght is calculated at the record size multiplied by the record number.

The rest is discarded.



This system call has been created for MSX-DOS and is not compatible with CP/M.



* Random readout - 2 (random block access)

Function:	27H

Setup:		DE register <-- starting address of opened FCB

FCB record size <-- record size to be read FCB random record <-- record to start reading HL register <-- number of records to be read Return value:	00H is set in the A register when data is read successfully; otherwise 01H is read. The number of records actually read is set back in the HL register. When this number is almost one, the data which has been read is set in the area indicated by DMA.



After readout, the random record field is automatically updated. After executing this system call, the total number of records actually read is set in the HL register. That is, if the end of file is reached before the specified number of records have been read, the actual number of records read will be returned in the HL register.



This system call has been created for MSX-DOS and is not compatible with CP/M.



* Random writing - 3



Function:	28H

Setup:		DE register <-- starting address of opened FCB

FCB random record <-- record to be written 128 bytes in DMA buffer <-- data to be written Return value:	00H is set in the A register when writing is successful; otherwise, 01H is set.



The lenght of records is fixed at 128 bytes.



This system call is the same as 22H except for one point. When the file becomes large, 00H is written to the added records coming before the specified record.



List 3.5 File dump

=========================================================================



;********************************************************

;

; List 3.5	file dump

;

;		this program must link List 3.3

;

;********************************************************

;

EXTRN	GETARG		Note: gets the dump list of the file EXTRN	STOHEX		 specified at the command line EXTRN	PUTCHR

EXTRN	PUTHEX

EXTRN	DUMP8B



BDOS:	EQU	0005H		Note: The file name specified as the first FCB:	EQU	005CH		 parameter of the command line is stored in the default FCB area from (005CH)



;----- program start -----



LD	DE,FCB		;DE := default FCB address LD	C,0FH		;open file function CALL	BDOS

OR	A		;success ?

JR	Z,READ		;if so, goto READ



LD	DE,ERMSG1	;[DE] := 'Cannot open that file'

LD	C,09H		;string output function CALL	BDOS

RET			;error return

READ:	LD	A,2

CALL	GETARG		;get 2nd argument of command line CALL	STOHEX		;HL := value of the argument LD	(ADRS),HL	;set address counter

LD	DE,NEWDMA

LD	C,1AH		;set DMA address function CALL	BDOS



LD	HL,8

LD	(FCB+14),HL	;record size := 8



LD	HL,0

LD	(FCB+33),HL

LD	(FCB+35),HL	;random record := 0



RD1:	LD	HL,NEWDMA	;clear DMA area

LD	B,8

RD2:	LD	(HL)," "

INC	HL

DJNZ	RD2



LD	HL,1		;read 1 record LD	DE,FCB

LD	C,27H		;random block read function CALL	BDOS

OR	A		;success ?

JR	Z,DUMP		;if so, goto DUMP



LD	DE,ERMSG2	;[DE] := 'Ok.'

LD	C,09H		;string output function CALL	BDOS

RET



DUMP:	LD	HL,(ADRS)

LD	A,H

CALL	PUTHEX

LD	A,L

CALL	PUTHEX

LD	A," "

CALL	PUTCHR

LD	DE,8

ADD	HL,DE

LD	(ADRS),HL



LD	HL,NEWDMA

CALL	DUMP8B		;dump 8 bytes

JR	RD1



;----- work area -----



ADRS:	DS	2

NEWDMA: DS	8



;----- error message -----



ERMSG1: DB	"Cannot open that file.$"

ERMSG2: DB	"Ok.$"



END



=========================================================================





MSX2 TECHNICAL HANDBOOK

-----------------------



Edited by:		ASCII Systems Division

Published by:		ASCII Coprporation - JAPAN

First edition:		March 1987

<i>

Text files typed by:	Nestor Soriano (Konami Man) - SPAIN

March 1997



Changes from the original:



- In Figure 4.3, "Port#17" indication is corrected to "R#17".



- In Figure 4.4, "00" field in R#17 is corrected to "10".



- In section 3.2.2, subsection "Pattern name table", text "12 low order bits o the address (A9 to A0)" is corrected to "12 low order bits of the address (A11 to A0)"



- In Figure 4.17, the numerations of the two last rows in the Screen correspondence table, originally "22" and "23", are corrected to "25" and "26" respectively.



- In section 3.2.2, subsection "Blink table", the text "the 9 low order bits of the address (A9 to A0)" is corrected to "the 8 low order bits of the address (A8 to A0)".



- In Figure 4.25, indication "Specifies the value of the screen (0 to 15)" is changed to "Specifies the border colour (0-15)".



- In Figure 4.34, in the screen correspondance table, the three stages of the screen are named "Upper stage of screen" in the original. This is corrected, and the stages are named "Upper", "Middle" and "Lower".



- The title of section 3.6.3 is "Screen colour mode specification" in the original. The word "mode" is erased.



- In section 3.8.2, the text "by writing the 2 high order bits" is corrected to "by writing the high order bit".



- The title of Figure 4.63 is "Judging the conflict (sprite mode 2)" in the original. This is corrected to "Judging the conflict (sprite mode 1)".



- In Figure 4.68, indication "Color code = 8 or 4 or 12" is changed to "Color code = 8 or 4 = 12".

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



CHAPTER 4 - VDP AND DISPLAY SCREEN (Parts 1 to 5)

The MSX2 machines uses an advanced VDP (video display processor) for its display screen, the V9938 (MSX-VIDEO). This LSI chip allows for several new graphics features to be accessed by the MSX2 video display. It is also fully compatible with the TMS9918A used in the MSX1.



Chapter 4 describes how to use this video display processor. It describes functions not accessible by BASIC. For mode details (e.g. hardware specifications, see V9938 MSX-VIDEO Technical Data Book (ASCII)).





1. MSX-VIDEO CONFIGURATION




The following features of the MSX-VIDEO give it a better display capabilities than the TMS9918A:



* 512 colours with a 9-bit colour palette * Max. 512 x 424 dot resolution (when using the interlace) * Max. 256 colours at the same time

* Full bitmap mode which makes graphic operations easy * Text display mode of 80 characters per line * LINE, SEARCH, AREA-MOVE executable by hardware * Up to 8 sprites on the same horizontal line * Different colours can be specified for each line in a sprite * Video signal digitizing feature built-in * Superimpose feature built-in





1.1 Registers




MSX-VIDEO uses 49 internal registers for its screen operations. These registers are referred to as "VDP registers" in this book. VDP registers are classified by function into three groups as described below. The control register group and status register group can be referred to using VDP(n) system variables from BASIC.



(1) Control register group (R#0 to R#23, R#32 to R#46)

This is a read-only 8-bit register group controlling MSX-VIDEO actions.

Registers are expressed using the notation R#n. R#0 to R#23 are used to set the screen mode. R#32 to R#46 are used to execute VDP commands. These VDP

commands will be described in detail in section 5. Control registers R#24 to R#31 do not exist. The roles of the different control registers are listed in Table 4.1.



Table 4.1 Control register list

-----------------------------------------------------------------------------

| | Corres- |							 |

| R#n | ponding |			 Function			 |

| | VDP(n) |							 |

|------+---------+----------------------------------------------------------|

| R#0 | VDP(0) | mode register #0					 |

| R#1 | VDP(1) | mode register #1					 |

| R#2 | VDP(2) | pattern name table					 |

| R#3 | VDP(3) | colour table (LOW)					 |

| R#4 | VDP(4) | pattern generator table				 |

| R#5 | VDP(5) | sprite attribute table (LOW) 			 |

| R#6 | VDP(6) | sprite pattern generator table			 |

| R#7 | VDP(7) | border colour/character colour at text mode		 |

| R#8 | VDP(9) | mode register #2					 |

| R#9 | VDP(10) | mode register #3					 |

| R#10 | VDP(11) | colour table (HIGH)					 |

| R#11 | VDP(12) | sprite attribute table (HIGH)			 |

| R#12 | VDP(13) | character colour at text blinks			 |

| R#13 | VDP(14) | blinking period					 |

| R#14 | VDP(15) | VRAM access address (HIGH)				 |

| R#15 | VDP(16) | indirect specification of S#n			 |

| R#16 | VDP(17) | indirect specification of P#n			 |

| R#17 | VDP(18) | indirect specification of R#n			 |

| R#18 | VDP(19) | screen location adjustment (ADJUST)			 |

| R#19 | VDP(20) | scanning line number when the interrupt occurs	 |

| R#20 | VDP(21) | colour burst signal 1				 |

| R#21 | VDP(22) | colour burst signal 2				 |

| R#22 | VDP(23) | colour burst signal 3				 |

| R#23 | VDP(24) | screen hard scroll					 |

| |	 |							 |

| R#32 | VDP(33) | SX: X-coordinate to be transferred (LOW)		 |

| R#33 | VDP(34) | SX: X-coordinate to be transferred (HIGH)		 |

| R#34 | VDP(35) | SY: Y-coordinate to be transferred (LOW)		 |

| R#35 | VDP(36) | SY: Y-coordinate to be transferred (HIGH)		 |

| R#36 | VDP(37) | DX: X-coordinate to be transferred to (LOW)		 |

| R#37 | VDP(38) | DX: X-coordinate to be transferred to (HIGH) 	 |

| R#38 | VDP(39) | DY: Y-coordinate to be transferred to (LOW)		 |

| R#39 | VDP(40) | DY: Y-coordinate to be transferred to (HIGH) 	 |

| R#40 | VDP(41) | NX: num. of dots to be transferred in X direction (LOW) |

| R#41 | VDP(42) | NX: num. of dots to be transferred in X direction (HIGH) |

| R#42 | VDP(43) | NY: num. of dots to be transferred in Y direction (LOW) |

| R#43 | VDP(44) | NY: num. of dots to be transferred in Y direction (HIGH) |

| R#44 | VDP(45) | CLR: for transferring data to CPU			 |

| R#45 | VDP(46) | ARG: bank switching between VRAM and expanded VRAM	 |

| R#46 | VDP(47) | CMR: send VDP command				 |

-----------------------------------------------------------------------------



(2) Status register (S#0 to S#9)



This is a read-only 8-bit register group which reads data from MSX-VIDEO.

Registers are expressed using the notation S#n. The functions of the registers are listed in Table 4.2.



Table 4.2 Status register list

-----------------------------------------------------------------------------

| | Corres- |							 |

| S#n | ponding |			 Function			 |

| | VDP(n) |							 |

|------+---------+----------------------------------------------------------|

| S#0 | VDP(8) | interrupt information				 |

| S#1 | VDP(-1) | interrupt information				 |

| S#2 | VDP(-2) | DP command control information/etc.			 |

| S#3 | VDP(-3) | coordinate detected (LOW)				 |

| S#4 | VDP(-4) | coordinate detected (HIGH)				 |

| S#5 | VDP(-5) | coordinate detected (LOW)				 |

| S#6 | VDP(-6) | coordinate detected (HIGH)				 |

| S#7 | VDP(-7) | data obtained by VDP command 			 |

| S#8 | VDP(-8) | X-coordinate obtained by search command (LOW)	 |

| S#9 | VDP(-9) | X-coordinate obtained by search command (HIGH)	 |

-----------------------------------------------------------------------------



(3) Colour palette register group (P#0 to P#15)

These registers are used to set the colour palette. Registers are expressed using the notation P#n where 'n' is the palette number which represents one of 512 colours. Each palette register has 9 bits allowing three bits to be used for each RGB colour (red, green, and blue).





1.2 VRAM




MSX-VIDEO can be connected with 128K bytes VRAM (Video RAM) and 64K bytes expanded RAM. MSX-VIDEO has a 17-bit counter for accessing this 128K bytes address area. Note that this memory is controlled by MSX-VIDEO and cannot be directly accessed by the CPU.



Expanded RAM memory cannot be directly displayed to the screen as can that of VRAM. However, it can be manipulated the same as VRAM when using the video processor commands. This large work area is very useful when processing screen data. Note that the MSX standard does not include instructions regarding expanded RAM, so taking advantage of this in program design could result in compatibility problems with other MSX machines.



Figure 4.1 VRAM and expanded RAM



Address counter

----------------- 00000H	-----------------

|		|	|	|		|

|		|	|	|		|

|		|	|	|		|

|		|	|	|		|

|---------------| 0FFFFH	-----------------

|		|	|	 RAM

|		|	|	 (data use) |		|	|

|		|	|

----------------- 1FFFFH

VRAM

(screen use)



1.3 I/O ports



MSX-VIDEO has four I/O ports that send data back and forth the CPU. The functions of these ports are listed in Table 4.3. The ports are accessed by the CPU through its I/O addresses in the table below, addresses expressed as n, n' are stored at address locations 6 and 7 in MAIN-ROM. Although n = n' =

98H normally, this can be different on some machines, so port addresses should be obtained from these addresses for reliable results.



It is generally recommended that BIOS be used for I/O operations for purposes of compatibility. However, the screen display often requires high speed, so these I/O ports are capable of accessing MSX-VIDEO directly.



Table 4.3 MSX-VIDEO ports

----------------------------------------------------------------------

| Port	 | Address |		 Function		 |

|-----------------+---------+----------------------------------------|

| port #0 (READ) | n | read data from VRAM		 |

| port #0 (WRITE) | n' | write data to VRAM |

| port #1 (READ) | n + 1 | read status register		 |

| port #1 (WRITE) | n'+ 1 | write to control register |

| port #2 (WRITE) | n'+ 2 | write to palette register |

| port #3 (WRITE) | n'+ 3 | write to indirectly specified register |

----------------------------------------------------------------------



Note: The value of n should be obtained by referring to address 6 in MAIN-ROM

The value of n'should be obtained by referring to address 7 in MAIN-ROM





2. ACCESS TO MSX-VIDEO




MSX-VIDEO can be accessed directly through the I/O ports without going through BIOS. This chapter describes how to do this.





2.1 Access to Registers




2.1.1 Writing data to control registers

The control registers are write-only registers. As described above, the partial contents of control registers (R#0 to R#23) can be obtained by referring to VDP(n) from BASIC. This only reads the value which has been written in the work area of RAM (F3DFH to F3E6H, FFE7H to FFF6H) used for writing to registers.



There are three ways, described below, to write data to control registers.

Since MSX accesses MSX-VIDEO inside the timer interrupt routine to examine the occurrence of sprite conflicts, note that access procedure will not inhibiting the interrupt when the registers are accessed in the proper way as described below.



(1) Direct access



The first way is to directly specify the data and where it is to be written to. Figure 4.2 illustrates the procedure. The data is first written to port#1

and then the destination register number is written to port#1 using the five least significant bits. The most significant bit is set to 1 and the second bit is set to 0. Thus the value would be 10XXXXXB in binary notation where XXXXX is the destination register number.



Figure 4.2 Direct access to R#n

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

Port #1 | :	 : : Data	 : : :	| 1.Puts data to port #1.

-----------------------------------------



-----------------------------------------

Port #1 | 1 | 0 | R5 | R4 | R3 | R2 | R1 | R0 | 2. Then puts register ----------------------------------------- number with two |	 |				| high bits set to +---------+-----------------------------+ "10" to port #1.

fixed register number (0 to 46) at "10"



Port#1 is also used to set VRAM addresses and is described in section 2.2.

The most significant bit of the second byte sent to this port is the address/register flag and determines the operation to take place. When the bit is set to "1", writing data to a control register as described here will take place.



(2) Indirect Access (non-autoincrement mode)

The second way is to write data to the register specified as the objective register (R#17 contains the objective pointer). To begin with, store the register number to be accessed in R#17 by direct access. The most significant bit is set to 1 and the second bit to 0. Thus the value would be 10XXXXXB in binary notation where XXXXX is the objective register number. After this is done, data can be written to the objective register by sending data to port#3. This method is used for sending data to the same register continuously. An example would be for the execution of VDP commands.



Figure 4.3 Indirect access to R#n (non-autoincrement mode)

First byte



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#17	| 1 | 0 | R5 | R4 | R3 | R2 | R1 | R0 | 1.Set register number n ----------------------------------------- to R#17, with two high |	 |				| order bits set to "10".

+---------+-----------------------------+

fixed 	 n (0 to 46) at "10"



-----------------------------------------

Port#3	| :	 : : Data	 : : :	| 2.Send data to port#3.

----------------------------------------- The data is stored in register R#n.



Following bytes



-----------------------------------------

Port#3	| :	 : : Data	 : : :	| 3.After these are done, ----------------------------------------- data can be written to register R#n only by sending to port #3.



(3) Indirect Access (autoincrement mode)

The third way is to write date to the register indicated by R#17. R#17 is incremented each time data is sent to port#3. To begin with, store the beginning register number to be accessed in R#17 by direct access. The two most significant bits are set to 0. Thus the value would be 00XXXXXB in binary notation where XXXXX is the beginning register number.



Since this method allows writing data to continuous control registers effectively, it is useful when several continuous registers are to be changed at once. One example would be when the screen mode is changed.



Figure 4.4 Indirect access to R#n (autoincrement mode)

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#17	| 0 | 0 | R5 | R4 | R3 | R2 | R1 | R0 | 1.Set register number n ----------------------------------------- to R#17, with two high |	 |				| order bits set to "00".

+---------+-----------------------------+

fixed 	 n (0 to 46) at "00"



-----------------------------------------

Port#3	| :	 : : Data	 : : :	| 2.Send data to port#3.

----------------------------------------- The data is stored in register R#n.



-----------------------------------------

Port#3	| :	 : : Data	 : : :	| 3.Data sent to next ----------------------------------------- port#3 is stored to register R#(n+1).

.				 .

.				 .

.				 .



2.1.2 Setting a palette



To set data in the MSX-VIDEO palette registers (P#0 to P#15), specify the palette register number in the four lowest significant bits of R#16 (color palette pointer), and then send the data to port#2. Since palette registers have a length of 9 bits, data must be sent twice; red brightness and blue brightness first, then green brightness. Brightness is specified in the lower three bits of a four bit segment. Refer to Figure 4.5 for details.



After data is sent to port#2 twice, R#16 is automatically incremented. This feature makes it easy to initialize all the palettes.



Figure 4.5 Setting a colour palette register

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#16	| 0 | 0 | 0 | 0 | R3 | R2 | R1 | R0 | 1.Set palette number n ----------------------------------------- to R#16, with four |		 |			| high order bits set +---------------------------------------+ to "0000".

fixed at "0000" n (0 to 15)

-----------------------------------------

Port#2	| | Red bright. |	 | Blue bright. | 2.Send red and blue ----------------------------------------- brightness to port#2.

|		 |	 |		|

+--------------+	 +--------------+

0 to 7	 0 to 7



-----------------------------------------

Port#2	| |	 | | |	 | Green bright.| 2.Send green brightness ----------------------------------------- to port#2. (*) |		|

+--------------+

0 to 7



(*) Since R#16 is incremented at this point, setting next palette can be done by sending data to port#2 continuously.



2.1.3 Reading status registers



Status registers are read-only registers. Their contents can be read from port#1 by setting the status register number in the least significant four bits of R#15 (status register pointer) as shown in Figure 4.6. The four most significant bits are set to 0. Thus the value would be 0000XXXXB in binary notation where XXXX is the status register number. Interrupts should be inhibited before the status register is accessed. After the desired task is completed, R#15 should be set to 0 and the interrupts released.



Figure 4.6 Acessing status registers

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#15	| 0 | 0 | 0 | 0 | R3 | R2 | R1 | R0 | 1.Set register number n ----------------------------------------- to R#15, with four |		 |			| high order bits set +-------------------+-------------------+ to "0000".

fixed at "0000" n (0 to 9)

-----------------------------------------

Port#1	| :	 : : Data	 : : :	| 2.Read data from port#1.

-----------------------------------------





2.2 VRAM Access From the CPU




When a VRAM address is to be accessed from the CPU, follow the procedure described below.



(1) Bank switching



The first 64K bytes of VRAM (00000H to 0FFFFH) and the 64K bytes of expanded RAM both reside at the same address space as viewed by MSX-VIDEO. Bank switching is used so that they can both be online at the same time. Since MSX2 does not to use expanded VRAM, always select the VRAM bank. Bank switching is controlled by bit 6 of R#45.



Figure 4.7 VRAM/expanded RAM bank switching

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#45	| . | X | . | . | . | . | . | .	| When bit 6 of R#45 is "0"

----------------------------------------- VRAM is selected; when it | 0:VRAM			 is 1, expanded RAM is +-->				 selected.





1:Expanded RAM




(2) Setting the VRAM page (three high order bits)

The 17-bit address for accessing the 128K bytes of VRAM is set in the address counter (A16 to A0). R#14 contains the three high order bits (A16 to A14). So this register can be viewed as switching between eight 16K byte pages of VRAM.



Figure 4.8 Setting the VRAM page (3 high order bits)

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#14	| 0 | 0 | 0 | 0 | 0 | A16| A15| A14| Set 3 high order bits of ----------------------------------------- address counter in the field from bit 2 to bit 0

on R#14.



(3) Setting the VRAM address (14 low order bits)

The 14 low order bits of the address should be sent to port#1 in two bytes.

Figure 4.9 shows the details. Make sure that the most significant bit of the second byte sent is set to 0. This sets the address/register flag to address mode. The second most significant bit sets the read/write flag. 1 signifies writing to VRAM and 2 signifies reading from VRAM.



Figure 4.9 Setting 14 low order bits

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

Port#1	| A7 | A6 | A5 | A4 | A3 | A2 | A1 | A0 | 1.Send A7 to A0 to ----------------------------------------- port#1.



-----------------------------------------

Port#1	| 0 |	 | A13| A12| A11| A10| A9 | A8 | 2.Send A13 to A8 to ----------------------------------------- port#1, continuously.

| | 0:reading VRAM		 Bit 7 must be set to "0" +--> "0". Bit 6 determines 1:writing VRAM		 reading/writing data.



(4) Reading/writing VRAM



After setting the value in the address counter, read or write data through port#0. The read/write flag is set the same time as A13 to A8 of the address counter, as described above.



The address counter is automatically incremented each time a byte of data is read or written to port #0. This feature allows for easy access of continuous memory in VRAM.



Figure 4.10	Access to VRAM through port#0



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

Port#0	| D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0 | Access to VRAM is done ----------------------------------------- through port#0. Address counter is automatically incremented.





3. SCREEN MODES OF THE MSX2




The MSX2 has ten different modes as shown in Table 4.4. Six screen modes marked with "*" in the table below (TEXT 2 and GRAPHIC 3 to GRAPHIC 7) have been introduced for the MSX2. The other modes have been improved due to the change from TMS9918A to MSX-VIDEO. Fetures of these ten screen modes and how to use them are described below.



Table 4.4 Screen modes listing of MSX2



--------------------------------------------------------------------------

| Mode Name | SCREEN mode |		 Description		 |

|-------------+-------------+--------------------------------------------|

| TEXT 1 | SCREEN 0 | 40 characters per line of text, one colour |

|	 | (width=40) | for each character			 |

|-------------+-------------+--------------------------------------------|

| * TEXT 2 | SCREEN 0 | 80 characters per line of text,		 |

|	 | (width=80) | character blinkable selection		 |

|-------------+-------------+--------------------------------------------|

| MULTI-COLOR | SCREEN 3 | pseudo-graphic, one character		 |

|	 | 	 | divided into four block			 |

|-------------+-------------+--------------------------------------------|

| GRAPHIC 1 | SCREEN 1 | 32 characters per one line of		 |

|	 | 	 | text, the COLOURed character available	 |

|-------------+-------------+--------------------------------------------|

| GRAPHIC 2 | SCREEN 2 | 256 x 192, the colour is			 |

|	 | 	 | specififed for each 8 dots		 |

|-------------+-------------+--------------------------------------------|

| * GRAPHIC 3 | SCREEN 4 | GRAPHIC 2 which can use sprite		 |

|	 | 	 | mode 2					 |

|-------------+-------------+--------------------------------------------|

| * GRAPHIC 4 | SCREEN 5 | 256 x 212; 16 colours are 		 |

|	 | 	 | available for each dot			 |

|-------------+-------------+--------------------------------------------|

| * GRAPHIC 5 | SCREEN 6 | 512 x 212; 4 colours are			 |

|	 | 	 | available for each dot			 |

|-------------+-------------+--------------------------------------------|

| * GRAPHIC 6 | SCREEN 7 | 512 x 212; 16 colours are 		 |

|	 | 	 | available for each dot			 |

|-------------+-------------+--------------------------------------------|

| * GRAPHIC 7 | SCREEN 8 | 256 x 212; 256 colours are		 |

|	 | 	 | available for each dot			 |

--------------------------------------------------------------------------





3.1 TEXT 1 Mode




TEXT 1 screen mode has the following features:

----------------------------------------------------------------------------

|									 |

| screen:		40 (horizontal) x 24 (vertical) 		 |

|			background/character colours can be selected from |

|			512 colours					 |

| character:		256 characters available			 |

|			character size: 6 (horizontal) x 8 (vertical)	 |

| memory requirements:	for character font ... 2048 bytes		 |

|					 (8 bytes x 256 characters) |

|			for display ........... 960 bytes		 |

|						(40 characters x 24 lines) |

| BASIC:		compatible with SCREEN 0 (WIDTH 40)		 |

|									 |

----------------------------------------------------------------------------



3.1.1 Setting TEXT 1 mode



MSX-VIDEO screen modes are set by using 5 bits of R#0 and R#1. Figure 4.11

shows the details. The 3-bit mask in R#0 is 000B and the 2-bit mask in R#1 is 10B when using the TEXT 1 mode.



Figure 4.11	Setting TEXT1 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | . | 0 | 0 | 0 | .	|

-----------------------------------------



-----------------------------------------

R#1	| . | . | . | 1 | 0 | . | . | .	|

-----------------------------------------



3.1.2 Screen structure of TEXT 1 mode

* Pattern generator table



The area in which character fonts are stored is called the pattern generator table. This table is located in VRAM, and, although the font is defined by using 8 bytes for each character from the top of the table, the 2 low order bits of each byte representing the right two columns are not displayed on the screen. Thus, the size of one character is 6 x 8 pixels. Each character font set contains 256 different characters numbered from 0 to 255. Use this code to specify which character should be displayed on the screen.



Specify the location of the pattern generator table in R#4. Note that the 6

high order bits of the address (A16 to A11) are specified and the 11 low order bits of the address (A10 to A0) are always 0 ("00000000000B"). So the address in which the pattern generator table can be set always begins at a multiple of 2K bytes from 00000H. This address can be found using the system variable BASE(2) from BASIC. Figure 4.12 shows the structure of the pattern generator table.



Figure 4.12	Structure of the pattern generator table

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#4	| 0 | 0 | A16| A15| A14| A13| A12| A11| ---+

----------------------------------------- |

|

+--------------------------------------------+

|

| MSB 7 6 5	 4 3 2	1 0	 LSB

|	----------------------------------------- --+

+---> 0 | |	 | # | |	 | | |	| |

|----+----+----+----+----+----+----+----| |

1 | | # | | # |	 | | |	| |

|----+----+----+----+----+----+----+----| |

2 | # |	 | | | # | | |	| |

|----+----+----+----+----+----+----+----| |

3 | # |	 | | | # | | |	| | Pattern #0

|----+----+----+----+----+----+----+----| |

4 | # | # | # | # | # | | |	| |

|----+----+----+----+----+----+----+----| |

5 | # |	 | | | # | | |	| |

|----+----+----+----+----+----+----+----| | ------

6 | # |	 | | | # | | |	| | | | = 0

|----+----+----+----+----+----+----+----| | ------

7 | |	 | | |	 | | |	| |

|----+----+----+----+----+----+----+----| --+

8 | # | # | # | # |	 | | |	| |

|----+----+----+----+----+----+----+----| | ------

9 | # |	 | | | # | | |	| | | # | = 1

|----+----+----+----+----+----+----+----| | ------

10 | # |	 | | | # | | |	| |

|----+----+----+----+----+----+----+----| |

11 | # | # | # | # |	 | | |	| |

|----+----+----+----+----+----+----+----| | Pattern #1

12 | # |	 | | | # | | |	| |

|----+----+----+----+----+----+----+----| |

13 | # |	 | | | # | | |	| |

|----+----+----+----+----+----+----+----| |

14 | # | # | # | # |	 | | |	| |

|----+----+----+----+----+----+----+----| |

15 | |	 | | |	 | | |	| |

----------------------------------------- --+

.			 .

.			 .

.			 .

----------------------------------------- --+

2040 | # |	 | # | | # | | |	| |

|----+----+----+----+----+----+----+----| |

2041 | | # | | # |	 | # | |	| |

|----+----+----+----+----+----+----+----| |

2042 | # |	 | # | | # | | |	| |

|----+----+----+----+----+----+----+----| |

2043 | | # | | # |	 | # | |	| |

|----+----+----+----+----+----+----+----| | Pattern #255

2044 | # |	 | # | | # | | |	| |

|----+----+----+----+----+----+----+----| |

2045 | | # | | # |	 | # | |	| |

|----+----+----+----+----+----+----+----| |

2046 | # |	 | # | | # | | |	| |

|----+----+----+----+----+----+----+----| |

2047 | | # | | # |	 | # | |	| |

----------------------------------------- --+

| 	|

+---------+

2 low order bits are not displayed

Pattern generator table

* Pattern name table



The pattern name table stores the characters to be displayed at each position on the screen. One byte of memory is used for each character to be displayed.

Figure 4.13 shows the correspondence between memory location and screen location.



Specify the location of the pattern generator table in R#2. Note that the 7

high order bits of the address (A16 to A10) are specified and that the 10 low order bits of the address (A9 to A0) are always 0 ("0000000000B"). So the address in which the name table can be set always begins at a multiple of 1K

bytes from 00000H. This address can be found by using the system variable BASE(0) from BASIC. Figure 4.13 shows the structure of the pattern generator table.



Figure 4.13	Structure of TEXT1 pattern name table

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#2	| 0 | A16| A15| A14| A13| A12| A11| A10| ---+

----------------------------------------- |

|

+--------------------------------------------+

|

|	|	 |

|	-----------

+---> 0 | (0,0) |	 0 1	2 3		 39 X

|---------|	 ---------------------- -------

1 | (1,0) |	 0 | 0 | 1 | 2 | 3	| . . . | 39 |

|---------|	 |----+----+----+----+- -+----|

2 | (2,0) |	 1 | 40 | 41 | 42 | 43 | . . . | 79 |

|---------|	 |----+----+----+----+- -+----|

. | .	 |	 |	 | | |	| . . . | |

. .		 .		 .		 .

. .		 .		 .		 .

|	 |	 .		 .		 .

|---------|	 |	 | | 		| |

39 | (39,0) |	 ------------	 -------

|---------|	 22 | 880| 881| 		| 919|

40 | (0,1) |	 |----+----+-	 -+----|

|---------|	 23 | 920| 921| 		| 959|

. | .	 |	 ------------ . .	. . .-------

. .		 Y

. .

|	 |		Screen correspondence table |---------|

959 | (39,23) |

|---------|

|	 |



Pattern Name Table

3.1.3 Specifying screen colour



The screen colour is specified by R#7. The background colour is the palette specified by the 4 low-order bits of R#7; the 4 high-order bits specify the foreground colour (see Figure 4.14). A "0" in the font pattern is displayed in the background colour and a "1" is displayed in the foreground colour.

Note that in TEXT 1 the border colour of the screen cannot be set and it is the same as the background colour.



Figure 4.14	Colour specification in TEXT 1



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#7	| :	 : : |	 : : :	|

-----------------------------------------

|		 |			|

+-------------------+-------------------+

Specifies the colour of "1" Specifies the colour of "0" of the pattern of the pattern (0 to 15) and of the background colour (0 to 15)





3.2 TEXT 2 Mode




The screen mode TEXT 2 has the following features:

----------------------------------------------------------------------------

|									 |

| screen:		80 (horizontal) x 24 (vertical) or 26.5 (vertical) |

|			background colour/character colour can be selected |

|			from 512 colours				 |

| character:		256 characters available			 |

|			character size: 6 (horizontal) x 8 (vertical)	 |

|			each character blinkable			 |

| memory requirements:	24 lines					 |

|			 for character font ... 2048 bytes		 |

|						(8 bytes x 256 characters) |

|			 for display .......... 1920 bytes		 |

|						(80 characters x 24 lines) |

|			 for blinking ......... 240 bytes (= 1920 bits) |

|			26.5 lines					 |

|			 for character font ... 2048 bytes		 |

|						(8 bytes x 256 characters) |

|			 for display .......... 2160 bytes		 |

|						(80 characters x 27 lines) |

|			 for blinking ......... 270 bytes (= 2160 bits) |

| BASIC:		compatible with SCREEN 0 (WIDTH 80)		 |

|									 |

----------------------------------------------------------------------------



3.2.1 Setting TEXT 2 mode



Set TEXT2 mode as shown in Figure 4.15.



Figure 4.15	Setting TEXT2 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | . | 0 | 1 | 0 | .	|

-----------------------------------------



-----------------------------------------

R#1	| . | . | . | 1 | 0 | . | . | .	|

-----------------------------------------



* Setting number of lines (24 lines/26.5 lines)

TEXT2 mode can switch the screen to 24 lines or 26.5 lines depending on the value of bit 7 in R#9. Note that, when the screen is set to 26.5 lines, only the upper half of the characters at the bottom of the screen are displayed.

This mode is not supported by BASIC.



Figure 4.16	Switching number of lines

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#9	| LN | . | . | . | . | . | . | .	|

-----------------------------------------

| 0:24 lines

+-->

1:26.5 lines



3.2.2 Screen structure of TEXT 2



* Pattern generator table



The pattern generator table has the same structure and function as the one of TEXT1. See the descriptions for TEXT1.



* Pattern name table



Since the number of characters to be displayed in the screen has been increased to 2160 (80 x 27) characters maximum, the maximum area occupied by the pattern name table is 2160 bytes.



Specify the location of the pattern name table in R#2. The 5 high order bits of the address (A16 to A12) are specified and the 12 low order bits of the address (A11 to A0) are always 0 ("000000000000B"). So the address in which the pattern name table can be set always begins at a multiple of 4K bytes from 00000H.



Figure 4.17	Structure of TEXT2 pattern name table

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#2	| 0 | A16| A15| A14| A13| A12| 1 | 1	| ---+

----------------------------------------- |

|

+--------------------------------------------+

|

|	|	 |

|	-----------

+---> 0 | (0,0) |	 0 1	2 3		 79 X

|---------|	 ---------------------- -------

1 | (1,0) |	 0 | 0 | 1 | 2 | 3	| . . . | 79 |

|---------|	 |----+----+----+----+- -+----|

2 | (2,0) |	 1 | 80 | 81 | 82 | 83 | . . . | 159|

|---------|	 |----+----+----+----+- -+----|

. | .	 |	 |	 | | |	| . . . | |

. .		 .		 .		 .

. .		 .		 .		 .

|	 |	 .		 .		 .

|---------|	 |	 | | 		| |

79 | (79,0) |	 |----+----+-	 -+----|

|---------|	 25 |2000|2001| 		|2079|

80 | (0,1) |	 |----+----+-	 -+----|

|---------|	 26 |2080|2081| 		|2159|

. | .	 |	 ------------ . .	. . .-------

. .		 Y

. .

|	 |		Screen correspondence table |---------|

2159 | (79,26) |

|---------|

|	 |



Pattern Name Table

* Blink table



In TEXT2 mode, it is possible to set the blink attribute for each character.

The blink table stores the information of the screen location of the characters blinked. One bit of the blink table corresponds to one character on the screen (that is, on the pattern name table). When the bit is set to "1" blinking is enabled for the corresponding character; when the bit is "0"

blinking is disabled.



Figure 4.18	Blink table structure of TEXT2



MSB 7 6 5	 4 3 2	1 0	 LSB

----------------------------------------- --+

R#3	| A13| A12| A11| A10| A9 | 1 | 1 | 1	| |

----------------------------------------- |

+--+

----------------------------------------- | |

R#10	| 0 | 0 | 0 | 0 | 0 | A16| A15| A14| | |

----------------------------------------- --+ |

|

+------------------------------------------------------+

|

| MSB 7	 6	 5	 4	 3	 2	 1	 0	 LSB

|	-----------------------------------------------------------------

+---> 0 | (0,0) | (1,0) | (2,0) | (3,0) | (4,0) | (5,0) | (6,0) | (7,0) |

|-------+-------+-------+-------+-------+-------+-------+-------|

1 | (8,0) | (9,0) |(10,0) |(11,0) |(12,0) |(13,0) |(14,0) |(15,0) |

|-------+-------+-------+-------+-------+-------+-------+-------|

| .	| .	| .	| .	| .	| .	| .	| .	|

.	 .	 .	 .	 .	 .	 .	 .

.	 .	 .	 .	 .	 .	 .	 .

|	|	|	|	|	|	|	|	|

|-------+-------+-------+-------+-------+-------+-------+-------|

269 |(72,26)|(73,26)|(74,26)|(75,26)|(76,26)|(77,26)|(78,26)|(79,26)|

-----------------------------------------------------------------



Blink table



Specify the starting address of the blink table by setting the 8 high order bits (A16 to A9) in R#3 and R#10. The location of the blink table is set by writing the 8 high order bits of the address (A16 to A9) in R#3 and R#10. The 9 low order bits of the address (A8 to A0) are always 0 ("000000000B"). So the address in which the blink table can be set always begins at a multiple of 512 bytes from 00000H.



3.2.3 Screen colour and character blink specification

The foreground colour is specified by the 4 high order bits of R#7 and the background colour by the 4 low order bits of R#7. Characters with a blink attribute of 1 defined by the blink table alternate between the blink colour and the colour specified in R#12.



Figure 4.19	Setting screen colour and blink colour

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#7	| :	 : : |	 : : :	| <-- original character ----------------------------------------- colour |		 |			|

+-------------------+-------------------+

Specifies the colour	Specifies the colour of "0" of the pattern of "1" of the pattern and of the background colour

-----------------------------------------

R#12	| :	 : : |	 : : :	| <-- character colour ----------------------------------------- when blinking |		 |			|

+-------------------+-------------------+

Specifies the colour of "1" Specifies the colour of "0" of of the pattern when blinking	the pattern when blinking

The blinking rate is set in R#13. The 4 high order bits define the display time in the original colour, and the 4 low order bits define the display time in the blink colour. The period of time is defined in units of 1/6 seconds.



Figure 4.20	Setting blink rate

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#13	| :	 T1 : |	 : T0 :	|

-----------------------------------------

|		 |			|

+-------------------+-------------------+

time to display the colour time to display the colour specified by R#12	 specified by R#7



--------------------		 -------- .... colour specified |<- T0/6 seconds ->|<- T1/6 seconds -> |	 in R#7

---------		 --------------------- ........... colour specified normal colour blinking colour		 in R#12



List 4.1 Blink example

=========================================================================



1000 '*********************************************************

1010 ' LIST 4.1 BLINK SAMPLE

1020 '*********************************************************

1030 '

1040 SCREEN 0 : WIDTH 80		'TEXT 2 mode 1050 ADR=BASE(1)			'TAKE COLOR TABLE ADDRESS

1060 '

1070 FOR I=0 TO 2048/8

1080 VPOKE ADR+I,0			'reset blink mode 1090 NEXT

1100 '

1110 VDP(7) =&HF1			'text color=15, back color=1

1120 VDP(13)=&H1F			'text color=1, back color=15

1130 VDP(14)=&H22			'set interval and start blink 1140 '

1150 PRINT "Input any character : ";

1160 '

1170 K$=INPUT$(1)

1180 IF K$<CHR$(28) THEN 1230

1190 IF K$>" " THEN GOSUB 1280

1200 PRINT K$;

1210 GOTO 1170

1220 '

1230 VDP(14)=0				'stop blink

1240 END

1250 '

1260 '----- set blink mode -----

1270 '

1280 X=POS(0) : Y=CSRLIN

1290 A=(Y*80+X)\8

1300 B=X MOD 8

1310 M=VAL("&B"+MID$("000000010000000",8-B,8)) 1320 VPOKE ADR+A,VPEEK(ADR+A) XOR M

1330 RETURN

=========================================================================





3.3 MULTI COLOUR Mode




The MULTI COLOUR mode is described below:

----------------------------------------------------------------------------

|									 |

| screen:		64 (horizontal) x 48 (vertical) blocks		 |

|			16 colours from 512 colours can be displayed	 |

|			at the same time				 |

| block:		block size is 4 (horizontal) x 4 (vertical) dots |

|			colour can be specified to each block		 |

| memory requirements:	for setting colours ........... 2048 bytes	 |

|			for specifying locations ...... 768 bytes	 |

| sprite:		sprite mode 1					 |

| BASIC:		compatible to SCREEN 3				 |

|									 |

----------------------------------------------------------------------------



3.3.1 Setting MULTI COLOUR mode



Set MULTI COLOUR mode as shown in Figure 4.21.



Figure 4.21	Setting MULTI COLOUR mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | . | 0 | 0 | 0 | .	|

-----------------------------------------



-----------------------------------------

R#1	| . | . | . | 0 | 1 | . | . | .	|

-----------------------------------------



* Pattern generator table



In this mode, patterns are constructed as 2 x 2 blocks and one pattern name corresponds to four patterns. The starting address on this table is specified in R#4. Since only the 6 high order bits (A16 to A11) of the address is specified, the pattern generator table can be located at intervals of 2K

bytes from 00000H (see Figure 4.22).



Figure 4.22	Pattern generator table structure of MULTI COLOUR



2 blocks

<-(8 dots) ->		 MSB 7	6 5	 4 3 2	 1 0 LSB

------------- ^ 	 ^ -----------------------------------------

| A | B | | 2 blocks | | "A" colour code | "B" colour code |

|-----+-----| | (8 dots) 2 bytes|-------------------+-------------------|

| C | D | | 	 | | "C" colour code | "D" colour code |

------------- V 	 V -----------------------------------------



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#4	| 0 | 0 | A16| A15| A14| A13| A12| A11| -----+

----------------------------------------- |

|

+------------------------------------------------------+

|

|				 MSB 7 6 5 4 3 2 1 0 LSB

| | 		| --------- ---------------------------------

+---> |-----------------| 0 | A | B | | "A" col. code | "B" col. code |

| Pattern name #0 | |---+---| |---------------+---------------|(1) | (8 bytes)	| | C | D | | "C" col. code | "D" col. code |

|-----------------| 8 --------- ---------------------------------

| Pattern name #1 |

| (8 bytes)	| --------- ---------------------------------

|-----------------| 16 | E | F | | "E" col. code | "F" col. code |

| .	| |---+---| |---------------+---------------|(2) .	 | G | H | | "G" col. code | "H" col. code |

.	 --------- ---------------------------------

| 		|

|-----------------| 2040 --------- ---------------------------------

| Pattern name#255| | I | J | | "I" col. code | "J" col. code |

| (8 bytes)	| |---+---| |---------------+---------------|(3) |-----------------| 2048 | K | L | | "K" col. code | "L" col. code |

| 		| --------- ---------------------------------



Pattern generator table --------- ---------------------------------

| M | N | | "M" col. code | "N" col. code |

|---+---| |---------------+---------------|(4) | O | P | | "O" col. code | "P" col. code |

--------- ---------------------------------



(1) This table is in effect when Y is 0, 4, 8, 12, 16, or 20

(2) This table is in effect when Y is 1, 5, 9, 13, 17, or 21

(3) This table is in effect when Y is 2, 8, 10, 14, 18, or 22

(4) This table is in effect when Y is 3, 7, 11, 15, 19, or 23



* Pattern name table



This is the table for displaying specified patterns at desired locations on the screen. One of four patterns in a pattern name is displayed at its Y-coordinate value. BASIC sets the contents of this table as shown in Figure 4.23. The starting address of the pattern name table is specified by R#2.

Since only the 7 high order bits of the address (A16 to A10) are specified, the address at which this table can be set is at increments of 1K bytes from 00000H (see Figure 4.24).



Figure 4.23	Setting BASIC pattern name table

Pattern 0

X	 0 1 2 3 4 5 . . . 26 27 28 29 30 31

--------- Y	-------------------------- --------------------------

| |	| 0 | 0 | 1 | 2 | 3 | 4 | 5 | . . . | 26| 27| 28| 29| 30| 31|

|---+---|	|---+---+---+---+---+---+- -+---+---+---+---+---+---|

| |	| 1 | 0 | 1 | 2 | 3 | 4 |		 | 27| 28| 29| 30| 31|

|---+---| ----> |---+---+---+---+---+-		 -+---+---+---+---+---|

| |	| 2 | 0 | 1 | 2 | 3 |			| 28| 29| 30| 31|

|---+---|	|---+---+---+---+-		 -+---+---+---+---|

| |	| 3 | 0 | 1 | 2 | 3 | . . . . . . . . . . . | 28| 29| 30| 31|

|---+---|	|---+---+---+---+-		 -+---+---+---+---|

| |	| 4 | 32| 33| 34| 35|			| 60| 61| 62| 63|

|---+---|	|---+---+---+---+-		 -+---+---+---+---|

| |	| 5 | 32| 33| .				 . | 62| 63|

|---+---|	|---+---+-.				 .-+--------

| |	| 6 | 32|	 .				 . | 63|

|---+---|	|---+-	 .				 . -+---|

| |	| 7 | 32|	 .				 . | 63|

---------	|---+-	 .				 . -+---|

8 | 64|	 .	 (64 x 64 blocks)	 . | 95|

Pattern 0	|---+-	 .				 . -+---|

appears . | 64|	 .				 . | 95|

here as a . |---+-	 .				 . -+---|

result	 . 	 .				 . .

. 	 . --------- 		 . .

. 	 . | | | 1 data unit	 . .

. ----+-	 . |---+---| corresponds	 . -+----

. |128|	 . | | | to a 2 x 2 block . |159|

|---+-	 . --------- 		 . -+---|

20 |160|	 .				 . |191|

|---+---+-.				 .-+---+---|

21 |160|161| .				 . |190|191|

|---+---+---+---+-		 -+---+---+---+---|

22 |160|161|162|163| . . . . . . . . . . . |188|189|190|191|

|---+---+---+---+---+---+- -+---+---+---+---+---+---|

23 |160|161|162|163|164|165| . . . |186|187|188|189|190|191|

-------------------------- --------------------------



Figure 4.24	Pattern name table structure of MULTI COLOUR mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#2	| 0 | A16| A15| A14| A13| A12| A11| A10| ---+

----------------------------------------- |

|

+--------------------------------------------+

|

|	|	 |

|	|----------

+---> 0 | (0,0) |	 0 1	2 3		 31 X

|---------|	 ---------------------- -------

1 | (1,0) |	 0 | 0 | 1 | 2 | 3	| . . . | 31 |

|---------|	 |----+----+----+----+- -+----|

2 | (2,0) |	 1 | 32 | 33 | 34 | 35 | . . . | 63 |

|---------|	 |----+----+----+----+- -+----|

. | .	 |	 |	 | | |	| . . . | |

. .		 .		 .		 .

. .		 .		 .		 .

|	 |	 .		 .		 .

|---------|	 |	 | | 		| |

31 | (31,0) |	 |----+----+-	 -+----|

|---------|	 22 | 704| 705| 		| 735|

32 | (0,1) |	 |----+----+-	 -+----|

|---------|	 23 | 736| 737| 		| 767|

. | .	 |	 ------------ . .	. . .-------

. .		 Y

. .

|	 |		Screen correspondence table |---------|

767 | (31,23) |

|---------|

|	 |



Pattern Name Table

3.3.3 Specifying the screen colour in MULTI COLOUR mode

The border colour of the screen can be specified by R#7 (see Figure 4.25).



Figure 4.25	Border colour specification

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#7	| :	 : : |	 : : :	|

-----------------------------------------

|		 |			|

+-------------------+-------------------+

invalid	 specifies the border colour of the screen (0 to 15)





3.4 GRAPHIC 1 Mode




GRAPHIC 1 Mode is the screen mode as shown below:

----------------------------------------------------------------------------

|									 |

| screen:		32 (horizontal) x 24 (vertical) patterns	 |

|			16 from 512 colours can be displayed		 |

|			at the same time				 |

| pattern:		256 kinds of patterns are available		 |

|			pattern size is 8 (horizontal) x 8 (vertical) dots |

|			any Figure can be defined for each pattern	 |

|			different colour for each 8 pattern can be set	 |

| memory requirements:	for pattern font .............. 2048 bytes	 |

|			for colour tbale .............. 32 bytes	 |

| sprite:		sprite mode 1					 |

| BASIC:		compatible with SCREEN 1			 |

----------------------------------------------------------------------------



3.4.1 Setting GRAPHIC 1 mode



GRAPHIC 1 mode can be set as shown in Figure 4.26.



Figure 4.26	Setting GRAPHIC 1 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | . | 0 | 0 | 0 | .	|

-----------------------------------------



-----------------------------------------

R#1	| . | . | . | 0 | 0 | . | . | .	|

-----------------------------------------



3.4.2 Screen structure of GRAPHIC 1 mode

* Pattern generator table



In this mode, 256 kinds of patterns, corresponding to codes 0 to 255, can be displayed on the screen. Fonts of each pattern are defined in the pattern generator table (see Figure 4.27). The starting address of the pattern generator table is specified by R#4. Note that only the 6 high order bits of the address (A16 to A11) are specified.



Figure 4.27	Pattern generator table of GRAPHIC 1 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#4	| 0 | 0 | A16| A15| A14| A13| A12| A11| ---+

----------------------------------------- |

|

+--------------------------------------------+

|

| MSB 7 6 5	 4 3 2	1 0	 LSB

|	----------------------------------------- --+

+---> 0 | |	 | # | |	 | | |	| |

|----+----+----+----+----+----+----+----| |

1 | | # | | # |	 | | |	| |

|----+----+----+----+----+----+----+----| |

2 | # |	 | | | # | | |	| |

|----+----+----+----+----+----+----+----| |

3 | # |	 | | | # | | |	| | Pattern #0

|----+----+----+----+----+----+----+----| |

4 | # | # | # | # | # | | |	| |

|----+----+----+----+----+----+----+----| |

5 | # |	 | | | # | | |	| |

|----+----+----+----+----+----+----+----| | ------

6 | # |	 | | | # | | |	| | | | = 0

|----+----+----+----+----+----+----+----| | ------

7 | |	 | | |	 | | |	| |

|----+----+----+----+----+----+----+----| --+

8 | # | # | # | # |	 | | |	| |

|----+----+----+----+----+----+----+----| | ------

9 | # |	 | | | # | | |	| | | # | = 1

|----+----+----+----+----+----+----+----| | ------

10 | # |	 | | | # | | |	| |

|----+----+----+----+----+----+----+----| |

11 | # | # | # | # |	 | | |	| |

|----+----+----+----+----+----+----+----| | Pattern #1

12 | # |	 | | | # | | |	| |

|----+----+----+----+----+----+----+----| |

13 | # |	 | | | # | | |	| |

|----+----+----+----+----+----+----+----| |

14 | # | # | # | # |	 | | |	| |

|----+----+----+----+----+----+----+----| |

15 | |	 | | |	 | | |	| |

----------------------------------------- --+

.			 .

.			 .

.			 .

----------------------------------------- --+

2040 | # |	 | # | | # | | |	| |

|----+----+----+----+----+----+----+----| |

2041 | | # | | # |	 | # | |	| |

|----+----+----+----+----+----+----+----| |

2042 | # |	 | # | | # | | |	| |

|----+----+----+----+----+----+----+----| |

2043 | | # | | # |	 | # | |	| |

|----+----+----+----+----+----+----+----| | Pattern #255

2044 | # |	 | # | | # | | |	| |

|----+----+----+----+----+----+----+----| |

2045 | | # | | # |	 | # | |	| |

|----+----+----+----+----+----+----+----| |

2046 | # |	 | # | | # | | |	| |

|----+----+----+----+----+----+----+----| |

2047 | | # | | # |	 | # | |	| |

----------------------------------------- --+



Pattern generator table

* Colour table



The colour specification for each of the 8 patterns are done by the colour table. Colours for "0" and "1" of the bit of each pattern can be specified (see Figure 4.28). The starting address of the colour table is specified by R#3 and R#10. Note that only the 11 high order bits of the address (A16 to A6) are specified.



Figure 4.28	Colour table structure of GRAPHIC 1 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

----------------------------------------- --+

R#3	| A13| A12| A11| A10| A9 | A8 | A7 | A6 | |

----------------------------------------- |

+--+

----------------------------------------- | |

R#10	| 0 | 0 | 0 | 0 | 0 | A16| A15| A14| | |

----------------------------------------- --+ |

|

+------------------------------------------------------+

|

| Pattern "1" colour code Pattern "0" colour code | -----------------------+-----------------------+

|	|			|			|

| MSB 7	 6 5 4	 3	 2 1 0	 LSB Pattern number |	-------------------------------------------------

+---> 0 | FC3 | FC2 | FC1 | FC0 | BC3 | BC2 | BC1 | BC0 |	 0 to 7

|-----+-----+-----+-----+-----+-----+-----+-----+

1 | FC3 | FC2 | FC1 | FC0 | BC3 | BC2 | BC1 | BC0 |	 8 to 15

|-----+-----+-----+-----+-----+-----+-----+-----+

| . | . | . | .	| . | . | . | .	|

.	 . . .	 .	 . . .

.	 . . .	 .	 . . .

| | |	 |	| | |	 |	|

|-----+-----+-----+-----+-----+-----+-----+-----+

31 | FC3 | FC2 | FC1 | FC0 | BC3 | BC2 | BC1 | BC0 |	248 to 255

-------------------------------------------------



Colour table



* Pattern name table



The size of the pattern name table is 768 bytes and the table corresponds to the pattern on the screen, one by one (see Figure 4.29). The starting address of the pattern name table is specified by R#2. Note that only the 7 high order bits of the address (A16 to A10) are specified.



Figure 4.29	Pattern name table structure of GRAPHIC 1 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#2	| 0 | A16| A15| A14| A13| A12| A11| A10| ---+

----------------------------------------- |

|

+--------------------------------------------+

|

|	|	 |

|	-----------

+---> 0 | (0,0) |	 0 1	2 3		 31 X

|---------|	 ---------------------- -------

1 | (1,0) |	 0 | 0 | 1 | 2 | 3	| . . . | 31 |

|---------|	 |----+----+----+----+- -+----|

2 | (2,0) |	 1 | 32 | 33 | 34 | 35 | . . . | 63 |

|---------|	 |----+----+----+----+- -+----|

. | .	 |	 |	 | | |	| . . . | |

. .		 .		 .		 .

. .		 .		 .		 .

|	 |	 .		 .		 .

|---------|	 |	 | | 		| |

31 | (31,0) |	 |----+----+-	 -+----|

|---------|	 22 | 704| 705| 		| 735|

32 | (0,1) |	 |----+----+-	 -+----|

|---------|	 23 | 736| 737| 		| 767|

. | .	 |	 ------------ . .	. . .-------

. .		 Y

. .

|	 |		Screen correspondence table |---------|

767 | (31,23) |

|---------|

|	 |



Pattern Name Table

3.4.3 Specifying the screen colour



The border colour of the screen can be specified by R#7 (see Figure 4.30).



Figure 4.30	Screen colour specification of GRAPHIC 1 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#7	| :	 : : |	 : : :	|

-----------------------------------------

|		 |			|

+-------------------+-------------------+

invalid	 specifies the border colour of the screen (0 to 15)





3.5 GRAPHIC 2, GRAPHIC 3 modes




GRAPHIC 2 and GRAPHIC 3 modes are the screen modes as described below:

----------------------------------------------------------------------------

|									 |

| screen:		32 (horizontal) x 24 (vertical) patterns	 |

|			16 from 512 colours can be displayed		 |

|			at the same time				 |

| pattern:		768 kinds of patterns are available		 |

|			pattern size is 8 (horizontal) x 8 (vertical) dots |

|			any Figure can be defined for each pattern	 |

|			only two colours can be used in horizontal 8 dots |

| memory requirements:	for pattern font .............. 6144 bytes	 |

|			for colour tbale .............. 6144 bytes	 |

| sprite:		sprite mode 1 for GRAPHIC 2			 |

|			sprite mode 2 for GRAPHIC 3			 |

| BASIC:		compatible to SCREEN 2 for GRAPHIC 2		 |

|			compatible to SCREEN 4 for GRAPHIC 3		 |

----------------------------------------------------------------------------



3.5.1 Setting GRAPHIC 2, GRAPHIC 3 modes

GRAPHIC 2, and GRAPHIC 3 modes are set as Figure 4.3.1.



Figure 4.3.1 Setting GRAPHIC 2, GRAPHIC 3 modes

GRAPHIC 2 mode setting



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | . | 0 | 0 | 1 | .	|

-----------------------------------------



-----------------------------------------

R#1	| . | . | . | 0 | 0 | . | . | .	|

-----------------------------------------



GRAPHIC 3 mode setting



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | . | 0 | 1 | 0 | .	|

-----------------------------------------



-----------------------------------------

R#1	| . | . | . | 0 | 0 | . | . | .	|

-----------------------------------------



3.5.2 Screen structure of GRAPHIC 2, GRAPHIC 3 modes

* Pattern generator table



In this mode, there are three pattern generator tables which are compatible with GRAPHIC 1 and 768 patterns can be displayed. It cannot display patterns which are overlapped on the screen, and operating the pattern generator table in this case causes the 256 x 192 dot graphics display to be simulated. The starting address of the pattern generator table is specified by R#4. Note that only 4 bits of the address (A16 to A13) are specdified, so the address which can be set is located at interval steps of 8K bytes from 00000H (see Figure 4.32).



Figure 4.32	Pattern generator table structure of GRAPHIC 2, GRAPHIC 3



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#4	| 0 | 0 | A16| A15| A14| A13| 1 | 1	| ---+

----------------------------------------- |

|

+--------------------------------------------+

|

|			 MSB 7 6 5 4 3 2 1 0 LSB

| ---------------		 -------------------	 -+

+---> | Pattern 0 | 0	 |	 # # #	 |	0 |

|-------------|		 | # # |	1 |

| Pattern 1 | 1	 | #		 # |	2 |

|-------------|		 | #		 # |	3 | Pattern Pattern | . | .	 | # # # # # # # |	4 |	0

generator	 . .	 | #		 # |	5 |

table		 . .	 | #		 # |	6 |

for block 1 |	 |		 |		 |	7 |

|-------------|		 | # # # # # # |	8 -+

| Pattern 254 |		 | #		 # |	9 |

|-------------|		 | #		 # |	10 |

| Pattern 255 | 255	 | # # # # # # |	11 | Pattern ---------------		 | #		 # |	12 |	1

| #		 # |	13 |

---------------		 | # # # # # # |	14 |

| Pattern 0 | 256	 |		 |	15-+

|-------------|			 .

| Pattern 1 |			 .

|--------------			 .

Pattern | . |		 | #	 # #	 # |	2040 -+

generator	 . 		 | # # # # |	2041 |

table		 . 		 | #	 # #	 # |	2042 |

for block 2 |	 |		 | # # # # |	2043 | Pat.

|-------------|		 | #	 # #	 # |	2044 | 255

| Pattern 254 |		 | # # # # |	2045 |

|-------------|		 | #	 # #	 # |	2046 |

| Pattern 255 | 511	 | # # # # |	2047 |

---------------		 -------------------	 -+



---------------		 ------------------------------

| Pattern 0 | 512	 |				|

|-------------|		 | ------------------------	|

| Pattern 1 |		 | | 		 |	|

|-------------|		 | | Block 1	 |	|

Pattern | . | .	 | | 		 |	|

generator	 . .	 | |----------------------|	|

table		 . .	 | | 		 |	|

for block 3 |	 |		 | | Block 2	 |	|

|-------------|		 | | 		 |	|

| Pattern 254 |		 | |----------------------|	|

|-------------|		 | | 		 |	|

| Pattern 255 | 767 pattern | | Block 3	 |	|

---------------		 | | 		 |	|

| ------------------------	|

Pattern generator table	 |				|

------------------------------



Screen



* Colour table



The size of the colour table is the same as that of the pattern generator table and colours for "0" and "1" bits of each horizontal line of each pattern can be specified (see Figure 4.33). The starting address of the colour table is specified by R#3 and R#10. Note that only the 4 high order bits of the address (A16 to A13) is specified.



Figure 4.33	Colour table structure of GRAPHIC 2, GRAPHIC 3 modes

MSB 7 6 5	 4 3 2	1 0	 LSB

----------------------------------------- ---+

R#3	| A13| 1 | 1 | 1 | 1 | 1 | 1 | 1	| |

----------------------------------------- |

|---+

----------------------------------------- |	 |

R#10	| 0 | 0 | 0 | 0 | 0 | A16| A15| A14| |	 |

----------------------------------------- ---+	 |

|

+------------------------------------------------+

|

|			 MSB 7 6 5 4 3 2 1 0 LSB

| ---------------		 -------------------	 -+

+---> | Pattern 0 | 0	 | Pattern|Pattern |	0 |

|--------------		 | "0" | "1" | 1 |

| Pattern 1 | 1	 | colour | colour |	2 |

|--------------		 |	(0 to 15) |	3 | Pattern | . | .	 |	 |	 |	4 |	0

Colour		 . .	 |	 |	 |	5 |

table		 . .	 |	 |	 |	6 |

for block 1 |	 |		 |	 |	 |	7 |

|--------------		 |	 |	 |	8 -+

| Pattern 254 |		 |	 |	 |	9 |

|-------------|		 |	 |	 |	10 |

| Pattern 255 | 255	 |	 |	 |	11 | Pattern ---------------		 |	 |	 |	12 |	1

|	 |	 |	13 |

---------------		 |	 |	 |	14 |

| Pattern 0 | 256	 |	 |	 |	15-+

|-------------|			 .

| Pattern 1 |			 .

|-------------|			 .

| . |		 |	 |	 |	2040 -+

Colour		 . 		 |	 |	 |	2041 |

table		 . 		 |	 |	 |	2042 |

for block 2 |	 |		 |	 |	 |	2043 | Pat.

|-------------|		 |	 |	 |	2044 | 255

| Pattern 254 |		 |	 |	 |	2045 |

|-------------|		 |	 |	 |	2046 |

| Pattern 255 | 511	 |	 |	 |	2047 |

---------------		 -------------------	 -+



---------------		 ------------------------------

| Pattern 0 | 512	 |				|

|-------------|		 | ------------------------	|

| Pattern 1 |		 | | 		 |	|

|-------------|		 | | Block 1	 |	|

| . | .	 | | 		 |	|

Colour		 . .	 | |----------------------|	|

table		 . .	 | | 		 |	|

for block 3 |	 |		 | | Block 2	 |	|

|-------------|		 | | 		 |	|

| Pattern 254 |		 | |----------------------|	|

|-------------|		 | | 		 |	|

| Pattern 255 | 767 pattern | | Block 3	 |	|

---------------		 | | 		 |	|

| ------------------------	|

Colour table		 |				|

------------------------------



Screen



* Pattern name table



The pattern name table is divided into three stages - upper, middle, and lower; each displays the pattern by referring to 256 bytes of the pattern generator (see Figure 4.34). This method enables each of 768 bytes on the pattern name table to display a different pattern font.



Figure 4.34	Pattern name table for GRAPHIC modes 2 and 3



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#2	| 0 | A16| A15| A14| A13| A12| A11| A10| ---+

----------------------------------------- |

|

+--------------------------------------------+

|

| Pattern name table |	|	 |

|	----------- ----+	------------------------------------

+---> 0 | (0,0) | 0	|	| (0,0) 		 (31,0) |

|---------|	|	|				 |

1 | (1,0) | 1	| +-> | Upper stage of screen	 |

|---------|	| |	| pattern display area (256 bytes) |

. | .	 | .	| |	|				 |

. .	 .	|---+	| (0,7) 		 (31,7) |

. .	 .	|	|----------------------------------|

|	 |	|	| (0,8) 		 (31,8) |

|---------|	|	|				 |

31 | (31,7) | 255 | +-> | Middle stage of screen	 |

|---------| ----+ |	| pattern display area (256 bytes) |

32 | (0,8) | 256 | |	|				 |

|---------|	| |	| (0,15)		 (31,15) |

. | .	 | .	| |	|----------------------------------|

. .	 .	|---+	| (0,16)		 (31,16) |

. .	 .	|	|				 |

|	 |	| +-> |	Lower stage of screen	 |

|---------|	| |	| pattern display area (256 bytes) |

767 | (31,15) | 511 | |	|				 |

|---------| ----+ |	| (0,23)		 (31,23) |

32 | (0,16) | 512 | |	------------------------------------

|---------|	| |

. | .	 |	| |	 Screen correspondence table . .		|---+

. .		|

|	 |	|

|---------|	|

767 | (31,15) | 767 bytes |---------| ----+

|	 |



Actual contents of fixed pattern name table

X axis

0	 8	 16	 240 248	255

----------------------- . . . . -----------------------

Y axis	 0 | &H0 | &H8	 |	 | &HF0 | &HF8	 |

| &H1 | &H9	 |	 | &HF1 | &HF9	 |

| &H2 | &HA	 |	 | &HF2 | &HFA	 |

| &H3 | &HB	 | . . . . | &HF3 | &HFB	 |

| &H4 | &HC	 |	 | &HF4 | &HFC	 |

| &H5 | &HD	 |	 | &HF5 | &HFD	 |

| &H6 | &HE	 |	 | &HF6 | &HFE	 |

| &H7 | &HF	 |	 | &HF7 | &HFF	 |

|----------+----------| . . . . |----------+----------|

8 | &H100 | &H108	 |	 | &H1F0 | &H1F8	 |

| &H101 | &H109	 |	 | &H1F1 | &H1F9	 |

| &H102 | &H10A	 |	 | &H1F2 | &H1FA	 |

| &H103 | &H10B	 |	 | &H1F3 | &H1FB	 |

| &H104 | &H10C	 | . . . . | &H1F4 | &H1FC	 |

| &H105 | &H10D	 |	 | &H1F5 | &H1FD	 |

| &H106 | &H10E	 |	 | &H1F6 | &H1FE	 |

| &H107 | &H10F	 |	 | &H1F7 | &H1FF	 |

-----------------------	 -----------------------

16 |	 .	 .			 .	 .	 |

.	 .	 .			 .	 .

.	 .	 . (256 x 192 dots) .	 .

.	 .	 .			 .	 .

|							 |

----------------------- . . . . -----------------------

184 | &H1700 | &H1708 |	 | &H17F0 | &H17F8 |

| &H1701 | &H1709 |	 | &H17F1 | &H17F9 |

| &H1702 | &H170A |	 | &H17F2 | &H17FA |

| &H1703 | &H170B | . . . . | &H17F3 | &H17FB |

| &H1704 | &H170C |	 | &H17F4 | &H17FC |

| &H1705 | &H170D |	 | &H17F5 | &H17FD |

| &H1706 | &H170E |	 | &H17F6 | &H17FE |

191 | &H1707 | &H170F |	 | &H17F7 | &H17FF |

----------------------- . . . . -----------------------



Note: The values are offset from the base address of the pattern generator table.



3.5.3 Screen colour specification



The border colour of the screen can be specified by R#7 (see Figure 4.35).



Figure 4.35	Screen colour specification of GRAPHIC 2, GRAPHIC 3 modes

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#7	| :	 : : |	 : : :	|

-----------------------------------------

|		 |			|

+-------------------+-------------------+

invalid	 specifies the border colour of the screen (0 to 15)





3.6 GRAPHIC 4 Mode




GRAPHIC 4 mode is described below:



----------------------------------------------------------------------------

|									 |

| screen:		256 (horizontal) x 212 (vertical) dots		 |

|			(or, 192 vertical)				 |

|			16 colours can be displayed at the same time	 |

|			each of 16 colours can be selected from 512 colours|

| command:		high speed graphic by VDP command available	 |

| sprite:		mode 2 sprite function available		 |

| memory requirements:	for 192 dots					 |

|			 bitmap screen ....... 24K bytes (6000H bytes) |

|			 (4 bits x 256 x 192)				 |

|			for 212 dots					 |

|			 bitmap screen ....... 26.5K bytes (6A00H bytes) |

|			 (4 bits x 256 x 212)				 |

| BASIC:		compatible to SCREEN 5				 |

----------------------------------------------------------------------------



3.6.1 Setting GRAPHIC 4 mode



Set GRAPHIC 4 mode as shown in Figure 4.36.



Figure 4.36	GRAPHIC 4 mode setting

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | . | 0 | 1 | 1 | .	|

-----------------------------------------



-----------------------------------------

R#1	| . | . | . | 0 | 0 | . | . | .	|

-----------------------------------------



3.6.2 Screen structure of GRAPHIC 4 mode

* Pattern name table



In GRAPHIC 4 mode, one byte of the pattern name table corresponds with 2 dots on the screen. The colour information of each dot is represented by 4 bits and 16 colours can be specified (see Figure 4.37). The starting address of the pattern name table is specified by R#2. Only the 2 high order bits of the address (A16 to A15) are specified and the 15 low order bits are considered as "0". Thus, the four addresses at which the pattern name can be set are 00000H, 08000H, 10000H, and 18000H.



Figure 4.37	Pattern name table structure of GRAPHIC 4 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#2	| 0 | A16| A15| 1 | 1 | 1 | 1 | 1	| --+

----------------------------------------- |

|

+---------------------------------------------------+

|

|		 Pattern name table

|

| MSB 7	 6 5 4	 3	 2 1 0	 LSB

|	-------------------------------------------------

+---> 0 | : (0,0) :	| : (1,0) :	|

+-----+-----+-----+-----+-----+-----+-----+-----+

1 | : (2,0) :	| : (3,0) :	|

+-----+-----+-----+-----+-----+-----+-----+-----+

. |						|

.

. |						|

+-----+-----+-----+-----+-----+-----+-----+-----+

127 | : (254,0) :	| : (255,0) :	|

+-----+-----+-----+-----+-----+-----+-----+-----+

128 | : (0,1) :	| : (1,1) :	|

+-----+-----+-----+-----+-----+-----+-----+-----+

. |						|

.

. |						|

+-----+-----+-----+-----+-----+-----+-----+-----+

27134 | : (252,211) :	| : (253,211) :	|

+-----+-----+-----+-----+-----+-----+-----+-----+

27135 | : (254,211) :	| : (255,211) :	|

-------------------------------------------------



This table shows how colour codes are set for each dot. (0 to 15)

+---------> X

|

| ---------------------- . . . . ----------------------

| |	 0,0 | 1,0	 |	 |	254,0 | 255,0 |

V |---------+---------+	 +---------+---------|

|	 0,1 |			 | 255,1 |

Y |---------+			 +---------|

|	 .		 -----------		 .	 |

.		 | X,Y |		 .

.		 -----------		 .

|							 |

|---------+			 +---------|

|	0,191 |	 LN = 0	 | 255,191 |

------------ . . . . . . . . . . . . . . ------------



|							 |

----------+			 +----------

|	0,211 |	 LN = 1	 | 255,211 |

------------ . . . . . . . . . . . . . . ------------



Screen correspondence table

The dot at (X,Y) coordinate on the screen can be accessed by using Expression 4.1. The program of List 4.2 illustrates the use of Expression 4.1.



Expression 4.1 The expression for accessing the dot at (X,Y) coordinate

----------------------------------------

| ADR = X/2 + Y * 128 + base address |

----------------------------------------



(The colour of the dot is represented by 4 high order bits in the case that X

is even and by 4 low order bits in the case that X is odd.)

List 4.2 PSET for GRAPHIC 4 mode written in BASIC

=========================================================================



100 '*********************************************

110 ' LIST 4.2 dot access of GRAPHIC 4 mode 120 '*********************************************

130 '

140 SCREEN 5

150 BA=0

160 FOR I=0 TO 255

170 X=I:Y=I\2

180 COL=15

190 GOSUB 1000

200 NEXT

210 END

220 '

1000 '****************************************

1010 ' PSET (X,Y),COL

1020 ' COL:color BA:graphics Base Address 1030 '****************************************

1040 '

1050 ADR=X\2+Y*128+BA

1060 IF X AND 1 THEN BIT=&HF0:C=COL ELSE BIT=&HF:C=COL*16

1070 D=VPEEK(ADR)

1080 D=(D AND BIT) OR C

1090 VPOKE ADR,D

1100 RETURN



=========================================================================



3.6.3 Screen colour specification



The border colour of the screen can be specified by R#7 (see Figure 4.38).



Figure 4.38	Screen colour specification in GRAPHIC 4 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#7	| :	 : : |	 : : :	|

-----------------------------------------

|		 |			|

+-------------------+-------------------+

invalid	 specifies the border colour of the screen (0 to 15)





3.7 GRAPHIC 5 Mode




GRAPHIC 5 mode is described as follows:

----------------------------------------------------------------------------

|									 |

| screen:		512 (horizontal) x 212 (vertical) dots		 |

|			(or, 192 vertical)				 |

|			4 colours can be displayed at the same time	 |

|			each of 4 colours can be selected from 512 colours |

| command:		graphic command by hardware available		 |

| sprite:		mode 2 sprite function available		 |

| memory requirements:	for 192 dots					 |

|			 bitmap screen ....... 24K bytes (6000H bytes) |

|			 (2 bits x 512 x 192)				 |

|			for 212 dots					 |

|			 bitmap screen ....... 26.5K bytes (6A00H bytes) |

|			 (2 bits x 512 x 212)				 |

| BASIC:		compatible to SCREEN 6				 |

----------------------------------------------------------------------------



3.7.1 Setting GRAPHIC 5 mode



Set GRAPHIC 5 mode as shown in Figure 4.39.



Figure 4.39	GRAPHIC 5 mode setting

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | . | 1 | 0 | 0 | .	|

-----------------------------------------



-----------------------------------------

R#1	| . | . | . | 0 | 0 | . | . | .	|

-----------------------------------------



3.7.2 Pattern name table



In GRAPHIC 5 mode, one byte of the pattern name table corresponds with 4 dots on the screen. The colour information of each dot is represented by 2 bits and 4 colours can be specified. As with GRAPHIC 4 mode, the pattern name table is set by writing 2 high order bits of the address in R#2. The addresses can be set at either 00000H, 08000H, 10000H, or 18000H (see Figure 4.40).



Figure 4.40	Pattern name table structure of GRAPHIC 5 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#2	| 0 | A16| A15| 1 | 1 | 1 | 1 | 1	| --+

----------------------------------------- |

|

+---------------------------------------------------+

|

|		 Pattern name table

|

| MSB 7	 6 5 4	 3	 2 1 0	 LSB

|	-------------------------------------------------

+---> 0 | (0,0) |	(1,0)	| (2,0) |	(3,0)	|

|-----+-----+-----+-----+-----+-----+-----+-----+

1 | (4,0) |	(5,0)	| (6,0) |	(7,0)	|

|-----+-----+-----+-----+-----+-----+-----+-----+

. |						|

.

. |						|

|-----+-----+-----+-----+-----+-----+-----+-----+

127 | (508,0) | (509,0)	| (510,0) | (511,0)	|

|-----+-----+-----+-----+-----+-----+-----+-----+

128 | (0,1) |	(1,1)	| (2,1) |	(3,1)	|

|-----+-----+-----+-----+-----+-----+-----+-----+

. |						|

.

. |						|

|-----+-----+-----+-----+-----+-----+-----+-----+

27135 | (508,211) | (509,211) | (510,211) | (511,211) |

-------------------------------------------------



This table shows how colour codes are set for each dot. (0 to 3)

+---------> X

|

| ---------------------- . . . . ----------------------

| |	 0,0 | 1,0	 |	 |	510,0 | 511,0 |

V |---------+---------+	 +---------+---------|

|	 0,1 |			 | 511,1 |

Y |---------+			 +---------|

|	 .		 -----------		 .	 |

.		 | X,Y |		 .

.		 -----------		 .

|							 |

|---------+			 +---------|

|	0,191 |	 LN = 0	 | 511,191 |

------------ . . . . . . . . . . . . . . ------------



|							 |

----------+			 +----------

|	0,211 |	 LN = 1	 | 511,211 |

------------ . . . . . . . . . . . . . . ------------



Screen correspondence table

The dot at (X,Y) coordinate on the screen can be accessed by using Expression 4.2. The program of List 4.3 confirms Expression 4.2.



Expression 4.2 The expression for accessing the dot at (X,Y) coordinate

----------------------------------------

| ADR = X/4 + Y * 128 + base address |

----------------------------------------



(The colour of the dot is represented by bit 7 and 6, or 5 and 4, or 3 and 2, or 1 and 0, when X MOD 4 is 0, or 1, or 2, or 3, respectively.)

List 4.3 PSET for GRAPHIC 5 mode written in BASIC

=========================================================================



100 '*********************************************

110 ' LIST 4.3 dot access of GRAPHIC 5 mode 120 '*********************************************

130 '

140 SCREEN 6

150 BA=0

160 FOR I=0 TO 511

170 X=I : Y=I\2

180 COL=3

190 GOSUB 1000

200 NEXT

210 END

220 '

1000 '*******************************************

1010 ' PSET(X,Y)

1020 ' COL:colour BA:graphic Base Address 1030 '*******************************************

1040 '

1050 ADR=X\4+Y*128+BA

1060 LP=X MOD 4

1070 IF LP=0 THEN BIT=&H3F:C=COL*&H40

1080 IF LP=1 THEN BIT=&HCF:C=COL*&H10

1090 IF LP=2 THEN BIT=&HF3:C=COL*&H4

1100 IF LP=3 THEN BIT=&HFC:C=COL

1110 D=VPEEK(ADR)

1120 D=(D AND BIT) OR C

1130 VPOKE ADR,D

1140 RETURN



=========================================================================



3.7.3 Setting the screen colour



In GRAPHIC 5 mode, hardware tiling is done for the border colour of the screen and sprites. As with the other modes, these colours are specified by 4

bits; 2 high order bits of 4 bits represents the dot colour at even locations, and 2 low order bits for the dot colour at odd locations (see Figure 4.41).



Figure 4.41	Screen colour specification in GRAPHIC 5 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#7	| :	 : : |	 : | :	|

-----------------------------------------

|		 |	 | 	|

+-------------------+---------+---------+

invalid		 |	border colour (0 to 3) at even dots |

+----> border colour (0 to 3) at odd dots

+--> even dots (0,2,...,510) |

| odd dots (1,3,...,511) -------------

| |	 | <-- graphic 2 dots -------------



-------------

|	 | <-- sprite 1 dot at another mode -------------



-------------

| |	 | <-- sprite 1 dot is automatically done by -------------	 tiling function |	|

+-------+-------+

|	 |	 |

-----------------

MSB |	 : |	 : |	LSB	sprite colour specification (4 bits) -----------------

right left

side side

colour colour

(0 to 3) (0 to 3)





3.8 GRAPHIC 6 Mode




GRAPHIC 6 mode is described as follows:

----------------------------------------------------------------------------

|									 |

| screen:		512 (horizontal) x 212 (vertical) dots		 |

|			(or, 192 vertical)				 |

|			16 colours can be displayed at the same time	 |

|			each of 16 colours can be selected from 512 colours|

| command:		graphic command by hardware available		 |

| sprite:		mode 2 sprite function available		 |

| memory requirements:	for 192 dots					 |

|			 bitmap screen ....... 48K bytes (C000H bytes) |

|			 (4 bits x 512 x 192)				 |

|			for 212 dots					 |

|			 bitmap screen ....... 53K bytes (D400H bytes) |

|			 (4 bits x 512 x 212)				 |

|			Note that this mode cannot be used at all with	 |

|			64K byte VRAM because of the hardware		 |

| BASIC:		compatible to SCREEN 7				 |

----------------------------------------------------------------------------



3.8.1 Setting GRAPHIC 6 mode



Set GRAPHIC 6 mode as shown in Figure 4.42.



Figure 4.42	GRAPHIC 6 mode setting

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | . | 1 | 0 | 1 | .	|

-----------------------------------------



-----------------------------------------

R#1	| . | . | . | 0 | 0 | . | . | .	|

-----------------------------------------



3.8.2 Pattern name table



In GRAPHIC 6 mode, one byte of the pattern name table corresponds with 2 dots on the screen. The colour information of each dot is represented by 4 bits and 16 colours can be specified (see Figure 4.43). The starting address of the pattern name table is set by writing the high order bit of the address in R#2. The two addresses at which the pattern name table can be set ae either 00000H or 10000H. The dot at (X,Y) coordinate on the screen can be accessed by using Expression 4.3. The program of List 4.4 illustrates this.



Figure 4.43	Pattern name table structure of GRAPHIC 6 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#2	| 0 | 0 | A16| 1 | 1 | 1 | 1 | 1	| ------------------------+

-----------------------------------------			 |

^							 |

|							 |

This bit is used to specify a page to be displayed on the screen.	 |

The bit position of A16 is different only in the GRAPHIC 6 and 7 modes. |

|

|

+-------------------------------------------------------------------------+

|

|		 Pattern name table

|

| MSB 7	 6 5 4	 3	 2 1 0	 LSB

|	-------------------------------------------------

+---> 0 | : (0,0) :	| : (1,0) :	|

|-----+-----+-----+-----+-----+-----+-----+-----+

1 | : (2,0) :	| : (3,0) :	|

|-----+-----+-----+-----+-----+-----+-----+-----+

. |						|

.

. |						|

|-----+-----+-----+-----+-----+-----+-----+-----+

255 | : (510,0) :	| : (511,0) :	|

|-----+-----+-----+-----+-----+-----+-----+-----+

256 | : (0,1) :	| : (1,1) :	|

|-----+-----+-----+-----+-----+-----+-----+-----+

. |						|

.

. |						|

|-----+-----+-----+-----+-----+-----+-----+-----+

54270 | : (508,211) :	| : (509,211) :	|

|-----+-----+-----+-----+-----+-----+-----+-----+

54271 | : (510,211) :	| : (511,211) :	|

-------------------------------------------------



This table shows how colour codes are set for each dot. (0 to 15)

+---------> X

|

| ---------------------- . . . . ----------------------

| |	 0,0 | 1,0	 |	 |	510,0 | 511,0 |

V |---------+---------+	 +---------+---------|

|	 0,1 |			 | 511,1 |

Y |---------+			 +---------|

|	 .		 -----------		 .	 |

.		 | X,Y |		 .

.		 -----------		 .

|							 |

|---------+			 +---------|

|	0,191 |	 LN = 0	 | 511,191 |

------------ . . . . . . . . . . . . . . ------------



|							 |

|---------+			 +---------|

|	0,211 |	 LN = 1	 | 511,211 |

------------ . . . . . . . . . . . . . . ------------



Screen correspondence table

The dot at (X,Y) coordinate on the screen can be accessed by using Expression 4.1. The program of List 4.2 illustrates the use of Expression 4.1.



Expression 4.3 The expression for the access to the dot at (X,Y) coordinate

----------------------------------------

| ADR = X/2 + Y * 256 + base address |

----------------------------------------



(The colour of the dot is represented by 4 high order bits in the case that X

is even and by 4 low order bits in the case that X is odd.)

List 4.4 PSET for GRAPHIC 6 mode written in BASIC

=========================================================================



100 '*********************************************

110 ' LIST 4.4 dot access of GRAPHIC 6 mode 120 '*********************************************

130 '

140 SCREEN 7

150 BA=0

160 FOR I=0 TO 511

170 X=I: Y=I\2: COL=15: GOSUB 1000

180 NEXT

190 END

200 '

1000 '*************************************************

1010 ' PSET (X,Y)

1020 ' COL:color BA:graphic Base Address 1030 '*************************************************

1040 '

1050 ADR=X\2+Y*256+BA

1060 IF X AND 1 THEN BIT=&HF: C=COL ELSE BIT=&HF0: C=COL*16

1070 VPOKE ADR,(VPEEK(ADR) AND BIT) OR COL

1080 RETURN



=========================================================================



3.8.3 Setting screen colour



The border colour of the screen can be specified by R#7 (see Figure 4.44).



Figure 4.44	Screen colour specification in GRAPHIC 6 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#7	| :	 : : |	 : : :	|

-----------------------------------------

|		 |			|

+-------------------+-------------------+

invalid	 specifies the border colour of the screen (0 to 15)





3.9 GRAPHIC 7 Mode Use




GRAPHIC 7 mode is described as follows:

----------------------------------------------------------------------------

|									 |

| screen:		256 (horizontal) x 212 (vertical) dots		 |

|			(or, 192 vertical)				 |

|			256 colours can be displayed at the same time	 |

| command:		graphic command by hardware available		 |

| sprite:		mode 2 sprite function available		 |

| memory requirements:	for 192 dots					 |

|			 bitmap screen ....... 48K bytes (C000H bytes) |

|			 (8 bits x 256 x 192)				 |

|			for 212 dots					 |

|			 bitmap screen ....... 53K bytes (D400H bytes) |

|			 (8 bits x 256 x 212)				 |

|			Note that this mode cannot be used with 64K byte |

|			VRAM machines, as in the case of GRAPHIC 6	 |

| BASIC:		compatible to SCREEN 8				 |

----------------------------------------------------------------------------



3.9.1 Setting GRAPHIC 7 mode



Set GRAPHIC 7 mode as shown in Figure 4.45.



Figure 4.45	GRAPHIC 4 mode setting

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | . | 1 | 1 | 1 | .	|

-----------------------------------------



-----------------------------------------

R#1	| . | . | . | 0 | 0 | . | . | .	|

-----------------------------------------



3.9.2 Pattern name table



Configuration of GRAPHIC 7 mode is the simplest of all modes; one dot on the screen corresponds with one byte in the pattern name table. The value of one byte written in the table represents 256 kinds of colours. The starting address of the pattern name table is set by R#2. The two addresses at which the pattern name table can be set are either 00000H or 10000H (see Figure 4.46).



One byte of data represents the intensity of 3 bits for green, 3 bits for red, and 2 bits for blue, as shown in Figure 4.47. The dot at (X,Y) coordinate on the screen can be accessed by using Expression 4.4.



Figure 4.46	Pattern name table structure of GRAPHIC 7 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#2	| 0 | 0 | A16| 1 | 1 | 1 | 1 | 1	| ------------------------+

-----------------------------------------			 |

^							 |

|							 |

This bit is used to specify a page to be displayed on the screen.	 |

The bit position of A16 is different only in the GRAPHIC 6 and 7 modes. |

|

|

+-------------------------------------------------------------------------+

|

|

|		 Pattern name table

|

| MSB 7	 6 5 4	 3	 2 1 0	 LSB

|	-------------------------------------------------

+---> 0 | : :	 : (0,0) : :	 :	|

|-----+-----+-----+-----+-----+-----+-----+-----|

1 | : :	 : (1,0) : :	 :	|

|-----+-----+-----+-----+-----+-----+-----+-----|

. |						|

.

. |						|

|-----------------------------------------------|

| Green level | Red level | Blue level|

|-----------------------------------------------|

. |						|

.

. |						|

|-----+-----+-----+-----+-----+-----+-----+-----|

255 | : :	 : (255,0) : :	 :	|

|-----+-----+-----+-----+-----+-----+-----+-----|

256 | : :	 : (0,1) : :	 :	|

|-----+-----+-----+-----+-----+-----+-----+-----|

. |						|

.

. |						|

|-----+-----+-----+-----+-----+-----+-----+-----|

54270 | : :	 : (254,211) : :	 :	|

|-----+-----+-----+-----+-----+-----+-----+-----|

54271 | : :	 : (255,211) : :	 :	|

-------------------------------------------------



This table shows how colour codes are set for each dot. (0 to 255)

+---------> X

|

| ---------------------- . . . . ----------------------

| |	 0,0 | 1,0	 |	 |	254,0 | 255,0 |

V |---------+---------+	 +---------+---------|

|	 0,1 |			 | 255,1 |

Y |---------+			 +---------|

|	 .		 -----------		 .	 |

.		 | X,Y |		 .

.		 -----------		 .

|							 |

|---------+			 +---------|

|	0,191 |	 LN = 0	 | 255,191 |

------------ . . . . . . . . . . . . . . ------------



|							 |

|---------+			 +---------|

|	0,211 |	 LN = 1	 | 255,211 |

------------ . . . . . . . . . . . . . . ------------



Screen correspondence table

Figure 4.47	RGB brightness information

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#2	| GREEN : RED : BLUE	|

-----------------------------------------

|	 |	 | 	|

+--------------+--------------+---------+

|	 |	 Blue level (0 to 3) |	 |

|	 +-------> Red level (0 to 7) |

+-----------------------> Green level (0 to 7)

Expression 4.4 The expression for accessing to the dot at (X,Y) coordinate

--------------------------------------

| ADR = X + Y * 256 + base address |

--------------------------------------



3.9.3 Setting the screen colour



The border colour of the screen can be specified by R#7 (see Figure 4.48).



Figure 4.48	Screen colour specification in GRAPHIC 7 mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#7	| :	 : : :	 : : :	|

-----------------------------------------

|					|

+---------------------------------------+

specifies the border colour of the screen (0 to 255)





4. MISCELLANEOUS FUNCTIONS FOR THE SCREEN DISPLAY




Detailed settings for the screen display are available in MSX-VIDEO. These include screen ON/OFF and specification of the display location. These MSX-VIDEO functions are described in this function.



* Screen ON/OFF



The screen ON/OFF function is controlled by bit 6 of R#1 (see Figure 4.49).

When set OFF, the entire screen changes to the colour specified by the 4 low order bits of R#7 (8 bits in GRAPHIC 7 mode). Drawing with the VDP commands is faster when the screen is set OFF.



Figure 4.49	Screen ON/OFF



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#1	| . | X | . | . | . | . | . | .	|

-----------------------------------------

|

| 0: Screen OFF

+--->





1: Screen ON




BASIC program lines:

VDP(1)=VDP(1) AND &B10111111 <-- Screen OFF

VDP(1)=VDP(1) OR &B01000000 <-- Screen ON



* Adjustment of the display location on the screen

R#18 is used for adjusting the display location on the screen (see Figure 4.50). This corresponds with the "SET ADJUST" instruction of BASIC.



Figure 4.50	Adjustment of the screen display

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#18	| v3 | v2 | v1 | v0 | h3 | h2 | h1 | h0 |

-----------------------------------------

|		 |			|

+-------------------+-------------------+

vertical adjustment horizontal adjustment (-8 to +7)		 (-8 to +7)

---------------------------------------------------- V=7

|			 ^			 | ^

|			 |			 | |

| ----------------------------------------	 | |

| | 				 |	 | |

| | 				 |	 | |

| | 				 |	 | |

| | 				 |	 | |

| <-- | 	 Display screen	 | --> | |

| | 				 |	 | |

| | 				 |	 | |

| | 				 |	 | |

| | 				 |	 | |

| ----------------------------------------	 | |

|			 |			 | |

|			 V			 | V

---------------------------------------------------- V=8

H=7 <----------------------------------------------> H=8



* Switching the number of pixels in the Y direction

The number of dots displayed in the Y direction on the screen can be switched to either 192 dots or 212 dots by setting bit 7 of R#9 to 0 or 1. This function is only valid for five screen modes, TEXT 2, and GRAPHIC 4 to GRAPHIC 7 modes. When 212 dots are set in TEXT 2 mode, the number of text lines is 26.5 (=212/8) and on the 27th line only the upper halves of characters are displayed.



Figure 4.51	Switching the number of dots in the vertical direction

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#9	| X | . | . | . | . | . | . | .	|

-----------------------------------------

|

|	0: 192 dots +--->





1: 212 dots




BASIC program lines:

VDP(10)=VDP(10) AND &B01111111 <-- 192 dots VDP(10)=VDP(10) OR &B10000000 <-- 212 dots

* Switching the display page



In GRAPHIC modes 4 to 7, the display pages can be easily switched by setting the starting address of the pattern name table using R#2. In fact, the second parameter of the "SET PAGE" BASIC instruction switches the display page this way.



Figure 4.52	Switching pages

* GRAPHIC modes 4 and 5



MSB 7 6 5	 4 3 2	1 0	 LSB	 VRAM

----------------------------------------- ---------------- 00000H

R#2	| 0 | X | X | 1 | 1 | 1 | 1 | 1	| | page 0 |

----------------------------------------- |--------------| 08000H

|	 |			 | page 1 |

+---------+			 |--------------| 10000H

|	 00: page 0		 | page 2 |

+---> 01: page 1		 |--------------| 18000H

10: page 2		 | page 3 |





11: page 3		 ----------------




* GRAPHIC modes 6 and 7



MSB 7 6 5	 4 3 2	1 0	 LSB	 VRAM

----------------------------------------- ---------------- 00000H

R#2	| 0 | 0 | X | 1 | 1 | 1 | 1 | 1	| | 	 |

----------------------------------------- | page 0 |

|				 | 	 |

|				 |--------------| 10000H

|	 0: page 0		 | 	 |

+--->			 | page 1 |

1: page 1		 | 	 |

----------------



* Automatic alternate screen display



In GRAPHIC modes 4 to 7, two pages can be displayed alternately by using the following method. Either page 0 and page 1, or page 2 and page 3 can be displayed alternately.



To begin the alternate display, select the odd-numbered page (1 or 3) using R#2 and set the screen alternation rate in R#13. The 4 high order bits of R#13 represent the time for displaying the even page and the 4 low order bits represent the time for displaying the odd page. The time is set in 1/6

seconds interval. Setting 0 for both time periods causes only the odd page to be displayed.



Figure 4.53	Setting the rate of the screen alternation

-----------------------------------------

R#13	| :	 EVEN : |	 : ODD :	| setting the cycle -----------------------------------------



----------------------			 --------

| even numbered page | odd numbered page |

---------		 ----------------------

|<- EVEN/6 seconds ->|<- ODD/6 seconds	->|



* Setting the interlaced mode



The interlaced mode allows an apparent screen resolution in the Y direction of double the normal mode. A resolution of up to 424 dots in the Y direction can be achieved using this mode. This is done by alternating at high speed the normal screen and a screen whose scanning lines are offset vertically by half a line. In MSX-VIDEO the interlaced mode is specified by setting bit 3

of R#9 ro "1". The two screens are switched 60 times a second.



When the odd page is selected in GRAPHIC 4 to GRAPHIC 7 screen modes and the alternate screen display mode is selected, the screen is normally switched at slow rates specified in units of 1/6 seconds. However, combinig this function and the interlaced function can make the number of the vertical dots of the display screen seem double.



Figure 4.54	Setting the interlaced mode

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#9	| . | . | . | . | X | X | . | .	|

-----------------------------------------

| |	 0: one screen is displayed | +-->

| 	 1: two screens are displayed | 	 alternately |

| 0: non-interlace mode (normal mode) +---->





1: interlace mode




First screen

+-- -------------------

| | --------------- |

| |		 |

212 | --------------- |

dots |		 |

| | --------------- |	 -------------------	---

| |		 |	 | -------------- |	 ^

| | --------------- |	 | .............. |	 |

+-- ------------------- ------> | -------------- |	 | Apparent | .............. |	 | 424 dots Second screen		 | -------------- |	 | resolution +-- ------------------- ------> | .............. |	 |

| | ............... |	 | -------------- |	 |

| |		 |	 | .............. |	 V

212 | ............... |	 -------------------	---

dots |		 |	 interlace mode table

| | ............... |	 (The first and second screens are | |		 |	 displayed alternately at 1/60 seconds | | ............... |	 each cycle.)

+-- -------------------



List 4.5 Interlaced mode example

=========================================================================



1000 '***************************************************

1010 ' List 4.5 interlace mode

1020 '***************************************************

1030 '

1040 COLOR 15,0,0 : SCREEN 5,,,,,0 'noninterlace mode 1050 '

1060 SET PAGE 0,0 : CLS

1070 LINE (32,0)-(64,120),15,BF

1080 SET PAGE 1,1 : CLS

1090 LINE (192,91)-(224,211),15,BF

1100 '

1110 VDP(10)=VDP(10) OR &B00001100 'interlace mode!!!

1120 '

1130 FOR I=32 TO 192

1140 SET PAGE 1,0

1150 LINE (I,0)-STEP(0,120),0

1160 LINE (I+33),0)-STEP(0,120),15

1170 SET PAGE 1,1

1180 LINE (256-I,91)-STEP(0,120),0

1190 LINE (221-I,91)-STEP(0,120),15

1200 NEXT I

1210 '

1220 VDP(10)=VDP(10) AND &B11110011 'interlace off

=========================================================================



* Vertical scroll of the screen



R#23 is used to set the line at which display begins on the screen. Changing this register enables vertical scrolling of the screen. Note that, since the scroll is done every 256 lines, the sprite tables should be moved to another page. List 4.6 shows an example.



List 4.6 Vertical scroll example

=========================================================================



1000 '**************************************************************

1010 ' List 4.6 Hardware scroll

1020 '**************************************************************

1030 '

1040 SCREEN 5,2: COLOR 15,0,0: CLS

1050 COPY (0,0)-(255,43) TO (0,212),,PSET 'erase (212,0)-(255,255) 1060 '

1070 FOR I=1 TO 8: D(I)=VAL(MID$("00022220",I,1))-1: NEXT

1080 '

1090 OPEN "GRP:" AS #1

1100 FOR I=0 TO 3

1110 PRESET (64,I*64): PRINT #1,"Hit CURSOR Key"

1120 NEXT

1130 '

1140 J=STICK(0)

1150 P=(P+D(J)) AND &HFF

1160 VDP(24)=P

1170 GOTO 1140



=========================================================================



* Specifying the colour code 0 function

Among the 16 colour codes, only code 0 can be made as a "transparent" colour (the border colour of the screen can be set transparently), the colour set in palette P#0. Setting bit 5 of R#8 to "1" disables thsi function and the colour code 0 changes to the colour defined by the palette P#0.



Figure 4.55	Colour code 0 function

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#8	| . | . | X | . | . | . | . | .	|

-----------------------------------------

|	 0: Colour code 0 transparent function is enabled +-->





1: Colour code 0 function disabled




- When the TB bit is "0", colour code 0 becomes transparent.

- When the TB bit is "1", colour code 0 changes to the colour defined by palette P#0.



* Generating interrupts by the scanning line location

In MSX-VIDEO an interrupt can be generated just after the CRT finishes displaying a specific scanning line. Set in R#19 the number of the scanning line at which the interrupt should be generated, and set bit 4 of R#0 to "1"

(see Figure 4.56).



Figure 4.56	Generating the scanning line interrupt

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#0	| . | . | . | E1 | . | . | . | .	| Mode register 0

-----------------------------------------

| 0: Normal condition +-->





1: Interrupt at specific line mode




MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#19	| IL7| IL6| IL5| IL4| IL3| IL2| IL1| IL0| Interrupt line register -----------------------------------------





5. SPRITES




Sprites are used to display movable character patterns of 8 x 8 or 16 x 16

dots on the screen. This function is especially useful in the programming of games.



The parameters specified are the X and Y coordinates, the character number, and the colour code. The sprite is displayed by writing this data to the preset sprite attribute table.



There are two modes for MSX2 sprites. Mode 1 is compatible to the TMS9918

used in the MSX1 machines. Mode 2 includes several improved functions and has been implemented on the MSX2. This section summarises the sprite function and describes the two modes.





5.1 Sprite Function




Up to 32 sprites can be displayed on one screen at a time.



Sprites have two sizes, 8 x 8 and 16 x 16 dots. Only one size can be displayed on the screen at a time. The size of one dot of the sprite is usually the same as one pixel, but in the case of GRPAHIC5 and 6 modes (for both, the resolution is 512 x 212) the horizontal size is two pixels, that is, the absolute size of the sprite is the same in any mode.



The Sprite mode automatically selected is determined by the screen mode in use. Shown below are the default settings:

Sprite mode 1 selected: ....... GRAPHIC 1	(SCREEN 1) GRAPHIC 2	(SCREEN 2) MULTI colour	(SCREEN 3)

Sprite mode 2 selected: ....... GRAPHIC 3	(SCREEN 4) GRAPHIC 4	(SCREEN 5) GRAPHIC 5	(SCREEN 6) GRAPHIC 6	(SCREEN 7) GRAPHIC 7	(SCREEN 8)





5.2 Sprite mode 1




Sprite mode 1 has the same functions as the sprite mode of MSX1 machines.

Thus programs using this mode can also be run on the MSX1



5.2.1 Number of sprites to be displayed

There are 32 sprites numbered from 0 to 31. Sprites with the smallest numbers have the highest priority. When sprites are placed on the same horizontal line of the screen, up to 4 sprites are placed in their order priority, and the portions of the 5th sprite or higher which conflict with the existing four sprites on a given line are not displayed.



Figure 4.57	Number of sprites to be displayed (sprite mode 1)

-------------------------------------------------------------------------

|									|

|	 --------	 --------	 --------			|

| -------- |	#2 |	 | #3 | -------- | #5 |			|

| | #1 | |	 |	 |	 | | #4 | : :	 ::::::::	|

| |	 | --------	 -------- |	 | ::::::::	 : #6	:	|

| --------			 --------		 |	|	|

|							 --------	|

|									|

|									|

|									|

-------------------------------------------------------------------------



5.2.2 Sprite display settings



The following descriptions are settings to display the sprite.



* Setting the size of the sprite



8 x 8 dots or 16 x 16 dots can be set (see Figure 4.58). By default, 8 x 8

dots is selected.



Figure 4.58	Setting the size of the sprite

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#1	| . | . | . | . | . | . | X | .	|

-----------------------------------------

| 0: 8 x 8 dots +-->





1: 16 x 16 dots




8 x 8 dots				 16 x 16 dots -------------- -		------------------------------	-

|	 | ^		|			 |	^

|	 | |		|			 |	|

|	 | 8 dots		|			 |	|

|	 | |		|			 |	|

|	 | V		|			 |	|

-------------- -		|			 | 16 dots

|<- 8 dots ->|			|			 |	|

|			 |	|

|			 |	|

|			 |	|

|			 |	V

------------------------------	-

|<---	 16 x 16 dots	 --->|



* Expanding the sprite



Figure 4.59 shows how to select whether one dot of the sprite corresponds to one dot of the screen or whether it is expanded double in both the horizontal and vertical directions. By default, the one dot to one dot size is selected.



Figure 4.59	Expanding the sprite

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#1	| . | . | . | . | . | . | . | X	|

-----------------------------------------

|	 0: normal mode +-->

1: expansion mode (2X)

* Setting the sprite pattern generator table

Sprite patterns are defined in the sprite pattern generator table in VRAM. Up to 256 sprites can be defined in the case of 8 x 8 dots, and up to 64 for 16

x 16 dots. Each pattern is numbered from 0 to 255 and is allocated in VRAM as shown in Figure 4.60. For 16 x 16 dots, four 8 x 8 patterns are used from the top of the table. In this case, using any number of these four patterns causes the same sprite to be specified. R#6 is used to set the address in the sprite pattern generator table as shown in Figure 4.60.



Figure 4.60	Structure of the sprite pattern generator table (sprite mode 1)

VRAM



|<-- 1 byte -->|

- ----------------- ---+ <--- R#6

^ | 	 | |	 -----------------------------------------

| | 	 | |	 | 0 | 0 | A16| A15| A14| A13| A12| A11|

| | 	 | |	 -----------------------------------------

8 | 	 | Pattern bytes | 	 | #0

| | 	 | |

| | 	 | |

V | 	 | |

- |---------------| ---+

| 	 | |

| 	 | |

| 	 | |

| 	 | Pattern

| 	 | #1

| 	 | |

| 	 | |

| 	 | |

|---------------| ---+

| . |

.

.

| 	 |

|---------------| Pattern #255

| 	 |



* Setting the sprite attribute table



Each sprite is displayed in one of 32 "sprite planes" exclusively, and the sprite status for each sprite plane is recorded using 4 bytes. The area having the information for each sprite plane is called the sprite attribute table. The starting address in VRAM for this table is set in R#5 and R#11 as shown in Figure 4.61.



The four bytes in the attribute table ocntain the following information:

-------------------------------------------------------------------------

|									|

| Y-coordinate:	specifies Y-coordinate of the sprite. Note that |

|			the top line of the screen is not 0 but 255.	|

|			Setting this value in 208 (D0H) causes sprites	|

|			after this plane not to be displayed.		|

| X-coordinate:	specifies X-coordinate of the sprite.		|

| pattern number:	specifies the character in the sprite pattern	|

|			generator table to be displayed.		|

| colour code: 	specifies the colour (palette number) of the	|

|			portion where the bit of the sprite pattern	|

|			is "1". |

| EC:			Setting "1" to this bit causes the sprite to be |

|			shifted for 32 bits to the left. Using this	|

|			function enables the dot of the sprite to be	|

|			displayed one by one from the left edge of the	|

|			screen. 					|

|									|

-------------------------------------------------------------------------



Figure 4.61	Structure of the sprite attribute table (sprite mode 1)

MSB 7 6 5	 4 3 2	1 0	 LSB

-	----------------------------------------- --+ <--- (*) ^	| :	 Y coordinate (0 to 255) :	| |

|	|----+----+----+----+----+----+----+----| |

|	| :	 X coordinate (0 to 255) :	| |

4 bytes |----+----+----+----+----+----+----+----| Sprite #0 attribute area |	| :	Pattern number (0 to 255) :	| |

|	|----+----+----+----+----+----+----+----| |

V	| EC | 0 | 0 | 0 |	 Colour code	| |

-	|----+----+----+----+----+----+----+----| --+

|					| |

|					| | Sprite #1 attrib. area .			 .

.			 .

.			 .



|					| | Sprite #31 attrib. area |					| |

----------------------------------------- --+



-----------------------------------------

(*) R#5 | A14| A13| A12| A11| A10| 1 | 1	| 1 |

-----------------------------------------

-----------------------------------------

R#11 | 0 | 0 | 0 | 0 | 0 | 0 | A16| A15|

-----------------------------------------



-------------------------------------------

|					 |

|	 --------------------------------- |

|	 |				 | |

|	 |		 |	 ###|: |

|	 |		 |		 | |

|	 |		 |	 ##|:: |

|	 |		 |		 | | EC bit = "0"

|	 |		 V		#|::: |

|	 |				 | |

|	 |####				 | |

|	 | ^				 | |

|	 ---+----------------------------- |

|	 |				 |

--------+----------------------------------

|

The sprite will display from here (X coordinate = 0)

-------------------------------------------

|					 |

|	 --------------------------------- |

|	 |				 | |

| :::|#		 |		 | |

|	 |		 |		 | |

| ::|##		 |		 | |

|	 |		 |		 | | EC bit = "1"

|	:|###		 V		 | |

|	 |				 | |

|	 |####			 ####| |

|	 |			 ^ | |

|	 -----------------------------+--- |

|				 | |

----------------------------------+--------

|

The sprite will display until here (X coordinate = 255)

5.2.3 Judging the sprite conflicts



When two sprites conflict, bit 5 of S#0 becomes "1" to inform of the conflict. A "conflict" means that bits "1" in the sprite pattern whose colour is not "transparent" occupy the same coordinate (see Figure 4.62)

Figure 4.62	Conflict of sprites (sprite mode 1)

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

S#0	| . | . | X | . | . | . | . | .	|

-----------------------------------------

|	 0: Normal

+-->





1: A sprite conflict exists




+-- ---------------------			 ---------------------

|	| \\\\\\\ |	 |			 | \\\\\\\ |	 |

|	| \\\\\\\ |	 | <--- Sprite 1 ---> | \\ -----+---------+-----

8 or 16 | \\\\\\\ |	 |			 | \\ | xx | // | | |

dots	|---------+---------+---------- 	 |----+----- // | | |

|	|	 | /////// |	 | 	 | | /////// | | |

|	|	 | /////// |	 | 	 | |---------- | |

|	|	 | /////// |	 | 	 | |	 | |

+-- ----------+----------	 | 	 -----+--------------- |

|		 | <- Sprite 2 -> |		 |

|		 | 	 ---------------------

|		 |

---------------------



These two sprites do not conflict	 These two sprites conflict

------	------

| \\ |	| // | --> This pattern bit has one part ------	------



When more than 5 sprites are placed on the same line, bit 6 of S#0 becomes "1" and the identifying number of the 5th sprite (the portion which cannot be displayed) is set in the 5 low order bits of S#0.



Figure 4.63	Judging the conflict (sprite mode 1)

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

S#0	| . | X | . | X | X | X | X | X	|

-----------------------------------------

| |			|

| +------------------------+

| Identification number of fifth sprite on a single line |

| 0: Normal

+-->

1: More than 4 sprites are occupying a single line





5.3 Sprite Mode 2




Sprite mode 2 is the newly added mode for MSX-VIDEO. It is not compatible with TMS9918 and cannot be used with MSX1 machines.



5.3.1 Number of sprites to be displayed

The number of sprites which can be displayed on one screen is also 32, but up to eight sprites can be displayed on a given horizontal line of the screen.

The priorities are the same as in mode 1 with the lower numbers having highest priority.



Figure 4.64	Number of sprites to be displayed (sprite mode 2)

----------------------------------------------------------------------------

|									 |

|									 |

| -------	 ------------- -------		 -------	 |

| | #0 | ------- |	#2 | #4 | | #5 |		 | #8 |	 |

| |	 | | #1 | |	 |--- | |	 |---	------- : : ::::::: |

| ------- |	 | ------- |--- ------- |	| #7 | ::::::: : #9 : |

|	 -------	| #3 | | #6 |	| | 	 |	| |

|			------- -------	------- 	 ------- |

|									 |

|									 |

----------------------------------------------------------------------------



5.3.2 Sprite display settings



* Sprite size ................................. same as sprite mode 1



* Expanding sprite ............................ same as sprite mode 1



* Sprite display ON/OFF



In sprite mode 2, the sprite display can be turned ON/OFF by bit 1 of R#8.

When this bit is set to 1, no sprites will appear on the screen.



Figure 4.65	Sprite display specification

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#8	| . | . | . | . | . | . | X | .	|

-----------------------------------------

| 0: Sprite mode on +-->





1: Sprite mode off




* Setting the pattern generator table ......... same as sprite mode 1



* Sprite attribute table



In sprite mode 2, since different colours can be set for each horizontal line of the sprite, the colour information is stored in a sprite colour table as described below, which is independent of the sprite attribute table. Three kinds of information are stored in the sprite attribute table (see Figure 4.66).



-------------------------------------------------------------------------

|									|

| Y-coordinate:	setting this value to 216 (D8H) causes sprites	|

|			after this sprite plane not to be displayed.	|

|			Except for this, it is the same as the sprite	|

|			mode 1. 					|

| X-coordinate:	same as sprite mode 1.				|

| pattern number:	same as sprite mode 1.				|

|									|

-------------------------------------------------------------------------



Figure 4.66	Structure of the sprite attribute table (sprite mode 2)

MSB 7 6 5	 4 3 2	1 0	 LSB

-	----------------------------------------- --+ <--- (*) ^	| :	 Y coordinate (0 to 255) :	| |

|	|----+----+----+----+----+----+----+----| |

|	| :	 X coordinate (0 to 255) :	| |

4 bytes |----+----+----+----+----+----+----+----| Sprite #0 attribute area |	| :	Pattern number (0 to 255) :	| |

|	|----+----+----+----+----+----+----+----| |

V	| :	 : : unused : : :	| |

-	|----+----+----+----+----+----+----+----| --+

|					| |

|					| | Sprite #1 attrib. area .			 .

.			 .

.			 .



|					| | Sprite #31 attrib. area |					| |

----------------------------------------- --+



-----------------------------------------

(*) R#5 | A14| A13| A12| A11| A10| 1 | 1	| 1 |

-----------------------------------------

-----------------------------------------

R#11 | 0 | 0 | 0 | 0 | 0 | 0 | A16| A15|

-----------------------------------------



* Sprite colour table



The colour table is automatically set at the address 512 bytes before the starting address of the sprite attribute table. 16 bytes are allocated for each sprite plane and the following settings are made for each line of the sprite.



-------------------------------------------------------------------------

|									|

| colour code: 	colour can be specified for each line.		|

| EC:			the same as EC bit of the attribute table of	|

|			sprite mode one. When "1", the sprite display |

|			location is shifted 32 bits to the left.	|

|			This also can be specified for each line.	|

| CC:			when CC bit is "1", it can have the same |

|			priority as the sprite "that has the higher |

|			priority than this sprite and whose CC bit is	|

|			"0" and that is nearest to this sprite plane". |

|			When sprites having the same priority are	|

|			overlapped, the colour for which OR (logical	|

|			or) of both colour codes are displayed. In this |

|			case, the overlapping does not cause a conflict |

|			(see Figure 4.68).				|

| IC:			(one line of) the sprite with this bit "1" |

|			does not conflict with other sprites.		|

|									|

-------------------------------------------------------------------------



Figure 4.67	Structure of the sprite colour table (sprite mode 2)

MSB	7 6	 5 4 3	 2 1 0	LSB

----------------------------------------- 	 --+ <-- starting 0 | EC | CC | IC | 0 | Color code | 1st line |	 address |----+----+----+----+----+----+----+----| 	 |	 of the 1 | EC | CC | IC | 0 | Color code | 2nd line |	 sprite |----+----+----+----+----+----+----+----| 	 |	 colour | 		 .		 | 	 |	 table .				 |

.				 | Sprite #0

| 				 | 	 | colour table |----+----+----+----+----+----+----+----| 	 |

15 | EC | CC | IC | 0 | Color code | 16th line |

|----+----+----+----+----+----+----+----| 	 --+

| 		 .		 | 	 .

.				 .

.				 .

| 				 |

|----+----+----+----+----+----+----+----| 	 --+

496 | EC | CC | IC | 0 | Color code | 1th line |

|----+----+----+----+----+----+----+----| 	 |

497 | EC | CC | IC | 0 | Color code | 2nd line | Sprite #31

|----+----+----+----+----+----+----+----| 	 | colour table | 		 .		 | 	 |

.				 |	 starting .				 |	 address | 				 | 	 |	 of the |----+----+----+----+----+----+----+----| 	 |	 sprite 511 | EC | CC | IC | 0 | Color code | 16th line |	 attribute ----------------------------------------- 	 --+ <-- table | |	 |	 |		 |

| |	 |	 +-------------------+

| |	 |	 Specify the colour code (0 to 15) | |	 |	 for the sprite by each line | |	 |					 1 = no | |	 +-------------------> detect conflict: 0 = yed | |

| +------------------------> priority: 0 = yes |					 1 = no

|

+-----------------------------> 32 dot left shifted display: 1 = yes 0 = no



Figure 4.68	CC bit detection

Sprite 1			 Sprite 2	 Sprite 1,2 (overlapped) -------------------	 ------------------- 	-------------------

| ////////// |	 |	 | \\ |	 | 	| xx | ///// |	 |

| ////////// |	 |	 | \\ |	 | 	| xx | ///// |	 |

| ////////// |	 |	 | \\ -------------| 	| xx --------+----|

| ////////// |	 |	 | \\\\\\\\\\\\\\\ | +--| xxxxxxxxxx | \\ |

| ////////// |	 |	 | \\\\\\\\\\\\\\\ | |	| xxxxxxxxxx | \\ |

-------------------	 ------------------- V	-------------------

CC = 0			 CC = 1	 Color code = 8 or 4 = 12



------			 ------			------

| // | Color code = 8	 | \\ | Color code = 4	| xx | Color code=12

------			 ------			------



Note:	1) Conflicts are not detected when the pattern of the sprite whose CC is "1" is piled on the portion CC=0 of the sprite which has a smaller number and is nearest to it.

2) To display the sprite whose CC is "1", CC bit of the sprite which has smaller number should be set to 0.



5.3.3 Judging sprite conflicts



A "conflict" in sprite mode 2 occurs when the display colour of a sprite is not transparent and "1" bits on the line whose CC bit is 0 overlap each other. When two sprites conflict, bit 5 of S#0 becomes "1" and the conflict can be detected (see Figure 4.69). In this case, different from the sprite mode 1, the coordinate where the conflict occurred can be detected by S#3 to S#6 as shown in Figure 4.70. Note that the coordinate which can be obtained by these registers is not the coordinate where the conflict actually occurred. To get this, use Expression 4.5. S#3 to S#6 are reset when S#5 is read out.



Figure 4.69	Conflict of the sprite (sprite mode 2)

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

S#0	| . | . | X | . | . | . | . | .	|

-----------------------------------------

|	 0: normal

+-->





1: conflict occurred




----------------------------

|			 |

| -------------------- |

| | \\\\\\\\\\\\\\\\ | |

| | \\\\\\\\\\\\\\\\ | |

| | \\\\\\\ ---------+----+-----------

| | \\\\\\\ | \\\\\\ | |	 |

| | \\\\\\\ | \\\\\\ | |	 |

| | \\\\\\\ | \\\\\\ | |	 |

| | \\\\\\\ | \\\\\\ | |	 | the attribute of this line - | \\\\\\\ | \ -----+----+-------- - -------------------------

+-- | | \\\\\\\ | \ | xx | // | ///// | | --> | | 0| 0|	: : : : |

|	- ----------+---+----- // | ///// | - -------------------------

|	|	 |	 | /////// | ///// | | | |

|	-------------+---+---------- ///// | | +-----+

|		 |	 | /////////////// | | CC and IC bits are both "0"

| the attribute |	 ------------------- |

| of this line |			 |

|		 |			 |

|		 --------------------------

V

-------------------------

| | 0| 0| : : : :	|

-------------------------

|	 |

+-----+

CC and IC bits are both "0"



Figure 4.70	Readout of the conflict coordinate

MSB 7 6 5	 4 3 2	1 0	 LSB

----------------------------------------- --+

S#3	| X7 | X6 | X5 | X4 | X3 | X2 | X1 | X0 | |

----------------------------------------- | X-coordinate where the | conflict occurred ----------------------------------------- |

S#4	| 1 | 1 | 1 | 1 | 1 | 1 | 1 | X8 | |

----------------------------------------- --+



----------------------------------------- --+

S#5	| Y7 | Y6 | Y5 | Y4 | Y3 | Y2 | Y1 | Y0 | |

----------------------------------------- | Y-coordinate where the | conflict occurred ----------------------------------------- |

S#6	| 1 | 1 | 1 | 1 | 1 | 1 | Y9 | Y8 | |

----------------------------------------- --+



Expression 4.5 Calculating the actual conflict coordinate

---------------------------------------------------------

|							|

| (X-coordinate where the conflict occurred) =	|

| (X-coordinate of S#3 and S#4) - 12		|

|							|

| (Y-coordinate where the conflict occurred) =	|

| (Y-coordinate of S#5 and S#6) - 8 		|

|							|

---------------------------------------------------------



When more than nine sprites are placed on the same horizontal line, bit 6 of S#0 becomes "1" and the number of the sprite plane whose order of priority is 9 is entered to the 5 low order bits of S#0 (see Figure 4.71).



Figure 4.71	Conflict of the sprite (sprite mode 2)

MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

S#0	| . | X | . | X | X | X | X | X	|

-----------------------------------------

| |			|

| +------------------------+

| contains the 9th sprite number |

| 0: normal

+-->

1: more than 9 sprites are occupying the same line





MSX2 TECHNICAL HANDBOOK

-----------------------



Edited by:		ASCII Systems Division

Published by:		ASCII Coprporation - JAPAN

First edition:		March 1987

<i>

Text file typed by:	Nestor Soriano (Konami Man) - SPAIN

March 1997



Changes from the original:



- In Figure 4.72, last "10000H" is corrected to "1FFFFH".



- In Table 4.6, in TEOR line, "else DC+..." is corrected to "else DC=..."



- In Figure 4.76, in R#45 figure, DIX and DIY bits have been placed correctly (they were inverted in the original).



- In Figure 4.79, in R#42 and R#43 explanation, "NY -> of dots..." has been changed to "NY -> number of dots..."



- In List 4.9, in the line with the comment "YMMM command", 11010000 bitfield has been corrected to 11100000.



- In Figure 4.84, "*" mark removed from the explanation of NX.



- In Figure 4.85, in R#45 explanation,	"select source memory" text has been corrected to "select destination memory".



- In List 4.13, labels beginning with "LMMC" have been corrected to "LMCM".



- In List 4.15, in the line with the comment "NY", the "OUT (C),H"

instruction has been corrected to "OUT (C),L".



- In section 6.5.9, the explanation of usage of the LINE command were mixed wih other text. It has been corrected.



- In Figure 4.94, a line explaining the meaning of R#44 has been added.



- In Figure 4.97, BX9 bit has been supressed in S#9 figure.



- In Figure 4.99, a line explaining the meaning of R#44 has been added.



- In Table 4.7, "CLR L" has been corrected to "CMR L".

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



CHAPTER 4 - VDP AND DISPLAY SCREEN (Part 6)





6. VDP COMMAND USAGE




MSX-VIDEO can execute basic graphic operations, which are called VDP

commands. These are done by accessing special harware and are available in the GRAPHIC 4 to GRAPHIC 7 modes. These graphic commands have been made easy to implement, requiring only that the necessary parameters be set in the proper registers before invoking them. This section describes these VDP

commands.





6.1 Coordinate System of VDP Commands




When VDP commands are executed, the location of the source and destination points are represented as (X, Y) coordinates as shown in Figure 4.72. When commands are executed, there is no page division and the entire 128K bytes VRAM is placed in a large coordinate system.



Figure 4.72	Coordinate system of VRAM



GRAPHIC 4 (SCREEN 5)			GRAPHIC 5 (SCREEN 6) ------------------------------	 00000H ------------------------------

| (0,0) 	 (255,0) |	 |	 | (0,0)		 (511,0) |

|	 Page 0	 |	 |	 |		Page 0		 |

| (0,255)	 (255,255) |	 |	 | (0,255)	 (511,255) |

|----------------------------|	 08000H |----------------------------|

| (0,256)	 (255,256) |	 |	 | (0,256)	 (511,256) |

|	 Page 1	 |	 |	 |		Page 1		 |

| (0,511)	 (255,511) |	 |	 | (0,511)	 (511,511) |

|----------------------------|	 10000H |----------------------------|

| (0,512)	 (255,512) |	 |	 | (0,512)	 (511,512) |

|	 Page 2	 |	 |	 |		Page 2		 |

| (0,767)	 (255,767) |	 |	 | (0,767)	 (511,767) |

|----------------------------|	 18000H |----------------------------|

| (0,768)	 (255,768) |	 |	 | (0,768)	 (511,768) |

|	 Page 3	 |	 |	 |		Page 3		 |

| (0,1023)	 (255,1023) |	 |	 | (0,1023)	 (511,1023) |

------------------------------	 1FFFFH ------------------------------



GRAPHIC 7 (SCREEN 8)			GRAPHIC 6 (SCREEN 7) ------------------------------	 00000H ------------------------------

| (0,0) 	 (255,0) |	 |	 | (0,0)		 (511,0) |

|	 Page 0	 |	 |	 |		Page 0		 |

| (0,255)	 (255,255) |	 |	 | (0,255)	 (511,255) |

|----------------------------|	 10000H |----------------------------|

| (0,256)	 (255,256) |	 |	 | (0,256)	 (511,256) |

|	 Page 1	 |	 |	 |		Page 1		 |

| (0,511)	 (255,511) |	 |	 | (0,511)	 (511,511) |

------------------------------	 1FFFFH ------------------------------





6.2 VDP Commands




There are 12 types of VDP commands which can be executed by MSX-VIDEO. These are shown in Table 4.5.



Table 4.5 List of VDP commands

----------------------------------------------------------------------------

| Command name | Destination | Source | Units | Mnemonic | R#46 (4 hi ord) |

|--------------+-------------+--------+-------+----------+-----------------|

|	 | VRAM |	CPU | bytes | HMMC	 | 1	1 1	1 |

| High speed | VRAM |	VRAM | bytes | YMMM	 | 1	1 1	0 |

| move	 | VRAM |	VRAM | bytes | HMMM	 | 1	1 0	1 |

|	 | VRAM |	VDP | bytes | HMMV	 | 1	1 0	0 |

|--------------+-------------+--------+-------+----------+-----------------|

|	 | VRAM |	CPU | dots | LMMC	 | 1	0 1	1 |

| Logical | CPU |	VRAM | dots | LMCM	 | 1	0 1	0 |

| move	 | VRAM |	VRAM | dots | LMMM	 | 1	0 0	1 |

|	 | VRAM |	VDP | dots | LMMV	 | 1	0 0	0 |

|--------------+-------------+--------+-------+----------+-----------------|

| Line	 | VRAM |	VDP | dots | LINE	 | 0	1 1	1 |

|--------------+-------------+--------+-------+----------+-----------------|

| Search | VRAM |	VDP | dots | SRCH	 | 0	1 1	0 |

|--------------+-------------+--------+-------+----------+-----------------|

| Pset	 | VRAM |	VDP | dots | PSET	 | 0	1 0	1 |

|--------------+-------------+--------+-------+----------+-----------------|

| Point | VDP |	VRAM | dots | POINT | 0	1 0	0 |

|--------------+-------------+--------+-------+----------+-----------------|

|	 | ---- |	---- | ----- | ----	 | 0	0 1	1 |

| Reserved | ---- |	---- | ----- | ----	 | 0	0 1	0 |

|	 | ---- |	---- | ----- | ----	 | 0	0 0	1 |

|--------------+-------------+--------+-------+----------+-----------------|

| Stop	 | ---- |	---- | ----- | ----	 | 0	0 0	0 |

----------------------------------------------------------------------------



* When data is written in R#46 (Command register), MSX-VIDEO begins to execute the command after setting 1 to bit 0 (CE/Command Execute) of the status register S#2. Necessary parameters should be set in register R#32 to R#45 before the command is executed.



* When the execution of the command ends, CE becomes 0.



* To stop the execution of the command, execute STOP command.



* Actions of the commands are guaranteed only in the bitmap modes (GRAPHIC 4

to GRAPHIC 7).





6.3 Logical Operations




When commands are executed, various logical operations can be done between data in VRAM and the specified data. Each operation will be done according to the rules listed in Table 4.6.



In the table, SC represents the source color and DC represents the destination colour. IMP, AND, OR, EOR and NOT write the result of each operation to the destination. In operations whose names are preceded by "T", dots which correspond with SC=0 are not the objects of the operations and remains as DC. Using these operations enables only colour portions of two figures to be overlapped, so they are especially effective for animations.



List 4.7 shows an example of these operations.



Table 4.6 List of logical operations

-------------------------------------------------------------------------

| Logical name |					|L03 L02 L01 L00|

|--------------+----------------------------------------+---------------|

|	 |					|		|

| IMP | DC=SC					| 0 0 0 0 |

|	 |					|		|

| AND | DC=SCxDC				| 0 0 0 1 |

|	 |					|		|

| OR | DC=SC+DC				| 0 0 1 0 |

|	 | __	 __ 			|		|

| EOR | DC=SCxDC+SCxDC 			| 0 0 1 1 |

|	 | __					|		|

| NOT | DC=SC					| 0 1 0 0 |

|	 |					|		|

| ---- |					| 0 1 0 1 |

|	 |					|		|

| ---- |					| 0 1 1 0 |

|	 |					|		|

| ---- |					| 0 1 1 1 |

|	 |					|		|

|--------------+----------------------------------------+---------------|

|	 |					|		|

| TIMP | if SC=0 then DC=DC else DC=SC		| 1 0 0 0 |

|	 |					|		|

| TAND | if SC=0 then DC=DC else DC=SCxDC	| 1 0 0 1 |

|	 |					|		|

| TOR | if SC=0 then DC=DC else DC=SC+DC	| 1 0 1 0 |

|	 |			 __	 __ |		|

| TEOR | if SC=0 then DC=DC else DC=SCxDC+SCxDC | 1 0 1 1 |

|	 |			 __		|		|

| TNOT | if SC=0 then DC=DC else DC=SC		| 1 1 0 0 |

|	 |					|		|

| ---- |					| 1 1 0 1 |

|	 |					|		|

| ---- |					| 1 1 1 0 |

|	 |					|		|

| ---- |					| 1 1 1 1 |

|	 |					|		|

-------------------------------------------------------------------------



* SC = Source colour code

* DC = Destination colour code

* EOR = Exclusive OR



List 4.7 Example of the logical operation with T

=========================================================================



1000 '***********************************************************

1010 ' List 4.7 logical operation with T

1020 '***********************************************************

1030 '

1040 SCREEN8 : COLOR 15,0,0 : CLS

1050 DIM A%(3587)

1060 '

1070 LINE (50,50)-(60,100),48,8 : PAINT (51,51),156,48

1080 CIRCLE (55,30),30,255 : PAINT (55,30),240,255

1090 COPY(20,0)-(90,100) TO A%

1100 CLS

1110 '

1120 R=RND(-TIME)

1130 FOR Y=0 TO 100 STEP 3

1140 X=INT(RND(1)*186)

1150 COPY A% TO (X,Y),,TPSET

1160 NEXT

1170 '

1180 GOTO 1180



=========================================================================





6.4 Area Specification




AREA-MOVE commands are for transferring screen data inside areas surrounded by a rectangle. The area to be transferred is specified by one vertex and the length of each side of the rectangle as shown in Figure 4.73. SX and SY

represent the basic point of the rectangle to be transferred and NX and NY

represent the lengt of each side in dots. The two bits, DIX and DIY, are for the direction of transferring data (the meaning of DIX and DIY depends on the type of command). The point where the area is to be transferred is specified in DX and DY.



Figure 4.73	Area specification

----------------------------------------------------------------

|							 |

| (SX,SY)						 |

|	x----------------- -->				 |

|	|		 | DIX				 |

|	|		 |				 |

|	|		 |				 |

|	|		 |				 |

|	------------------ --+ 			 |

|	| DIY		 | 			 |

|	V		 | 			 |

|			 | (DX,DY)		 |

|			 +-> x-----------------	 |

|				 |		 |	 |

|				 |		 |	 |

|				 |		 |	 |

|				 |		 |	 |

|				 ------------------	 |

|							 |

----------------------------------------------------------------





6.5 Use of Each Command




Commands are clasified into three types, high-speed transfer commands, logical transfer commands, and drawing commands. This section describes the commands and their use.



6.5.1 HMMC (CPU -> VRAM high-speed transfer)

Data is transferred into the specified area of VRAM from the CPU (see Figure 4.74). Logical operations cannot be specified. Data is transferred in bytes in high-speed transfer commands such as HMMC. Note that the low order bit of the X-coordinate is not referred to in GRAPHIC 4, or 6 modes. The two low order bits are not referred to in GRAPHIC 5 mode (see Figure 4.75).



Set the parameters as shown in Figure 4.76 to the appropriate registers. At this point, write only the first byte of data to be transferred from the CPU

in R#44. Writing the command code F0H in R#46 causes the command to be executed, and UMSX-VIDEO receives data from R#44 and writes it to VRAM, then waits for data from the CPU.



The CPU writes data after the second byte in R#44. Note that data should be transferred after MSX-VIDEO can receive data (in the case that TR bit is "1"), referring to TR bit of S#2. When the CE bit of S#2 is "0", this means that all data has been transferred (see figure 4.77). List 4.8 shows an example of using HMMC.



Figure 4.74	Action of HMMC command

VRAM or expansion RAM

---------------------------------------------------

|						 | MSX-VIDEO CPU

|						 | -------	 -------

| (DX,DY)					 | | |	 |	 |

|	x------------------------ --> DIX	 | | |	 |	 |

|	|	 NX		|		 | | |	 |	 |

|	| NY			|<----------------+----| |-----|	 |

|	|			|		 | | |	 |	 |

|	-------------------------		 | | |	 |	 |

|	| DIY					 | | |	 |	 |

|	V					 | | |	 |	 |

|						 | -------	 -------

|						 |

---------------------------------------------------



MXD: select the destination memory	0 = VRAM, 1 = expansion RAM



NX: number of dots to be transferred in X direction (0 to 511)*

NY: number of dots to be transferred in Y direction (0 to 1023)

DIX: direction of NX from the origin	0 = right, 1 = left DIY: direction of NY from the origin	0 = below, 1 = above

DX: destination origin X-coordinate (0 to 511)*

DY: destination origin Y-coordinate (0 to 1023)

CLR (R#44:Colour register): 1st byte of data to be transferred

* The one low-order bit for GRAPHIC 4 and 6 modes, or two low-order bits for GRAPHIC 5 mode of the DX and NX registers are ignored.



Figure 4.75	Dots not to be referred to

MSB 7	 6 5 4	 3 2 1	0 LSB

-----------------------------------------

GRAPHIC 4 |	: :	 : | :	 : : |

-----------------------------------------

(1) 		(2)

Since 1 VRAM byte represents 2 dots, 1 low order bit of X-coordinate is not referred to.



MSB 7	 6 5 4	 3 2 1	0 LSB

-----------------------------------------

GRAPHIC 5 |	: |	 : | :	 | : |

-----------------------------------------

(1)	 (2)	 (3)	 (4) Since 1 VRAM byte represents 4 dots, 2 low order bits of X-coordinate are not referred to.



MSB 7	 6 5 4	 3 2 1	0 LSB

-----------------------------------------

GRAPHIC 6 |	: :	 : | :	 : : |

-----------------------------------------

(1) 		(2)

Since 1 VRAM byte represents 2 dots, 1 low order bit of X-coordinate is not referred to.



Figure 4.76	Register settings of HMMC command

> HMMC register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#36	| DX7| DX6| DX5| DX4| DX3| DX2| DX1| DX0|

----------------------------------------- DX ---+

R#37	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | DX8|	|

-----------------------------------------	|

| destination origin -----------------------------------------	|

R#38	| DY7| DY6| DY5| DY4| DY3| DY2| DY1| DY0|	|

----------------------------------------- DY ---+

R#39	| 0 | 0 | 0 | 0 | 0 | 0 | DY9| DY8|

-----------------------------------------



-----------------------------------------

R#40	| NX7| NX6| NX5| NX4| NX3| NX2| NX1| NX0|	 Number of dots in ----------------------------------------- NX ---> X direction to be R#41	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | NX8|	 transferred -----------------------------------------



-----------------------------------------

R#42	| NY7| NY6| NY5| NY4| NY3| NY2| NY1| NY0|	 Number of dots in ----------------------------------------- NY ---> Y direction to be R#43	| 0 | 0 | 0 | 0 | 0 | 0 | NY9| NY8|	 transferred -----------------------------------------



-----------------------------------------		 --+d R#44	| CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 4,6)	|a -----------------------------------------			|t |		 |			|			|a +-------------------+-------------------+			|

X=2N		 X=2N+1	 (N=0, 1, ..., 127)	|t |o

-----------------------------------------			|

| CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 5)	|b -----------------------------------------			|e |	 |	 |	 | 	|			|

+---------+---------+---------+---------+			|t X=4N X=4N+1 X=4N+2	X=4N+3	 (N=0, 1, ..., 127)	|r |a

-----------------------------------------			|n | CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 7)	|s -----------------------------------------		 --+f.

1 byte per dot

-----------------------------------------

R#45	| 0 | -- | MXD| -- | DIY| DIX| -- | -- | ARG (Argument register) -----------------------------------------

|	 | direction (X) |	 |

|	 +-> direction (Y) |

+-----------> select destination memory

> HMMC command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 1 | 1 | 1 | 1 | -- | -- | -- | -- | CMR

-----------------------------------------



Figure 4.77	HMMC command execution flow chart

/-------------------\ | HMMC start |

\-------------------/

|

---------------------

| register setup |

---------------------

|

---------------------

| command execution |

---------------------

|

+---------------->|

|		 |

| ---------------------------

| | Read status register #2 |

| ---------------------------

|		 |

|	//////////+\\\\\\\\\\ Yes (CE bit = 0) |	| command end? |-------------------+

|	\\\\\\\\\\+//////////			|

|		 | No (CE bit = 1)		|

|	//////////+\\\\\\\\\\			|

|<------| transfer? |			|

| No	\\\\\\\\\\+//////////			|

| (TR bit=0)	 | Yes (TR bit = 1)		|

|	---------------------			|

|	| transfer data |			|

|	---------------------			|

|		 |				|

+-----------------+				|

|

+-----------------------------+

|

V

/--------------------\ | HMMC end |

\--------------------/



List 4.8 Example of HMMC command execution =========================================================================



;****************************************************************

; List 4.8 HMMC sample

;		to use, set H, L, D, E, IX and go

;		RAM (IX) ---> VRAM (H,L)-(D,E)

;****************************************************************

;

RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



HMMC:	DI				;disable interrupt

CALL	WAIT.VDP		;wait end of command

LD	A,(WRVDP)

LD	C,A

INC	C			;C := PORT#1's address LD	A,36

OUT	(C),A

LD	A,17+80H

OUT	(C),A			;R#17 := 36



INC	C

INC	C			;C := PORT#3's address XOR	A

OUT	(C),H			;DX

OUT	(C),A

OUT	(C),L			;DY

OUT	(C),A



LD	A,H			;make NX and DIX

SUB	A

LD	D,00000100B

JR	NC,HMMC1

LD	D,00000000B

NEG

HMMC1:	LD	H,A			;H := NX , D := DIX



LD	A,L

SUB	A

LD	E,00001000B

JR	NC,HMMC2

LD	E,00000000B

NEG

HMMC2:	LD	L,A			;L := NY , E := DIY



XOR	A

OUT	(C),H			;NX

OUT	(C),A

OUT	(C),L			;NY

OUT	(C),A

LD	H,(IX+0)

OUT	(C),H			;first DATA LD	A,D

OR	E

OUT	(C),A			;DIX and DIY

LD	A,0F0H

OUT	(C),A			;HMMC command

LD	A,(WRVDP)

LD	C,A			;C := PORT#1's address INC	C

LD	A,44+80H

OUT	(C),A

LD	A,17+80H

OUT	(C),A

INC	C

INC	C



LOOP:	LD	A,2

CALL	GET.STATUS

BIT	0,A			;check CE bit JR	Z,EXIT

BIT	7,A			;check TR bit JR	Z,LOOP

INC	IX

LD	A,(IX+0)

OUT	(C),A

JR	LOOP



EXIT:	LD	A,0

CALL	GET.STATUS		;when exit, you must select S#0

EI

RET



GET.STATUS:				;read status register specified by A PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:				;wait VDP ready

LD	A,2

CALL	GET.STATUS

AND	1

JR	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



6.5.2 YMMM (high-speed transfer between VRAM in Y direction)

Data from a specified VRAM area is transferred into another area in VRAM.

Note that transfers using this command can only be done in the Y direction (see Figure 4.78).



After setting the data as shown in Figure 4.79 in the proper registers, writing command code E0H in R#46 causes the command to be executed. When the CE bit of S#2 is "1", it indicates that the command is currently being executed. List 4.9 shows an example of using YMMM.



Figure 4.78	Actions of YMMM command

VRAM or expansion RAM

---------------------------------------------------

|						 |

|		 (DX,DY)			 |

|			 x------------------------|

|			 |			 |

|			 |			 |

|			 |			 |

|			 -------------------------|

|				 ^		 |

|				 |		 |

|				 |		 |

|		 (DX,SY)			 |

|			 x------------------------| --> DIX

|			 |			 |

|			 | NY			 |

|			 |			 |

|			 -------------------------|

|			 | DIY			 |

|			 V			 |

---------------------------------------------------



MXD: select the destination memory	0 = VRAM, 1 = expansion RAM



SY: source origin Y-coordinate (0 to 1023)

NY: number of dots to be transferred in Y direction (0 to 1023)

DIX: set which to be transferred, to te right end or to the left end of the screen from the source origin	0 = right, 1 = left DIY: direction of NY from the origin	0 = below, 1 = above

DX: destination origin X-coordinate (0 to 511)*

DY: destination origin Y-coordinate (0 to 1023)

* The one low-order bit for GRAPHIC 4 and 6 modes, or two low-order bits for GRAPHIC 5 mode of the DX register are ignored.



Figure 4.79	Register settings of YMMM command

> YMMM register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#34	| SY7| SY6| SY5| SY4| SY3| SY2| SY1| SY0|

----------------------------------------- SY --> source origin R#35	| 0 | 0 | 0 | 0 | 0 | 0 | SY9| SY8|

-----------------------------------------



-----------------------------------------

R#36	| DX7| DX6| DX5| DX4| DX3| DX2| DX1| DX0|

----------------------------------------- DX --> destination and R#37	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | DX8|	 source origin -----------------------------------------



-----------------------------------------

R#38	| DY7| DY6| DY5| DY4| DY3| DY2| DY1| DY0|

----------------------------------------- DY --> destination origin R#39	| 0 | 0 | 0 | 0 | 0 | 0 | DY9| DY8|

-----------------------------------------



-----------------------------------------

R#42	| NY7| NY6| NY5| NY4| NY3| NY2| NY1| NY0|	 number of dots to ----------------------------------------- NY ---> be transferred in R#43	| 0 | 0 | 0 | 0 | 0 | 0 | NY9| NY8|	 Y direction -----------------------------------------



-----------------------------------------

R#45	| 0 | -- | MXD| -- | DIY| DIX| -- | -- | ARG (Argument register) -----------------------------------------

|	 | direction (X) |	 |

|	 +-> direction (Y) |

+-----------> select destination memory

> YMMM command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 1 | 1 | 1 | 0 | -- | -- | -- | -- | CMR

-----------------------------------------



List 4.9 Example of YMMM command execution =========================================================================



;****************************************************************

; List 4.9 YMMM sample

;		to use, set L, E, B, C, D(bit 2) and go ;		VRAM (B,L)-(*,E) ---> VRAM (B,C) ;		DIX must be set in D(bit 2)

;****************************************************************

;

RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



YMMM:	DI				;disable interrupt

PUSH	BC			;save destination CALL	WAIT.VDP		;wait end of command

LD	A,(WRVDP)

LD	C,A

INC	C			;C := PORT#1's address LD	A,34

OUT	(C),A

LD	A,17+80H

OUT	(C),A			;R#17 := 34



INC	C

INC	C			;C := PORT#3's address XOR	A

OUT	(C),L			;SY

OUT	(C),A



LD	A,L			;make NY and DIY

SUB	A

LD	E,00001000B

JP	NC,YMMM1

LD	E,00000000B

NEG

YMMM1:	LD	L,A			;L := NY , D := DIY



LD	A,D

OR	E



POP	DE			;restore DX,DY

PUSH	AF			;save DIX,DIY

XOR	A

OUT	(C),D			;DX

OUT	(C),A

OUT	(C),E			;DY

OUT	(C),A

OUT	(C),A			;dummy OUT	(C),A			;dummy OUT	(C),L			;NY

OUT	(C),A

OUT	(C),A			;dummy POP	AF

OUT	(C),A			;DIX and DIY

LD	A,11100000B		;YMMM command OUT	(C),A



EI

RET



GET.STATUS:

PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JP	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



6.5.3 HMMM (high-speed transfer between VRAM)

Data of specified VRAM area is transferred into another area in VRAM (see Figure 4.80).



After setting the parameters as shown in Figure 4.81, writing D0H in R#46

causes the command to be executed. While the command is being executed, CE

bit of S#2 is "1". List 4.10 shows an example of using HMMM.



Figure 4.80	Actions of HMMM command

VRAM or expansion RAM

----------------------------------------------------------------

|							 |

| (SX,SY)						 |

|	------------------ -->				 |

|	|	NX	 | DIX				 |

|	|		 |				 |

|	| NY		 |				 |

|	|		 |				 |

|	------------------ --+ 			 |

|	| DIY		 | 			 |

|	V		 | 			 |

|			 | (DX,DY)		 |

|			 +-> ------------------	 |

|				 |		 |	 |

|				 |		 |	 |

|				 |		 |	 |

|				 |		 |	 |

|				 ------------------	 |

|							 |

----------------------------------------------------------------



MXS: select the source memory		0 = VRAM, 1 = expansion RAM

MXD: select the destination memory	0 = VRAM, 1 = expansion RAM



SX: source origin X-coordinate (0 to 511)*

SY: source origin Y-coordinate (0 to 1023)

NX: number of dots to be transferred in X direction (0 to 511)*

NY: number of dots to be transferred in Y direction (0 to 1023)

DIX: direction of NX from the origin	0 = right, 1 = left DIY: direction of NY from the origin	0 = below, 1 = above

DX: destination origin X-coordinate (0 to 511)*

DY: destination origin Y-coordinate (0 to 1023)

* The one low-order bit for GRAPHIC 4 and 6 modes, or two low-order bits for GRAPHIC 5 mode of the SX, DX, and NX register are ignored.



Figure 4.81	Register settings of HMMM command

> HMMM register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#32	| SX7| SX6| SX5| SX4| SX3| SX2| SX1| SX0|

|----+----+----+----+----+----+----+----| SX ---+

R#33	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | SX8|	|

-----------------------------------------	|

| source origin -----------------------------------------	|

R#34	| SY7| SY6| SY5| SY4| SY3| SY2| SY1| SY0|	|

|----+----+----+----+----+----+----+----| SY ---+

R#35	| 0 | 0 | 0 | 0 | 0 | 0 | SY9| SY8|

-----------------------------------------



-----------------------------------------

R#36	| DX7| DX6| DX5| DX4| DX3| DX2| DX1| DX0|

|----+----+----+----+----+----+----+----| DX ---+

R#37	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | DX8|	|

-----------------------------------------	|

| destination origin -----------------------------------------	|

R#38	| DY7| DY6| DY5| DY4| DY3| DY2| DY1| DY0|	|

|----+----+----+----+----+----+----+----| DY ---+

R#39	| 0 | 0 | 0 | 0 | 0 | 0 | DY9| DY8|

-----------------------------------------



-----------------------------------------

R#40	| NX7| NX6| NX5| NX4| NX3| NX2| NX1| NX0|	 Number of dots in |----+----+----+----+----+----+----+----| NX ---> X direction to be R#41	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | NX8|	 transferred -----------------------------------------



-----------------------------------------

R#42	| NY7| NY6| NY5| NY4| NY3| NY2| NY1| NY0|	 Number of dots in |----+----+----+----+----+----+----+----| NY ---> Y direction to be R#43	| 0 | 0 | 0 | 0 | 0 | 0 | NY9| NY8|	 transferred -----------------------------------------



-----------------------------------------

R#45	| 0 | -- | MXD| MXS| DIY| DIX| -- | -- | ARG (Argument register) -----------------------------------------

|	 | | direction (X) |	 | |

|	 | +-> direction (Y) |	 |

|	 +------> select source memory |

+-----------> select destination memory

> HMMM command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 1 | 1 | 0 | 1 | -- | -- | -- | -- | CMR

-----------------------------------------



List 4.10 Example of HMMM command execution =========================================================================



;****************************************************************

; List 4.10 HMMM sample

;		 to use, set H, L, D, E, B, C and go ;		 VRAM (H,L)-(D,E) ---> VRAM (B,C) ;		 DIX must be set in D(bit 2)

;****************************************************************

;

RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



HMMM:	DI				;disable interrupt

PUSH	BC			;save destination CALL	WAIT.VDP		;wait end of command

LD	A,(WRVDP)

LD	C,A

INC	C			;C := PORT#1's address LD	A,32

OUT	(C),A

LD	A,80H+17

OUT	(C),A			;R#17 := 32



INC	C

INC	C			;C := PORT#3's address XOR	A

OUT	(C),H			;SX

OUT	(C),A

OUT	(C),L			;SY

OUT	(C),A



LD	A,H			;make NX and DIX

SUB	A

LD	D,00000100B

JP	NC,HMMM1

LD	D,00000000B

NEG

HMMM1:	LD	H,A			;H := NX , D := DIX



LD	A,L			;make NY and DIY

SUB	A

LD	E,00001000B

JP	NC,HMMM2

LD	E,00000000B

NEG

HMMM2:	LD	L,A			;L := NY , E := DIY



LD	A,D

OR	E

POP	DE			;restore DX,DY

PUSH	AF			;save DIX,DIY

XOR	A

OUT	(C),D			;DX

OUT	(C),A

OUT	(C),E			;DY

OUT	(C),A

OUT	(C),H			;NX

OUT	(C),A

OUT	(C),L			;NY

OUT	(C),A

OUT	(C),A			;dummy POP	AF

OUT	(C),A			;DIX and DIY



LD	A,11010000B		;HMMM command OUT	(C),A



EI

RET



GET.STATUS:

PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JP	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



6.5.4 HMMV (painting the rectangle in high speed)

Each byte of data in the specified VRAM area is painted by the specified colour code (see Figure 4.82)



After setting the parameters as shown in Figure 4.83, writing C0H in R#46

causes the command to be executed. While the command is being executed, the CE bit of S#2 is 1. List 4.11 shows an example of using HMMV.



Figure 4.82	Actions of HMMC command

VRAM or expansion RAM

---------------------------------------------------

|						 | MSX-VIDEO

|						 | -------

| (DX,DY)					 | | |

|	x------------------------ --> DIX	 | | |

|	|	 NX		|		 | | |

|	| NY			|<----------------+----| |

|	|			|		 | | |

|	-------------------------		 | | |

|	| DIY					 | | |

|	V					 | | |

|						 | -------

|						 |

---------------------------------------------------



MXD: select memory			0 = VRAM, 1 = expansion RAM



NX: number of dots to be painted in X direction (0 to 511)*

NY: number of dots to be painted in Y direction (0 to 1023)

DIX: direction of NX from the origin	0 = right, 1 = left DIY: direction of NY from the origin	0 = below, 1 = above

DX: origin X-coordinate (0 to 511)*

DY: origin Y-coordinate (0 to 1023)



CLR (R#44:Colour register): Painted data

* The one low-order bit for GRAPHIC 4 and 6 modes, or two low-order bits for GRAPHIC 5 mode of the DX and NX registers are ignored.



Figure 4.83	Register settings of HMMV command

> HMMV register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#36	| DX7| DX6| DX5| DX4| DX3| DX2| DX1| DX0|

|----+----+----+----+----+----+----+----| DX ---+

R#37	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | DX8|	|

-----------------------------------------	|

| origin

-----------------------------------------	|

R#38	| DY7| DY6| DY5| DY4| DY3| DY2| DY1| DY0|	|

|----+----+----+----+----+----+----+----| DY ---+

R#39	| 0 | 0 | 0 | 0 | 0 | 0 | DY9| DY8|

-----------------------------------------



-----------------------------------------

R#40	| NX7| NX6| NX5| NX4| NX3| NX2| NX1| NX0|	 number of dots in |----+----+----+----+----+----+----+----| NX ---> X direction to R#41	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | NX8|	 be painted -----------------------------------------



-----------------------------------------

R#42	| NY7| NY6| NY5| NY4| NY3| NY2| NY1| NY0|	 number of dots in |----+----+----+----+----+----+----+----| NY ---> Y direction to R#43	| 0 | 0 | 0 | 0 | 0 | 0 | NY9| NY8|	 be painted -----------------------------------------



-----------------------------------------		 --+d R#44	| CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 4,6)	|a -----------------------------------------			|t |		 |			|			|a +-------------------+-------------------+			|

X=2N		 X=2N+1	 (N=0, 1, ..., 127)	|t |o

-----------------------------------------			|

| CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 5)	|b -----------------------------------------			|e |	 |	 |	 | 	|			|

+---------+---------+---------+---------+			|p X=4N X=4N+1 X=4N+2	X=4N+3	 (N=0, 1, ..., 127)	|a |i

-----------------------------------------			|n | CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 7)	|t -----------------------------------------		 --+e 1 byte / dot					 d

-----------------------------------------

R#45	| 0 | -- | MXD| -- | DIY| DIX| -- | -- | ARG (Argument register) -----------------------------------------

|	 | painting direction (X) |	 |

|	 +-> painting direction (Y) |

+-----------> memory selection

> HMMV command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 1 | 1 | 0 | 0 | -- | -- | -- | -- | CMR

-----------------------------------------



List 4.11 Example of HMMV command execution =========================================================================



;****************************************************************

; List 4.11 HMMV sample

;		 to use, set H, L, D, E, B and go

;		 B ---> VRAM (H,L)-(D,E) fill

;****************************************************************

;

RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



HMMV:	DI				;disable interrupt

CALL	WAIT.VDP		;wait end of command

LD	A,(WRVDP)

LD	C,A

INC	C			;C := PORT#1's address LD	A,36

OUT	(C),A

LD	A,80H+17

OUT	(C),A			;R#17 := 36



INC	C

INC	C			;C := PORT#3's address XOR	A

OUT	(C),H			;DX

OUT	(C),A

OUT	(C),L			;DY

OUT	(C),A



LD	A,H			;make NX and DIX

SUB	A

LD	D,00000100B

JP	NC,HMMV1

LD	D,00000000B

NEG

HMMV1:	LD	H,A			;H := NX



LD	A,L			;make NY and DIY

SUB	A

LD	E,00001000B

JP	NC,HMMV2

LD	E,00000000B

NEG

HMMV2:	OUT	(C),H

LD	H,A			;H := NY



XOR	A

OUT	(C),A

OUT	(C),H

OUT	(C),A

OUT	(C),B			;fill data XOR	A

OR	D

OR	E

OUT	(C),A			;DIX and DIY



LD	A,11000000B		;HMMV command OUT	(C),A



EI

RET



GET.STATUS:

PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JP	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



6.5.5 LMMC (CPU -> VRAM logical transfer)

Data is transferred from the CPU to thespecified VRAM area in dots (see Figure 4.84). Logical operations with the source can be specified. In the logical transfer commands, such as LMMC, data is transfered in dots and one byte is required for the information of one pixel in all screen modes.



After setting the data as shown in Figure 4.85, write command code B0H in R#46. At this point, logical operations can be specified by using the 4 low order bits of the command register. Data is transferred with reference to the TR and CE bit of S#2, as in HMMC (see Figure 4.86). List 4.12 shows an example of using LMMC.



Figure 4.84	Action of LMMC command

VRAM or expansion RAM

---------------------------------------------------

|						 | MSX-VIDEO CPU

|						 | -------	 -------

| (DX,DY)					 | | |	 |	 |

|	x------------------------ --> DIX	 | | |	 |	 |

|	|	 NX		|		 | | |	 |	 |

|	| NY			|<----------------+----| |-----|	 |

|	|			|		 | | |	 |	 |

|	-------------------------		 | | |	 |	 |

|	| DIY					 | | |	 |	 |

|	V					 | | |	 |	 |

|						 | -------	 -------

|						 |

---------------------------------------------------



MXD: select destination memory		0 = VRAM, 1 = expansion RAM



NX: number of dots to be transferred in X direction (0 to 511) NY: number of dots to be transferred in Y direction (0 to 1023)

DIX: direction of NX from the origin	0 = right, 1 = left DIY: direction of NY from the origin	0 = below, 1 = above

DX: destination origin X-coordinate (0 to 511) DY: destination origin Y-coordinate (0 to 1023)

CLR (R#44:Colour register): 1st byte of data to be transferred

Figure 4.85	Register settings of LMMC command

> LMMC register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#36	| DX7| DX6| DX5| DX4| DX3| DX2| DX1| DX0|

|----+----+----+----+----+----+----+----| DX ---+

R#37	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | DX8|	|

-----------------------------------------	|

| destination origin -----------------------------------------	|

R#38	| DY7| DY6| DY5| DY4| DY3| DY2| DY1| DY0|	|

|----+----+----+----+----+----+----+----| DY ---+

R#39	| 0 | 0 | 0 | 0 | 0 | 0 | DY9| DY8|

-----------------------------------------



-----------------------------------------

R#40	| NX7| NX6| NX5| NX4| NX3| NX2| NX1| NX0|	 Number of dots in |----+----+----+----+----+----+----+----| NX ---> X direction to be R#41	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | NX8|	 transferred -----------------------------------------



-----------------------------------------

R#42	| NY7| NY6| NY5| NY4| NY3| NY2| NY1| NY0|	 Number of dots in |----+----+----+----+----+----+----+----| NY ---> Y direction to be R#43	| 0 | 0 | 0 | 0 | 0 | 0 | NY9| NY8|	 transferred -----------------------------------------



-----------------------------------------		 --+

R#44	| -- | -- | -- | -- | CR3| CR2| CR1| CR0| CLR (GRAPHIC 4,6) |

-----------------------------------------		 |

| data

-----------------------------------------		 | to be | -- | -- | -- | -- | -- | -- | CR1| CR0| CLR (GRAPHIC 5) | trans-

-----------------------------------------		 | ferred |

-----------------------------------------		 |

| CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 7) |

-----------------------------------------		 --+



-----------------------------------------

R#45	| 0 | -- | MXD| -- | DIY| DIX| -- | -- | ARG (Argument register) -----------------------------------------

|	 | direction (X) |	 |

|	 +-> direction (Y) |

+-----------> select destination memory

> LMMC command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 1 | 0 | 1 | 1 | L03| L02| L01| L00| CMR

-----------------------------------------

|			|

+-------------------+

Logical operation

Figure 4.86	LMMC command execution flow chart

/-------------------\ | LMMC start |

\-------------------/

|

---------------------

| register setup |

---------------------

|

---------------------

| command execution |

---------------------

|

+---------------->|

|		 |

| ---------------------------

| | read status register #2 |

| ---------------------------

|		 |

|	//////////+\\\\\\\\\\ Yes (CE bit = 0) |	| command end? |-------------------+

|	\\\\\\\\\\+//////////			|

|		 | No (CE bit = 1)		|

|	//////////+\\\\\\\\\\			|

|<------| transfer? |			|

| No	\\\\\\\\\\+//////////			|

| (TR bit=0)	 | Yes (TR bit = 1)		|

|	---------------------			|

|	| transfer data |			|

|	---------------------			|

|		 |				|

+-----------------+				|

|

+-----------------------------+

|

V

/--------------------\ | LMMC end |

\--------------------/



List 4.12 Example of LMMC command execution =========================================================================



;****************************************************************

; List 4.12	LMMC sample

;		 to use, set H, L, D, E, IX, A and go ;		 RAM (IX) ---> VRAM (H,L)-(D,E) (logi-OP : A) ;****************************************************************

;

RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



LMMC:	DI				;disable interrupt

LD	B,A			;B := LOGICAL OPERATION

CALL	WAIT.VDP		;wait end of command

LD	A,(WRVDP)

LD	C,A

INC	C			;C := PORT#1's address LD	A,36

OUT	(C),A

LD	A,80H+17

OUT	(C),A			;R#17 := 36



INC	C

INC	C			;C := PORT#3's address XOR	A

OUT	(C),H			;DX

OUT	(C),A

OUT	(C),L			;DY

OUT	(C),A



LD	A,H			;make NX and DIX

SUB	A

LD	D,00000100B

JR	NC,LMMC1

LD	D,00000000B

NEG

LMMC1:	LD	H,A			;H := NX , D := DIX



LD	A,L

SUB	A

LD	E,00001000B

JR	NC,LMMC2

LD	E,00000000B

NEG

LMMC2:	LD	L,A			;L := NY , E := DIY



XOR	A

OUT	(C),H			;NX

OUT	(C),A

OUT	(C),L			;NY

OUT	(C),A

LD	A,(IX+0)

OUT	(C),A			;first DATA LD	A,D

OR	E

OUT	(C),A			;DIX and DIY



LD	A,B			;A := LOGICAL OPERATION

OR	10110000B		;LMMC command OUT	(C),A



DEC	C

DEC	C



LOOP:	LD	A,2

CALL	GET.STATUS

BIT	0,A			;check CE bit JP	Z,EXIT

BIT	7,A			;check TR bit JP	Z,LOOP

INC	IX

LD	A,(IX+0)

OUT	(C),A

JR	LOOP



EXIT:	LD	A,0

CALL	GET.STATUS



EI

RET



GET.STATUS:

PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JR	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



6.5.6 LMCM (VRAM - CPU logical transfer)

Data is transferred from the specified VRAM area to CPU in dots (see Figure 4.87)



After setting the parameters as shown in Figure 4.88, writing command code A0H in R#46 causes the command to be executed and data to be transferred from MSX-VIDEO. The CPU refers to the TR bit of S#2 and, since data of MSX-VIDEO

has been prepared if this bit is "1", the CPU reads data from S#7. When CE

bit of S#2 is "0", data comes to the end (see Figure 4.89). List 4.13 shows an example of using LMCM.



Figure 4.87	Action of LMCM command

VRAM or expansion RAM

---------------------------------------------------

|						 | MSX-VIDEO CPU

|						 | -------	 -------

| (SX,SY)					 | | |	 |	 |

|	x------------------------ --> DIX	 | | |	 |	 |

|	|	 NX		|		 | | |	 |	 |

|	| NY			|-----------------+--->| |---->|	 |

|	|			|		 | | |	 |	 |

|	-------------------------		 | | |	 |	 |

|	| DIY					 | | |	 |	 |

|	V					 | | |	 |	 |

|						 | -------	 -------

|						 |

---------------------------------------------------



MXS: select source memory		0 = VRAM, 1 = expansion RAM



SX: source origin X-coordinate (0 to 511) SY: source origin Y-coordinate (0 to 1023)

NX: number of dots to be transferred in X direction (0 to 511) NY: number of dots to be transferred in Y direction (0 to 1023)

DIX: direction of NX from the origin	0 = right, 1 = left DIY: direction of NY from the origin	0 = below, 1 = above

Figure 4.88	Register settings of LMCM command

> LMCM register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#32	| SX7| SX6| SX5| SX4| SX3| SX2| SX1| SX0|

|----+----+----+----+----+----+----+----| SX ---+

R#33	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | SX8|	|

-----------------------------------------	|

| source origin -----------------------------------------	|

R#34	| SY7| SY6| SY5| SY4| SY3| SY2| SY1| SY0|	|

|----+----+----+----+----+----+----+----| SY ---+

R#35	| 0 | 0 | 0 | 0 | 0 | 0 | SY9| SY8|

-----------------------------------------



-----------------------------------------

R#40	| NX7| NX6| NX5| NX4| NX3| NX2| NX1| NX0|	 Number of dots in |----+----+----+----+----+----+----+----| NX ---> X direction to be R#41	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | NX8|	 transferred -----------------------------------------



-----------------------------------------

R#42	| NY7| NY6| NY5| NY4| NY3| NY2| NY1| NY0|	 Number of dots in |----+----+----+----+----+----+----+----| NY ---> Y direction to be R#43	| 0 | 0 | 0 | 0 | 0 | 0 | NY9| NY8|	 transferred -----------------------------------------



-----------------------------------------

R#45	| 0 | -- | -- | MXS| DIY| DIX| -- | -- | ARG (Argument register) -----------------------------------------

| | direction (X) | |

| +-> direction (Y) |

+------> select source memory

> LMCM command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 1 | 0 | 1 | 0 | -- | -- | -- | -- | CMR

-----------------------------------------



-----------------------------------------

S#7	| 0 | 0 | 0 | 0 | C3 | C2 | C1 | C0 | status register(GRAPHIC4,6) -----------------------------------------



-----------------------------------------

S#7	| 0 | 0 | 0 | 0 | 0 | 0 | C1 | C0 | status register (GRAPHIC 5) -----------------------------------------



-----------------------------------------

S#7	| C7 | C6 | C5 | C4 | C3 | C2 | C1 | C0 | status register (GRAPHIC 7) -----------------------------------------



Figure 4.89	LMCM command execution flow chart

/-------------------\ | LMCM start |

\-------------------/

|

---------------------

| register setup |

---------------------

|

---------------------

| command execution |

---------------------

|

+---------------->|

|		 |

| ---------------------------

| | read status register #2 |

| ---------------------------

|		 |

|	//////////+\\\\\\\\\\ No (TR bit = 0) |	| data prepared? |-------------------+

|	\\\\\\\\\\+//////////			|

|		 | Yes (TR bit = 1)		|

|		 |				|

| ---------------------------		|

| | read status register #7 |		|

| ---------------------------		|

|		 |				|

|		 |<----------------------------+

|		 |

|	//////////+\\\\\\\\\\

+-------| command end? |

No	\\\\\\\\\\+//////////

(CE bit=1)	 | Yes (CE bit = 0) |

V

/--------------------\ | LMCM end |

\--------------------/



* Note 1: Read status register #7 in "register setup", since TR bit should be reset before the command execution.



* Note 2: Though last data was set in register #7 and TR bit was 1, the command would end inside of the MSX-VIDEO and CE would be zero.



List 4.13 Example of LMCM command execution =========================================================================



;****************************************************************

; List 4.13	LMCM sample

;		 to use, set H, L, D, E, IX, A and go ;		 VRAM (H,L)-(D,E) ---> RAM (IX) ;****************************************************************

;

RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



LMCM:	DI				;disable interrupt

LD	B,A			;B := LOGICAL OPERATION

CALL	WAIT.VDP		;wait end of command

LD	A,(WRVDP)

LD	C,A

INC	C			;C := PORT#1's address LD	A,32

OUT	(C),A

LD	A,80H+17

OUT	(C),A			;R#17 := 32

INC	C

INC	C			;C := PORT#3's address XOR	A

OUT	(C),H			;SX

OUT	(C),A

OUT	(C),L			;SY

OUT	(C),A

OUT	(C),A			;dummy OUT	(C),A			;dummy OUT	(C),A			;dummy OUT	(C),A			;dummy LD	A,H			;make NX and DIX

SUB	A

LD	D,00000100B

JR	NC,LMCM1

LD	D,00000000B

NEG

LMCM1:	LD	H,A			;H := NX , D := DIX



LD	A,L

SUB	A

LD	E,00001000B

JR	NC,LMCM2

LD	E,00000000B

NEG

LMCM2:	LD	L,A			;L := NY , E := DIY



XOR	A

OUT	(C),H			;NX

OUT	(C),A

OUT	(C),L			;NY

OUT	(C),A

LD	A,(IX+0)

OUT	(C),A			;dummy LD	A,D

OR	E

OUT	(C),A			;DIX and DIY

LD	A,7

CALL	GET.STATUS

LD	A,B			;A := LOGICAL OPERATION

OR	10100000B		;LMCM command OUT	(C),A

LD	A,(RDVDP)

LD	C,A			;C := PORT#1's address LOOP:	LD	A,2

CALL	GET.STATUS

BIT	0,A			;check CE bit JP	Z,EXIT

BIT	7,A			;check TR bit JP	Z,LOOP

LD	A,7

CALL	GET.STATUS

LD	(IX+0),A

INC	IX

JR	LOOP



EXIT:	LD	A,0

CALL	GET.STATUS

EI

RET



GET.STATUS:

PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JR	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



6.5.7. LMMM (VRAM->VRAM logical transfer)

Data of the specified VRAM area is transferred into another VRAM area in dots (see figure 4.9)



After setting the parameters as shown in Figure 4.91, writing command code 9XH (X means a logical operation) in R#46 causes the command to be executed.

While the CE bit of S#2 is "1", the command is being executed. List 4.14

shows an example of using LMMM.



Figure 4.90	Actions of LMMM command

VRAM or expansion RAM

----------------------------------------------------------------

|							 |

| (SX,SY)						 |

|	------------------ -->				 |

|	|	NX	 | DIX				 |

|	|		 |				 |

|	| NY		 |				 |

|	|		 |				 |

|	------------------ --+ 			 |

|	| DIY		 | 			 |

|	V		 | 			 |

|			 | (DX,DY)		 |

|			 +-> ------------------	 |

|				 |		 |	 |

|				 |		 |	 |

|				 |		 |	 |

|				 |		 |	 |

|				 ------------------	 |

|							 |

----------------------------------------------------------------



MXS: select the source memory		0 = VRAM, 1 = expansion RAM

MXD: select the destination memory	0 = VRAM, 1 = expansion RAM



SX: source origin X-coordinate (0 to 511) SY: source origin Y-coordinate (0 to 1023)

NX: number of dots to be transferred in X direction (0 to 511) NY: number of dots to be transferred in Y direction (0 to 1023)

DIX: direction of NX from the origin	0 = right, 1 = left DIY: direction of NY from the origin	0 = below, 1 = above

DX: destination origin X-coordinate (0 to 511) DY: destination origin Y-coordinate (0 to 1023)

Figure 4.91	Register settings of LMMM command

> LMMM register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#32	| SX7| SX6| SX5| SX4| SX3| SX2| SX1| SX0|

|----+----+----+----+----+----+----+----| SX ---+

R#33	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | SX8|	|

-----------------------------------------	|

| source origin -----------------------------------------	|

R#34	| SY7| SY6| SY5| SY4| SY3| SY2| SY1| SY0|	|

|----+----+----+----+----+----+----+----| SY ---+

R#35	| 0 | 0 | 0 | 0 | 0 | 0 | SY9| SY8|

-----------------------------------------



-----------------------------------------

R#36	| DX7| DX6| DX5| DX4| DX3| DX2| DX1| DX0|

|----+----+----+----+----+----+----+----| DX ---+

R#37	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | DX8|	|

-----------------------------------------	|

| destination origin -----------------------------------------	|

R#38	| DY7| DY6| DY5| DY4| DY3| DY2| DY1| DY0|	|

|----+----+----+----+----+----+----+----| DY ---+

R#39	| 0 | 0 | 0 | 0 | 0 | 0 | DY9| DY8|

-----------------------------------------



-----------------------------------------

R#40	| NX7| NX6| NX5| NX4| NX3| NX2| NX1| NX0|	 Number of dots in |----+----+----+----+----+----+----+----| NX ---> X direction to be R#41	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | NX8|	 transferred -----------------------------------------



-----------------------------------------

R#42	| NY7| NY6| NY5| NY4| NY3| NY2| NY1| NY0|	 Number of dots in |----+----+----+----+----+----+----+----| NY ---> Y direction to be R#43	| 0 | 0 | 0 | 0 | 0 | 0 | NY9| NY8|	 transferred -----------------------------------------



-----------------------------------------

R#45	| 0 | -- | MXD| MXS| DIY| DIX| -- | -- | ARG (Argument register) -----------------------------------------

|	 | | direction (X) |	 | |

|	 | +-> direction (Y) |	 |

|	 +------> select source memory |

+-----------> select destination memory

> LMMM command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 1 | 0 | 0 | 1 | L03| L02| L01| L00| CMR

-----------------------------------------

|			|

+-------------------+

Logical operation

List 4.14 Example of LMMM command execution =========================================================================



;****************************************************************

; List 4.14 LMMM sample

;		 to use, set H, L, D, E, B, C, A and go ;		 VRAM (H,L)-(D,E) ---> VRAM (B,C) (logi-OP : A) ;****************************************************************

;

RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



LMMM:	DI				;disable interrupt

PUSH	AF			]save LOGICAL OPERATION

PUSH	BC			;save DESTINATION

CALL	WAIT.VDP		;wait end of command

LD	A,(WRVDP)

LD	C,A

INC	C			;C := PORT#1's address LD	A,32

OUT	(C),A

LD	A,80H+17

OUT	(C),A			;R#17 := 32



INC	C

INC	C			;C := PORT#3's address XOR	A

OUT	(C),H			;SX

OUT	(C),A

OUT	(C),L			;SY

OUT	(C),A



LD	A,H			;make NX and DIX

SUB	A

LD	D,00000100B

JP	NC,LMMM1

LD	D,00000000B

NEG

LMMM1:	LD	H,A			;H := NX , D := DIX



LD	A,L			;make NY and DIY

SUB	A

LD	E,00001000B

JP	NC,LMMM2

LD	E,00000000B

NEG

LMMM2:	LD	L,A			;L := NY , E := DIY



LD	A,D

OR	E

POP	DE			;restore DX,DY

PUSH	AF			;save DIX,DIY

XOR	A

OUT	(C),D			;DX

OUT	(C),A

OUT	(C),E			;DY

OUT	(C),A

OUT	(C),H			;NX

OUT	(C),A

OUT	(C),L			;NY

OUT	(C),A

OUT	(C),A			;dummy POP	AF

OUT	(C),A			;DIX and DIY



POP	AF			;A := LOGICAL OPERATION

OR	10010000B		;LMMM command OUT	(C),A



EI

RET



GET.STATUS:

.	PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JP	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



6.5.8 LMMV (VRAM logical paint)



The specified VRAM area is painted by the colour code in dots (see Figure 4.92). Logical operations between data in VRAM and the specified data are allowed.



After setting the parameters as shown in Figure 4.93, writing command code 8Xh (X means a logical operation) in R#46 causes the command to be executed.

While the CE bit of S#2 is "1", the command is being executed. List 4.15

shows an example of using LMMV.



Figure 4.92	Actions of LMMV command

VRAM or expansion RAM

---------------------------------------------------

|						 | MSX-VIDEO

|						 | -------

| (DX,DY)					 | | |

|	x------------------------ --> DIX	 | | |

|	|	 NX		|		 | | |

|	| NY			|<----------------+----| |

|	|			|		 | | |

|	-------------------------		 | | |

|	| DIY					 | | |

|	V					 | | |

|						 | -------

|						 |

---------------------------------------------------



MXD: select memory			0 = VRAM, 1 = expansion RAM



NX: number of dots to be painted in X direction (0 to 511) NY: number of dots to be painted in Y direction (0 to 1023)

DIX: direction of NX from the origin	0 = right, 1 = left DIY: direction of NY from the origin	0 = below, 1 = above

DX: origin X-coordinate (0 to 511)

DY: origin Y-coordinate (0 to 1023)



CLR (R#44:Colour register): Painted data

Figure 4.93	Register settings of LMMV command

> LMMV register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#36	| DX7| DX6| DX5| DX4| DX3| DX2| DX1| DX0|

|----+----+----+----+----+----+----+----| DX ---+

R#37	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | DX8|	|

-----------------------------------------	|

| origin

-----------------------------------------	|

R#38	| DY7| DY6| DY5| DY4| DY3| DY2| DY1| DY0|	|

|----+----+----+----+----+----+----+----| DY ---+

R#39	| 0 | 0 | 0 | 0 | 0 | 0 | DY9| DY8|

-----------------------------------------



-----------------------------------------

R#40	| NX7| NX6| NX5| NX4| NX3| NX2| NX1| NX0|	 number of dots in |----+----+----+----+----+----+----+----| NX ---> X direction to R#41	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | NX8|	 be painted -----------------------------------------



-----------------------------------------

R#42	| NY7| NY6| NY5| NY4| NY3| NY2| NY1| NY0|	 number of dots in |----+----+----+----+----+----+----+----| NY ---> Y direction to R#43	| 0 | 0 | 0 | 0 | 0 | 0 | NY9| NY8|	 be painted -----------------------------------------



-----------------------------------------		 --+

R#44	| 0 | 0 | 0 | 0 | CR3| CR2| CR1| CR0| CLR (GRAPHIC 4,6)	|data -----------------------------------------			|

|to

-----------------------------------------			|

| 0 | 0 | 0 | 0 | 0 | 0 | CR1| CR0| CLR (GRAPHIC 5)	|be -----------------------------------------			|

|tran

-----------------------------------------			|sfe | CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 7)	|rred -----------------------------------------		 --+



-----------------------------------------

R#45	| 0 | -- | MXD| -- | DIY| DIX| -- | -- | ARG (Argument register) -----------------------------------------

|	 | painting direction (X) |	 |

|	 +-> painting direction (Y) |

+-----------> memory selection

> LMMV command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 1 | 0 | 0 | 0 | L03| L03| L01| L00| CMR

-----------------------------------------

|			|

+-------------------+

Logical operation

List 4.15 Example of LMMV command execution =========================================================================



;****************************************************************

; List 4.15 LMMV sample

;		 to use, set H, L, D, E, B, A and go ;		 data B ---> fill VRAM (H,L)-(D,E) (logi-op : A) ;****************************************************************

;

RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



LMMV:	DI				;disable interrupt

PUSH	AF			;save LOGICAL OPERATION

PUSH	BC			;save FILL DATA CALL	WAIT.VDP		;wait end of command

LD	A,(WRVDP)

LD	C,A

INC	C			;C := PORT#1's address LD	A,36

OUT	(C),A

LD	A,80H+17

OUT	(C),A			;R#17 := 36



INC	C

INC	C			;C := PORT#3's address XOR	A

OUT	(C),H			;DX

OUT	(C),A

OUT	(C),L			;DY

OUT	(C),A



LD	A,H			;make NX and DIX

SUB	A

LD	D,00000100B

JP	NC,LMMV1

LD	D,00000000B

NEG

LMMV1:	LD	H,A			;H := NX , D := DIX



LD	A,L			;make NY and DIY

SUB	A

LD	E,00001000B

JP	NC,LMMV2

LD	E,00000000B

NEG

LMMV2:	LD	L,A			;L := NY , E := DIY



XOR	A

OUT	(C),H			;NX

OUT	(C),A

OUT	(C),L			;NY

OUT	(C),A

POP	AF

OUT	(C),A			;FILL DATA LD	A,D

OR	E

OUT	(C),A			;DIX and DIY



POP	AF			;restore LOGICAL OPERATION

OR	A,10000000B		;LMMV command OUT	(C),A



EI

RET



GET.STATUS:

PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JP	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



6.5.9 LINE (drawing a line)



Lines can be drawn between any coordinates in VRAM. The parameters to be specified include the (X,Y) coordinates of the starting point and the X and Y

lengths in units to the ending point (see Figure 4.94). Logical operations between data in VRAM and the specified data are allowed.



After setting the parameters as shown in Figure 4.94, writing command code 7XH (X means a logical operation) in R#46 causes the command to be executed.

While the CE bit of S#2 is "1", the command is being executed. List 4.16

shows an example of using LINE.



Figure 4.94	Actions of LINE command

VRAM or expansion RAM

---------------------------------------------------

|						 |

|			 / : ^		 |

|			 / : |		 |

|			/ : DIY		 |

|		 / : 		 |

|		 /	 Min : 		 |

|		 /	 : 		 |

|		/	 : 		 |

|	 / Maj : 		 |

|	 x................. -> DIX		 |

|	 (DX,DY)				 |

|						 |

---------------------------------------------------



MXD: select memory			0 = VRAM, 1 = expansion RAM



Maj: number of dots of major side (0 to 1023) Maj: number of dots of minor side (0 to 512)

MAJ: 0 = The major side is parallel to X axis MAJ: 1 = The major side is parallel to Y axis, or the major side = the minor side

DIX: direction of the end from the origin 0 = right, 1 = left DIY: direction of the end from the origin 0 = below, 1 = above

DX: origin X-coordinate (0 to 511)

DY: origin Y-coordinate (0 to 1023)



CLR (R#44:Colour register): Line colour data

Figure 4.95	Register settings of LINE command

> LINE register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#36	| DX7| DX6| DX5| DX4| DX3| DX2| DX1| DX0|

|----+----+----+----+----+----+----+----| DX ---+

R#37	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | DX8|	|

-----------------------------------------	|

| origin

-----------------------------------------	|

R#38	| DY7| DY6| DY5| DY4| DY3| DY2| DY1| DY0|	|

|----+----+----+----+----+----+----+----| DY ---+

R#39	| 0 | 0 | 0 | 0 | 0 | 0 | DY9| DY8|

-----------------------------------------



-----------------------------------------

R#40	| NX7| NX6| NX5| NX4| NX3| NX2| NX1| NX0|	 number of dots |----+----+----+----+----+----+----+----| Maj (NX) -> of the major R#41	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | NX8|	 side -----------------------------------------



-----------------------------------------

R#42	| NY7| NY6| NY5| NY4| NY3| NY2| NY1| NY0|	 number of dots |----+----+----+----+----+----+----+----| Min (NY) -> of the minor R#43	| 0 | 0 | 0 | 0 | 0 | 0 | NY9| NY8|	 side -----------------------------------------



-----------------------------------------		 --+

R#44	| 0 | 0 | 0 | 0 | CR3| CR2| CR1| CR0| CLR (GRAPHIC 4,6)	|

-----------------------------------------			|co-

|lour

-----------------------------------------			|

| 0 | 0 | 0 | 0 | 0 | 0 | CR1| CR0| CLR (GRAPHIC 5)	|code -----------------------------------------			|

|data

-----------------------------------------			|

| CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 7)	|

-----------------------------------------		 --+



-----------------------------------------

R#45	| 0 | -- | MXD| -- | DIY| DIX| -- | MAJ| ARG (Argument register) -----------------------------------------

|	 | |	 major side selection |	 | V

|	 | direction to the end (X) |	 |

|	 +-> direction to the end (Y) |

+-----------> memory selection

> LINE command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 0 | 1 | 1 | 1 | L03| L03| L01| L00| CMR

-----------------------------------------

|			|

+-------------------+

Logical operation

List 4.16 Example of LINE command execution =========================================================================



;****************************************************************

; List 4.16 LINE sample

;		 to use, set H, L, D, E, B, A and go ;		 draw LINE (H,L)-(D,E) with color B, log-op A ;****************************************************************

;

RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



LINE:	DI				;disable interrupt

PUSH	AF			;save LOGICAL OPERATION

PUSH	BC			;save COLOR

CALL	WAIT.VDP		;wait end of command LD	A,(WRVDP)

LD	C,A

INC	C			;C := PORT#1's address LD	A,36

OUT	(C),A

LD	A,80H+17

OUT	(C),A			;R#17 := 36



INC	C

INC	C			;C := PORT#3's address XOR	A

OUT	(C),H			;DX

OUT	(C),A

OUT	(C),L			;DY

OUT	(C),A



LD	A,H			;make DX and DIX

SUB	D

LD	D,00000100B

JP	NC,LINE1

LD	D,00000000B

NEG

LINE1:	LD	H,A			;H := DX , D := DIX



LD	A,L			;make DY and DIY

SUB	E

LD	E,00001000B

JP	NC,LINE2

LD	E,00000000B

NEG

LINE2:	LD	L,A			;L := DY , E := DIY



CP	H			;make Maj and Min JP	C,LINE3

XOR	A

OUT	(C),L			;long side OUT	(C),A

OUT	(C),H			;short side OUT	(C),A

LD	A,00000001B		;MAJ := 1

JP	LINE4



LINE3:	XOR	A

OUT	(C),H			;NX

OUT	(C),A

OUT	(C),L			;NY

OUT	(C),A

LD	A,00000000B		;MAJ := 0



LINE4:	OR	D

OR	E			;A := DIX , DIY , MAJ

POP	HL			;H := COLOR

OUT	(C),H

OUT	(C),A

POP	AF			;A := LOGICAL OPERATION

OR	01110000B

OUT	(C),A

LD	A,8FH

OUT	(C),A

EI

RET



GET.STATUS:

PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JP	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



6.5.10 SRCH (colour code search)



SRCH searches for the existence of the specified colour from any coordinate on VRAM to the right or the left (see figure 4.96). This is very useful for paint routines.



After setting the parameters as shown in Figure 4.97, writing 60H in R#46

causes the command to be executed. The command terminates when the objective colour is found or when it cannot be found after searching for it to the screen edge. While the CE bit of S#2 is "1", the command is being executed (see Figure 4.98).



After the command ends, the objective colour code is stored in S#8 and S#9.

List 4.17 shows an example of using SRCH.



Figure 4.96	Actions of SRCH command

VRAM or expansion RAM

---------------------------------------------------

|						 |

|						 |

|						 |

|						 |

|	 (SX,SY)	 DIX			 |

|	 x......................>x	 |

|				 Border	 |

|				 colour	 |

|				 point	 |

|						 |

|						 |

|						 |

---------------------------------------------------



MXD: memory selection for the seacrh	0 = VRAM, 1 = expansion RAM



SX: search origin X-coordinate (0 to 511) SY: search origin Y-coordinate (0 to 1023)

DIX: direction for the search from the origin	 0 = right, 1 = left

EQ: 0 = ends the execution when the border colour is found 1 = ends the execution when the colour is found other than the border colour

CLR (R#44:Colour register): border colour

Figure 4.97	Register settings of SRCH command

> SRCH register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#32	| SX7| SX6| SX5| SX4| SX3| SX2| SX1| SX0|

|----+----+----+----+----+----+----+----| SX ---+

R#33	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | SX8|	|

-----------------------------------------	|

| search origin -----------------------------------------	|

R#34	| SY7| SY6| SY5| SY4| SY3| SY2| SY1| SY0|	|

|----+----+----+----+----+----+----+----| SY ---+

R#35	| 0 | 0 | 0 | 0 | 0 | 0 | SY9| SY8|

-----------------------------------------

b

-----------------------------------------		 --+o R#44	| 0 | 0 | 0 | 0 | CR3| CR2| CR1| CR0| CLR (GRAPHIC 4,6)	|r -----------------------------------------			|d |e

-----------------------------------------			|r | 0 | 0 | 0 | 0 | 0 | 0 | CR1| CR0| CLR (GRAPHIC 5)	|

-----------------------------------------			|c |o

-----------------------------------------			|l | CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 7)	|o -----------------------------------------		 --+u r

-----------------------------------------

R#45	| -- | -- | MXD| -- | -- | DIX| EQ | -- | ARG (Argument register) -----------------------------------------

|		 |	the condition for terminating |		 |	the execution |		 V

|		 search direction (X) |

+-----------> memory selection for the search

> SRCH command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 0 | 1 | 1 | 0 | -- | -- | -- | -- | CMR

-----------------------------------------



-----------------------------------------

S#2	| -- | -- | -- | BO | -- | -- | -- | CE | CMR

-----------------------------------------

|		 when the command ends : 0

|

+-------> when the border colour is found : 1



-----------------------------------------

S#8	| BX7| BX6| BX5| BX4| BX3| BX2| BX1| BX0| X-coordinate when the ----------------------------------------- border colour is found S#9	| 1 | 1 | 1 | 1 | 1 | 1 | 1 | BX8|

-----------------------------------------



Figure 4.98	SRCH command execution flowchart

/-------------------\ | SRCH start |

\-------------------/

|

---------------------

| register setup |

---------------------

|

---------------------

| command execution |

---------------------

|

+---------------->|

|		 |

| ---------------------------

| | Read status register #2 |

| ---------------------------

|		 |

|	//////////+\\\\\\\\\\

+-------| command end? |

No	\\\\\\\\\\+//////////

(CE bit = 1)	 |

| Yes (CE bit = 0) |

/////////////+\\\\\\\\\\\\\ +----| Is border colour found? |

| \\\\\\\\\\\\\+/////////////

| No		 |

| (BO bit = 0)	 | Yes (BO bit = 1)

|		 |

| ---------------------------

| | Read status register #8 |

| ---------------------------

|		 |

| ---------------------------

| | Read status register #2 |

| ---------------------------

|		 |

+---------------->|

|

V

/--------------------\ | SRCH end |

\--------------------/



List 4.17 Example of SRCH command execution =========================================================================



;****************************************************************

; List 4.17 SRCH sample

;		 to use, set H, L, E, A as follows ;		 srch (x:H, y:L, color:E, arg(reg#45) : A) ;		 returns: Z (not found)

;			 NZ (A := X)

;****************************************************************

;

RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



SRCH:	DI				;disable interrupt

PUSH	AF			;save arg CALL	WAIT.VDP



LD	A,(WRVDP)

LD	C,A

INC	C			;C := PORT#1's address

LD	D,0

LD	A,32+80H

OUT	(C),H

OUT	(C),A			;R#32 := H

INC	A

OUT	(C),D

OUT	(C),A			;R#33 := 0

INC	A

OUT	(C),L

OUT	(C),A			;R#34 := L

INC	A

OUT	(C),D

OUT	(C),A			;R#35 := 0

LD	A,44+80H

OUT	(C),E

OUT	(C),A			;R#44 := E

INC	A

LD	E,A

POP	AF			;A := ARG

OUT	(C),A

OUT	(C),E			;R#45 := A

LD	A,01100000B

OUT	(C),A

INC	E

OUT	(C),E			;R#46 := SRCH command

LOOP:	LD	A,2

CALL	GET.STATUS

BIT	0,A

JP	NZ,LOOP

LD	E,A

LD	A,8

CALL	GET.STATUS

LD	D,A

LD	A,9

CALL	GET.STATUS

LD	A,D

BIT	4,E



EI

RET



GET.STATUS:

PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JP	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



List 4.18 Simple PAINT routine using SRCH and LINE

=========================================================================



;****************************************************************

; List 4.18 SRCH and LINE sample

;		 search color to right and left,

;		 then draw line between the two points ;****************************************************************

;

EXTRN	SRCH

EXTRN	LINE



Y	EQU	0A800H

X	EQU	0A801H

COL	EQU	0A802H

ARG	EQU	0A803H

PCOL	EQU	0A804H



;----- program start -----



MAIN:	LD	(STK),SP

LD	SP,AREA

LD	HL,(Y)

LD	A,(COL)

LD	E,A

LD	A,(ARG)

PUSH	HL

PUSH	DE

SET	2,A

CALL	SRCH

POP	DE

POP	HL

JP	NZ,S1

LD	A,(X)

DEC	A





S1:	INC	A


PUSH	AF


LD	A,(ARG)

RES	2,A

CALL	SRCH

JP	NZ,S2

LD	A,(X)

INC	A





S2:	DEC	A


LD	D,A

POP	AF

LD	H,A

LD	A,(Y)

LD	L,A

LD	E,A

LD	A,(PCOL)

LD	B,A

LD	A,0			;PSET

CALL	LINE

LD	SP,(STK)

RET



;----- work area -----



STK:	DS	2

DS	200

AREA:	$



END



=========================================================================



List 4.19 Example of the use of simple PAINT routine =========================================================================



1000 '***********************************************

1010 ' list 4.19 SRCH and LINE sample 1020 ' Operate cursor while holding down the space bar.

1030 '***********************************************

1040 '

1050 SCREEN 5

1060 FOR I=0 TO 50:LINE -(RND(1)*255,RND(1)*211),15:NEXT

1070 I=&HA000 :DEF USR=I

1080 READ A$

1090 IF A$="END" THEN 1130

1100 POKE I,VAL("&H"+A$):I=I+1

1110 READ A$

1120 GOTO 1090

1130 X=128:Y=100:COL=15:PCOL=2:ARG=0

1140 CURS=0

1150 A=STICK(0)

1160 CURS=(CURS+1) AND 1

1170 LINE (X-5,I)-(X+5,I),15,,XOR

1180 LINE (X,Y-5)-(X,Y+5),15,,XOR

1190 IF CURS=1 THEN 1290

1200 IF A=1 THEN Y=Y-1

1210 IF A=2 THEN Y=Y-1:X=X+1

1220 IF A=3 THEN X=X+1

1230 IF A=4 THEN X=X+1:Y=Y+1

1240 IF A=5 THEN Y=Y+1

1250 IF A=6 THEN Y=Y+1:X=X-1

1260 IF A=7 THEN X=X-1

1270 IF A=8 THEN X=X-1:Y=Y-1

1280 IF STRIG(9) THEN GOSUB 1300

1290 GOTO 1150

1300 POKE &HA800,Y

1310 POKE &HA801,X

1320 POKE &HA802,COL

1330 POKE &HA803,ARG

1340 POKE &HA804,PCOL

1350 A=USR(0)

1360 RETURN

1370 DATA ED,73,80,A8,31,4A,A9,2A,00,A8,3A,02

1380 DATA A8,5F,3A,03,A8,E5,D5,CB,D7,CD,AD

1390 DATA A0,D1,E1,C2,21,A0,3A,01,A8

1400 DATA 3D,3C,F5,3A,03,A8,CB,97,CD,AD,A0,C2

1410 DATA 32,A0,3A,01,AB,3C,3D,57,F1,67,3A 1420 DATA 00,A8,6F,5F,3A,04,A8,47,3E

1430 DATA 00,CD,49,A0,ED,7B,80,A8,C9,F3,F5,CD

1440 DATA 0D,A1,C5,3A,06,00,4F,0C,3E,24,ED

1450 DATA 79,3E,91,ED,79,0C,0C,AF,ED

1460 DATA 61,ED,79,ED,69,ED,79,7C,92,16,04,D2

1470 DATA 72,A0,16,00,ED,44,67,7D,93,1E,08

1480 DATA D2,7E,A0,1E,00,ED,44,BC,DA

1490 DATA 90,A0,ED,79,AF,ED,79,ED,61,ED,79,26

1500 DATA 01,C3,9C,A0,ED,61,67,AF,ED,79,ED

1510 DATA 61,ED,79,26,00,7C,B2,B3,E1

1520 DATA ED,61,ED,79,F1,E6,0F,F6,70,ED,79,FB

1530 DATA C9,F5,F3,CD,0D,A1,ED,4B,06,00,0C

1540 DATA 3E,A0,16,00,ED,61,ED,79,3C

1550 DATA ED,51,ED,79,3C,ED,69,ED,79,3C,ED,51

1560 DATA ED,79,3E,AC,ED,59,ED,79,3C,5F,F1

1570 DATA ED,79,ED,59,3E,60,ED,79,1C

1580 DATA ED,59,3E,02,CD,FD,A0,CB,47,C2,E2,A0

1590 DATA 5F,3E,08,CD,FD,A0,57,3E,00,CD,FD

1600 DATA A0,7A,CB,63,FB,C9,C5,ED,4B

1610 DATA 06,00,0C,ED,79,3E,8F,ED,79,ED,78,C1

1620 DATA C9,3E,02,CD,FD,A0,E6,01,C2,0D,A1

1630 DATA AF,CD,FD,A0,C9,END



=========================================================================



6.5.11 PSET (drawing a point)



A point is drawn at any coordinate in VRAM (see figure 4.99).



After setting the parameters as shown in Figure 4.100, writing 5XH (X means a logical operation) in R#46 causes the command to be executed. While the CE

bit of S#2 is "1", the command is being executed. List 4.20 shows an example of using PSET.



Figure 4.99	Actions of PSET command

VRAM or expansion RAM

---------------------------------------------------

|						 |

|						 |

|						 |

|						 |

|	 (DX,DY)				 |

|		 x				 |

|						 |

|						 |

|						 |

|						 |

|						 |

|						 |

---------------------------------------------------



MXD: memory selection			0 = VRAM, 1 = expansion RAM



DX: origin X-coordinate (0 to 511)

DY: origin Y-coordinate (0 to 1023)



CLR (R#44:Colour register): point colour

Figure 4.100 Register settings of PSET command

> PSET register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#36	| DX7| DX6| DX5| DX4| DX3| DX2| DX1| DX0|

|----+----+----+----+----+----+----+----| DX ---+

R#37	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | DX8|	|

-----------------------------------------	|

| origin

-----------------------------------------	|

R#38	| DY7| DY6| DY5| DY4| DY3| DY2| DY1| DY0|	|

|----+----+----+----+----+----+----+----| DY ---+

R#39	| 0 | 0 | 0 | 0 | 0 | 0 | DY9| DY8|

-----------------------------------------



-----------------------------------------		 --+

R#44	| 0 | 0 | 0 | 0 | CR3| CR2| CR1| CR0| CLR (GRAPHIC 4,6)	|

-----------------------------------------			|co-

|lour

-----------------------------------------			|

| 0 | 0 | 0 | 0 | 0 | 0 | CR1| CR0| CLR (GRAPHIC 5)	|code -----------------------------------------			|

|data

-----------------------------------------			|

| CR7| CR6| CR5| CR4| CR3| CR2| CR1| CR0| CLR (GRAPHIC 7)	|

-----------------------------------------		 --+



-----------------------------------------

R#45	| 0 | -- | MXD| -- | -- | -- | -- | -- | ARG (Argument register) -----------------------------------------

|

+-----------> memory selection

> PSET command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 0 | 1 | 0 | 1 | L03| L02| L01| L00| CMR

-----------------------------------------

|			|

+-------------------+

Logical operation

List 4.20 Example of PSET command execution =========================================================================



;****************************************************************

; List 4.20 PSET sample

;		 to use, set H, L, E, A as follows ;		 pset (x:H, y:L), color:E, logi-OP:A ;****************************************************************

;

PUBLIC	PSET



RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



PSET:	DI

PUSH	AF

CALL	WAIT.VDP

LD	BC,(WRVDP)



INC	C

LD	A,36

OUT	(C),A

LD	A,80H+17

OUT	(C),A



PUSH	BC

INC	C

INC	C

XOR	A

OUT	(C),H

OUT	(C),A

OUT	(C),L

OUT	(C),A

POP	BC



LD	A,44

OUT	(C),A

LD	A,80H+17

OUT	(C),A



INC	C

INC	C

OUT	(C),E

XOR	A

OUT	(C),A



LD	E,01010000B

POP	AF

OR	E

OUT	(C),A



EI

RET



GET.STATUS:

PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JP	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



6.5.12 POINT (reading a colour code)



POINT reads the colour code in any coordinate of VRAM (see Figure 4.101).



After setting the parameters as shown in Figure 4.102, writing 40H in R#46

causes the command to be executed. While the CE bit of S#2 is "1", the command is being executed. After the command terminates, the colour code of the specified coordinate is set in S#7. List 4.21 shows an example of using POINT.



Figure 4.101 Actions of POINT command

VRAM or expansion RAM

---------------------------------------------------

|						 |

|						 |

|						 |

|						 |

|	 (SX,SY)				 |

|		 x				 |

|						 |

|						 |

|						 |

|						 |

|						 |

|						 |

---------------------------------------------------



MXD: memory selection			0 = VRAM, 1 = expansion RAM



SX: origin X-coordinate (0 to 511)

SY: origin Y-coordinate (0 to 1023)



Figure 4.102 Register settings of POINT command

> POINT register setup



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#32	| SX7| SX6| SX5| SX4| SX3| SX2| SX1| SX0|

|----+----+----+----+----+----+----+----| SX ---+

R#33	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | SX8|	|

-----------------------------------------	|

| origin

-----------------------------------------	|

R#34	| SY7| SY6| SY5| SY4| SY3| SY2| SY1| SY0|	|

|----+----+----+----+----+----+----+----| SY ---+

R#35	| 0 | 0 | 0 | 0 | 0 | 0 | SY9| SY8|

-----------------------------------------



-----------------------------------------

R#45	| -- | -- | -- | MXS| -- | -- | -- | -- | ARG (Argument register) -----------------------------------------

|

+-----------> memory selection

> POINT command execution



MSB 7 6 5	 4 3 2	1 0	 LSB

-----------------------------------------

R#46	| 0 | 1 | 0 | 0 | -- | -- | -- | -- | CMR

-----------------------------------------



-----------------------------------------

S#2	| -- | -- | -- | -- | -- | -- | -- | CE | CMR

-----------------------------------------

when the command ends : 0



-----------------------------------------		 --+

S#7	| 0 | 0 | 0 | 0 | C3 | C2 | C1 | C0 | CL (GRAPHIC 4,6) |

-----------------------------------------		 |co-

|lour

-----------------------------------------		 |

| 0 | 0 | 0 | 0 | 0 | 0 | C1 | C0 | CL (GRAPHIC 5) |code -----------------------------------------		 |

|data

-----------------------------------------		 |

| C7 | C6 | C5 | C4 | C3 | C2 | C1 | C0 | CL (GRAPHIC 7) |

-----------------------------------------		 --+



List 4.21 Example of POINT command execution =========================================================================



;****************************************************************

; List 4.21 POINT sample

;		 to use, set H, L as follows

;		 POINT ( x:H, y:L )

;		 returns: A := COLOR CODE

;****************************************************************

;

PUBLIC	POINT



RDVDP:	EQU	0006H

WRVDP:	EQU	0007H



;----- program start -----



POINT:	DI

CALL	WAIT.VDP



LD	A,(WRVDP)

LD	C,A



INC	C

LD	A,32

OUT	(C),A

LD	A,80H+17

OUT	(C),A



INC	C

INC	C

XOR	A

OUT	(C),H

OUT	(C),A

OUT	(C),L

OUT	(C),A



DEC	C

DEC	C

OUT	(C),A

LD	A,80H+45

OUT	(C),A

LD	A,01000000B

OUT	(C),A

LD	A,80H+46

OUT	(C),A

CALL	WAIT.VDP

LD	A,7

CALL	GET.STATUS

PUSH	AF

XOR	A

CALL	GET.STATUS

POP	AF



EI

RET



GET.STATUS:

PUSH	BC

LD	BC,(WRVDP)

INC	C

OUT	(C),A

LD	A,8FH

OUT	(C),A

LD	BC,(RDVDP)

INC	C

IN	A,(C)

POP	BC

RET



WAIT.VDP:

LD	A,2

CALL	GET.STATUS

AND	1

JP	NZ,WAIT.VDP

XOR	A

CALL	GET.STATUS

RET



END



=========================================================================



List 4.22 PAINT routine using PSET and POINT

=========================================================================



;****************************************************************

; List 4.22 paint routine using PSET and POINT

;	ENTRY:	X:H, Y:L, BORDER COLOR:D, PAINT COLOR:E

;****************************************************************

;

EXTRN	PSET

EXTRN	POINT



Q.LENGTH	EQU	256*2*2

MAX.Y		EQU	211



;----- paint main routine -----



PAINT:	CALL	POINT

CP	D

RET	Z

CALL	INIT.Q

LD	(COL),DE

CALL	PUT.Q

LD	A,(COL)

LD	E,A

XOR	A			;logi-OP : PSET

CALL	PSET

PAINT0: CALL	GET.Q

RET	C

INC	H

CALL	NZ,PAINT.SUB

DEC	H

JP	Z,PAINT1

DEC	H

CALL	PAINT.SUB

INC	H

PAINT1: DEC	L

LD	A,-1

CP	L

CALL	NZ,PAINT.SUB

INC	L

INC	L

LD	A,MAX.Y

CP	L

CALL	NC,PAINT.SUB

JP	PAINT0



;----- check point and pset -----



PAINT.SUB:

CALL	POINT

LD	D,A

LD	A,(BORD)

CP	D

RET	Z

LD	A,(COL)

CP	D

RET	Z

LD	E,A

XOR	A

CALL	PSET

CALL	PUT.Q

RET



;----- init Q.BUFFER pointer -----



INIT.Q:

PUSH	HL

LD	HL,Q.BUF

LD	(Q.TOP),HL

LD	(Q.BTM),HL

POP	HL

RET



;----- put point to Q.BUF (X:H , Y:L) -----



PUT.Q:

EX	DE,HL

LD	HL,(Q.TOP)

LD	BC,Q.BUF+Q.LENGTH+1

OR	A			;clear CARRY

PUSH	HL

SBC	HL,BC

POP	HL

JP	C,PUT.Q1

LD	HL,Q.BUF

PUT.Q1:

LD	(HL),D

INC	HL

LD	(HL),E

INC	HL

LD	(Q.TOP),HL

EX	DE,HL

RET



;----- take point data to D, E -----

; returns: NC H:x, L:y

;		 C buffer empty



GET.Q:	LD	HL,(Q.BTM)

LD	BC,(Q.TOP)

OR	A

SBC	HL,BC

JP	NZ,GET.Q0

SCF

RET



GET.Q0: LD	HL,(Q.BTM)

LD	BC,Q.BUF+Q.LENGTH+1

OR	A

PUSH	HL

SBC	HL,BC

POP	HL

JP	C,GET.Q1

LD	HL,Q.BUF

GET.Q1: LD	D,(HL)

INC	HL

LD	E,(HL)

INC	HL

LD	(Q.BTM),HL

OR	A

EX	DE,HL

RET



;----- work area -----



COL	DS	1

BORD	DS	1

Q.TOP	DS	2

Q.BTM	DS	2

Q.BUF	DS	Q.LENGTH



END



=========================================================================



List 4.23 Example of using the PAINT routine =========================================================================



1000 '***********************************************

1010 ' list 4.23 paint routine using POINT and PSET

1020 ' Position cursor at beginnig of paint area and press the space bar.

1030 '***********************************************

1040 '

1050 SCREEN 5

1060 FOR I=0 TO 50

1070 LINE -(RND(1)*255,RND(1)*211),15

1080 NEXT

1090 I=&HA000 :DEF USR=I

1100 READ A$

1110 IF A$="END" THEN 1150

1120 POKE I,VAL("&H"+A$):I=I+1

1130 READ A$

1140 GOTO 1110

1150 X=128:Y=100:COL=15:PCOL=2

1160 CURS=0

1170 A=STICK(0)

1180 CURS=(CURS+1) AND 1

1190 LINE (X-5,I)-(X+5,I),15,,XOR

1200 LINE (X,Y-5)-(X,Y+5),15,,XOR

1210 IF CURS=1 THEN 1310

1220 IF A=1 THEN Y=Y-1

1230 IF A=2 THEN Y=Y-1:X=X+1

1240 IF A=3 THEN X=X+1

1250 IF A=4 THEN X=X+1:Y=Y+1

1260 IF A=5 THEN Y=Y+1

1270 IF A=6 THEN Y=Y+1:X=X-1

1280 IF A=7 THEN X=X-1

1290 IF A=8 THEN X=X-1:Y=Y-1

1300 IF STRIG(9) THEN GOSUB 1320

1310 GOTO 1170

1320 POKE &HA8CA,Y

1330 POKE &HA8CB,X

1340 POKE &HA8CD,COL

1350 POKE &HA8CC,PCOL

1360 A=USR(0)

1370 RETURN

1380 DATA ED,73,00,A8,31,CA,A8,2A,CA,A8,ED,5B,CC,A8,CD,67

1390 DATA A0,ED,7B,00,A8,C9,E5,21,D4,A8,22,D0,A8,22,D2,A8

1400 DATA E1,C9,EB,2A,D0,A8,01,D5,AC,B7,E5,ED,42,E1,DA,34

1410 DATA A0,21,D4,A8,72,23,73,23,22,D0,A8,EB,C9,2A,D2,A8

1420 DATA ED,4B,D0,A8,B7,ED,42,C2,4C,A0,37,C9,2A,D2,A8,01

1430 DATA D5,AC,B7,E5,ED,42,E1,DA,5D,A0,21,D4,A8,56,23,5E

1440 DATA 23,22,D2,A8,B7,EB,C9,CD,B8,A0,BA,C8,CD,16,A0,ED

1450 DATA 53,CE,A8,CD,22,A0,3A,CE,A8,5F,AF,CD,F4,A0,CD,3D

1460 DATA A0,D8,24,C4,A1,A0,25,CA,8F,A0,25,CD,A1,A0,24,2D

1470 DATA 3E,FF,BD,C4,A1,A0,2C,2C,3E,D3,BD,D4,A1,A0,C3,7E

1480 DATA A0,CD,B8,A0,57,3A,CF,A8,BA,C8,3A,CE,A8,BA,C8,5F

1490 DATA AF,CD,F4,A0,CD,22,A0,C9,F3,CD,3A,A1,ED,4B,06,00

1500 DATA 0C,3E,20,ED,79,3E,91,ED,79,0C,0C,AF,ED,61,ED,79

1510 DATA ED,69,ED,79,0D,0D,ED,79,3E,AD,ED,79,3E,40,ED,79

1520 DATA 3E,AE,ED,79,CD,3A,A1,3E,07,CD,2A,A1,F5,AF,CD,2A 1530 DATA A1,F1,FB,C9,F3,F5,CD,3A,A1,ED,4B,06,00,0C,3E,24

1540 DATA ED,79,3E,91,ED,79,C5,0C,0C,AF,ED,61,ED,79,ED,69

1550 DATA ED,79,C1,3E,2C,ED,79,3E,91,ED,79,0C,0C,ED,59,AF

1560 DATA ED,79,1E,50,F1,B3,ED,79,FB,C9,C5,ED,4B,06,00,0C

1570 DATA ED,79,3E,8F,ED,79,ED,78,C1,C9,3E,02,CD,2A,A1,E6

1580 DATA 01,C2,3A,A1,AF,CD,2A,A1,C9

1590 DATA END



=========================================================================





6.6 Speeding Up Commands




MSX-VIDEO performs various screen management duties in addition to executing the specified commands. Sometimes the command execution speed seems to be a bit slow because of this. Thus, by discarding these operations, the speed of the command executions can be made faster. This can be done using the following method.





1. Sprite display inhibition




This method is useful since speedup can be realised while the screen remains displayed. Set "1" to bit 1 of R#8.





2. Screen display inhibition




This method cannot be used frequently except in the case of initialising the screen, since the screen fades out in this mode. Set "1" to bit 6 of R#1.





6.7 Register Status at Command Termination




Table 4.7 shows the register status at the command termination for each command.



When the number of dots to be executed in Y direction assumes N, the values of SY*, DY*, and NYB can be calculated as follows:

SY*=SY+N, DY*=DY+N .................... when DIY bit is 0

SY*=SY-N, DY*=DY-N .................... when DIY bit is 1

NYB=NY-N



Note: when MAJ bit is 0 in LINE, N = N - 1.



Table 4.7 Register status at command termination

----------------------------------------------------------------------------

| command name | SX | SY | DX | DY | NX | NY | CLR |CMR H|CMR L| ARG |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|

| HMMC | --- | --- | --- | . | --- |	# | --- | 0 | --- | --- |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|

| YMMM | --- |	. | --- | . | --- |	# | --- | 0 | --- | --- |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|

| HMMM | --- |	. | --- | . | --- |	# | --- | 0 | --- | --- |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|

| HMMV | --- | --- | --- | . | --- |	# | --- | 0 | --- | --- |

----------------------------------------------------------------------------

----------------------------------------------------------------------------

| LMMC | --- | --- | --- | . | --- |	# | --- | 0 | --- | --- |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|

| LMCM | --- |	. | --- | --- | --- |	# | . | 0 | --- | --- |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|

| LMMM | --- |	. | --- | . | --- |	# | --- | 0 | --- | --- |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|

| LMMV | --- | --- | --- | . | --- |	# | --- | 0 | --- | --- |

----------------------------------------------------------------------------

----------------------------------------------------------------------------

| LINE | --- | --- | --- | . | --- | --- | --- | 0 | --- | --- |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|

| SRCH | --- | --- | --- | --- | --- | --- | --- | 0 | --- | --- |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|

| PSET | --- | --- | --- | --- | --- | --- | --- | 0 | --- | --- |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----|

| POINT | --- | --- | --- | --- | --- | --- | . | 0 | --- | --- |

----------------------------------------------------------------------------



--- :	no change

. :	coordinate (SY*, DY*) and the colour code at the command termination # :	the number of counts (NYB), when the screen edge is fetched





MSX2 TECHNICAL HANDBOOK

-----------------------



Edited by:		ASCII Systems Division

Published by:		ASCII Coprporation - JAPAN

First edition:		March 1987

<i>

Text file typed by:	Nestor Soriano (Konami Man) - SPAIN

October 1997



Changes from the original:



- In Figure 5.2, unused bits are marked as "x", and inverted signals are marked with "*", for easiest readability.



- Figure 5.17B was added.



- In List 5.4, the last line before the work area, "JR START", has been corrected to "JR SCAN".



- In Figure 5.18, the addresses for GETPNT y PUTPNT were swapped. They have been corrected.



- In description of BIOS routines PINLIN and INLIN, "BUF" address has been corrected from F55DH to F55EH.



- In Figure 5.22 (B), "Arabaic mode display" has been changed to "Arabic or kana mode display".



- In description of BIOS routine GTTRIG, the input needed for reading B

buttons has been added in the "Input" field.



- In Table 5.5, in the Note 4, "the trigger button of the mouse or the trigger button" has been changed to "the trigger button of the mouse or the trigger button of the track ball".



- In Figure 5.29, "1200 or 2400 hours" indication has been corrected to "12

or 24 hours".



- In Figure 5.32, "Register 3 #11" indication has been corrected to "Register #11".



- In Figure 5.33, "Adjust Y (8 to +7)" has been corrected to "Adjust Y (-8 to +7)".



- In description of BIOS routine WRTCLK, the input needed in the A register has been added in the "Input" field.

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



CHAPTER 5 - ACCESS TO PERIPHERALS THROUGH BIOS (Parts 1 to 6)

The basic philosophy of MSX is to have a standard interface, independent of machines or versions, to access peripherals through BIOS. Thus, the user should get to know about using BIOS first. In chapter 5, accessing peripherals using BIOS and the structure used for each peripheral are described.





1. PSG AND SOUND OUTPUT




MSX has the following three kinds of sound output functions, but function (3) is not installed in the standard MSX, so it is not described in this manual.

This section describes functions (1) and (2).



(1) PSG sound output (3 channels, 8 octaves)

(2) Sound output by 1 bit I/O port



(3) Sound output by MSX-AUDIO (FM sound generator) ........ not described in this manual



1.1. PSG functions



An AY-3-8910 compatible LSI is used for the MSX music play function and for BEEP tone generation. This LSI is referred to as the PSG (Programmable Sound Generator), and can generate complex music and varios tones. It has the following features:



* There are three tone generators, each of which can independently specify 4096 scales (equivalent to 8 octaves) and 16 volume levels.



* It can generate piano and organ tones by using envelope patterns. Note that, since there is only one envelope generator, the tone of only one channel can be modified fundamentally.



* With the noise generator inside, tones such as the wind or waves can easily be generated. Note that since there is only one noise generator, only one channel can generate the noise.



* Any necessary frequency, such as the tone or the envelope, is obtained by dividing the input clock (in MSX, it is defined that fc = 1.7897725 MHz). So there is no unsteady pitch or rythm.



Figure 5.1 PSG block diagram

R0, R1 		 R7			R8

--------------------	 -------------	 ------------------------------

| Tone generator A | --> |	 | ------> | Volume control amplifier A |

--------------------	 |	 |	 +--> ---------------------------+--

|	 |	 |	 Channel A output <--+

R2, R3 		 | Three |	 |	R9

--------------------	 |	 |	 | ------------------------------

| Tone generator B | --> | Channel | ---:--> | Volume control amplifier B |

--------------------	 |	 |	 +--> ---------------------------+--

| Mixer |	 |	 Channel B output <--+

R4, R5 		 |	 |	 |	R9

--------------------	 |	 |	 | ------------------------------

| Tone generator C | --> |	 | ---:--> | Volume control amplifier C |

--------------------	 -------------	 +--> ---------------------------+--

^	 |	 Channel C output <--+

|	 |

R6		 |	 | R11, R12, R13

---------------------	 ------------------------

| Noise generator |	 | Envelope generator	|

---------------------	 ------------------------



The PSG has two additional I/O (input/output) ports used for other than tone generating functions, which are omitted in the block diagram above. MSX uses them as general-purpose I/O ports to connect to I/O devices such as joystick, a touch pad, a paddle, or a mouse. These general-purpose I/O ports are described in section 5.



* PSG registers



Since the PSG generates tones, the CPU simply notifies PSG when the tone is to be changed. This is done by writing values in 16 8-bit registers inside the PSG as shown in Figure 5.2.



Roles and uses of these registers are described below.



* Setting the tone frequency (R0 to R5)

Each tone frequency of channel A, B, and C is set by R0 to R5. The input clock frequency (fc = 1.7897725 MHz) is divided by 16 and the result is the standard frequency. Each channel divides the standard frequency by the 12-bit data assigned for each, and the objective pitch is obtained. The following relation exists between 12-bit data (TP) and the tone frequency to be generated (ft).



ft = fc/(16 * TP) = 0.11186078125/TP [MHz]

= 111860.78125/TP [Hz]



A 12-bit data TP is specified for each channel by 4 high order bit coarse tune CT and 8 low order bit fine tune value FT, as shown in Figure 5.3. Table 5.1 shows the register settings to make the scales.



Figure 5.2 PSG register structure

-----------------------------------------------------------------------------

|			Bit |	 |	| | |	 |	| | |

|			 | B7 | B6	| B5 | B4 | B3 | B2	| B1 | B0 |

| Register		 |	 |	| | |	 |	| | |

|---------------------------+-----------------------------------------------|

| R0 | Channel A note |		 8 low order bits		 |

|----------|		 |-----------------------------------------------|

| R1 | Dividing rate | x x	 x	 x |	4 high order bits |

|----------+----------------+-----------------------------------------------|

| R2 | Channel B note |		 8 low order bits		 |

|----------|		 |-----------------------------------------------|

| R3 | Dividing rate | x x	 x	 x |	4 high order bits |

|----------+----------------+-----------------------------------------------|

| R4 | Channel C note |		 8 low order bits		 |

|----------|		 |-----------------------------------------------|

| R5 | Dividing rate | x x	 x	 x |	4 high order bits |

|----------+----------------+-----------------------------------------------|

| R6 | Noise div. rate| x x	 x | 			 |

|----------+----------------+-----------------------------------------------|

|	 |		 | IN*/OUT	| NOISE*	 |	 TONE*	 |

| R7 | Enable*	 |-----------+-----------------+-----------------|

|	 |		 | IOB | IOA | C | B | A | C	| B | A |

|----------+----------------+-----------------+-----+-----------------------|

| R8 | Chan. A volume | x x	 x | M |			 |

|----------+----------------+-----------------+-----+-----------------------|

| R9 | Chan. B volume | x x	 x | M |			 |

|----------+----------------+-----------------+-----+-----------------------|

| R10 | Chan. C volume | x x	 x | M |			 |

|----------+----------------+-----------------------------------------------|

| R11 |		 |		 8 low order bits		 |

|----------| Envelope Cycle |-----------------------------------------------|

| R12 |		 |		 8 high order bits		 |

|----------+----------------+-----------------------------------------------|

| R13 | Env. wave shape| x x	 x	 x |			 |

|----------+----------------+-----------------------------------------------|

| R14 | I/O port A |						 |

|----------+----------------+-----------------------------------------------|

| R15 | I/O port B |						 |

-----------------------------------------------------------------------------



NOTE:	x = unused bit

* = inverted signal

Figure 5.3 Setting the pitch

-------------------------------------------------

R0, R2, R4	|		 8	bits			| --+

------------------------------------------------- |

------------------------------------------------- |

R0, R2, R4	| x	 x x x	|	 4 bits 	| |

------------------------------------------------- |

|		 |

----------------------------------------+		 |

|							 |

V							 V

-----------------------------------------------------------------------

| Coarse Tune (CT)	|		 Fine Tune (FT) 	 |

-----------------------------------------------------------------------

|								 |

+-------------------------------- TP ---------------------------------+



[ Channel A - R0, R1 ]

[ Channel B - R2, R3 ]

[ Channel C - R4, R5 ]



Table 5.1 Setting the tone frequency (scale data)

----------------------------------------------------------------

|	Octave | |	 |	 | | |	 |	 | |

|	 | 1 |	2 | 3 | 4 | 5 |	6 | 7 | 8 |

| Note	 | |	 |	 | | |	 |	 | |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| C | D5D | 6AF | 357 | 1AC | D6 |	6B | 35 | 1B |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| C# | C9C | 64E | 327 | 194 | CA |	65 | 32 | 19 |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| D | BE7 | 5F4 | 2FA | 17D | BE |	5F | 30 | 18 |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| D# | B3C | 59E | 2CF | 168 | 84 |	5A | 2D | 16 |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| E | A9B | 54E | 2A7 | 153 | AA |	55 | 2A | 15 |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| F | A02 | 501 | 281 | 140 | A0 |	50 | 28 | 14 |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| F# | 973 | 4BA | 25D | 12E | 97 |	4C | 26 | 13 |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| G | 8EB | 476 | 23B | 11D | 8F |	47 | 24 | 12 |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| G# | 88B | 436 | 21B | 10D | 87 |	43 | 22 | 11 |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| A | 7F2 | 3F9 | 1FD | FE | 7F |	40 | 20 | 10 |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| A# | 780 | 3C0 | 1E0 | F0 | 78 |	3C | 1E | F |

|--------------+-----+-----+-----+-----+-----+-----+-----+-----|

| B | 714 | 38A | 1C5 | E3 | 71 |	39 | 1C | E |

----------------------------------------------------------------



* Setting the noise frequency (R6)



The noise generator is used for synthesizing explosion sounds or wave sounds.

The PSG can send the noise output by the noise generator to channels A to C.

Since there is only one noise generator, the same noise is sent to all channels. By changing the average frequency, various noise effects can be obtained and this is done by R6 register settings. The 5 low order bit data (NP) of this register is divides into the standard frequency (fc/16) and this determines the average frequency of the noise (fn).



Figure 5.4 Setting the noise frequency

-------------------------------------------------

R6 | x x x	|			 |

-------------------------------------------------

|			 |

+------------- NP ------------+



The following relation exists between NP and fn.



fn = fc/(16 * NP) = 0.11186078125/NP [MHz]

= 111860.78125/NP [Hz]



Since the value of NP is from 1 to 31, the average frequency of the noise can be set from 3.6kHz to 111.9kHz.



* Mixing the sound (R7)



R7 is used to select the output of the tone and noise generator, or a mixture of both. As shown in Figure 5.5, the 3 low order bits (B0 to B2) of R7

control the tone output and the next 3 bits (B3 to B5) control the noise output. In both cases, when the corresponding bit is 0, the output is ON and, when 1, it is OFF.



Figure 5.5 Output selection for each channel

-------------------------------------------------

R7 | B7 | B6 | B5	| B4 | B3 | B2 | B1	| B0 |

-------------------------------------------------

|

|

V



B7	 B6		 B5	 B4	 B3		B2	B1	B0

----------------- ------------------------- -------------------------

| Input enable* | | Noise enable* | |	 Tone enable*	 |

|---------------| |-----------------------| |-----------------------|

| B	| A	| | C | B | A | |	C |	B |	A |

----------------- ------------------------- -------------------------

I/O port	 Noise output		 Tone output

Input - 0		 ON - 0 		 ON - 0

Output - 1		 OFF - 1		 OFF - 1



The 2 high order bits of R7 do not affect sound output. These are used to determine the direction of the data of two I/O ports which PSG has. When the corresponding bit is 0, the input mode is selected and, when 0, the output mode is selected. In MSX, port A is used for the input and port B for the output, so it should always be set so that bit 6 = "0" and bit 7 = "1".



* Setting the volume (R8 to R10)



R8 to R10 are used to specify the volume of each channel. Two ways can be selected by these registers: specifying the fixed volume by 4-bit data (0 to 15) and generating sound effects such as vibrato or fade-out by using the envelope.



Figure 5.6 Setting the volume

-------------------------------------------------

R8, R9, R10 | x	x x | B4 | B3 | B2 | B1 | B0 |

-------------------------------------------------

| |		 |

| +---------- L ----------+

|

V

Use envelope:

No	- 0 (set volume by the value of L) Yes - 1 (ignore the value of L)

When bit 4 of these registers is "0", the envelope is not used and the 4 low order bit value L (0 to 15) of the registers specify the volume. When bit 4

is "1", the volume depends on the envelope signals and the value L is ignored.



* Setting the envelope cycle (R11, R12)

R11 and R12 specify the envelope cycle in 16-bit data. The 8 high order bits are set in R12 and the 8 low order bits are set in R11.



Figure 5.7 Setting the envelope cycle

-------------------------------------------------

R11	 |						 | --+

------------------------------------------------- |

------------------------------------------------- |

R12	 |						 | |

------------------------------------------------- |

|	 |

---------------------------------+	 |

| 					 |

V 					 V

-----------------------------------------------------------------------------

|	 Coarse Tune (CT)	 |		 Fine Tune (FT)	 |

-----------------------------------------------------------------------------

|									 |

+----------------------------------- EP ------------------------------------+



The following relation exists between the envelope cycle T and 16-bit data EP.



T = (256 * EP) / fc = (256 * EP) / 1.787725 [MHz]

= 143.03493 * EP [micro second]



* Setting the envelope pattern (R13)



R13 sets the envelope pattern by the 4 low order bit data as shown in Figure 5.8. The intervals of T specified in the figure correspond to the envelope cycle specified by R11 and R12.



Figure 5.8 Setting the wave forms of the envelopes

-------------------------------------------------

R13	 | x x	 x	 x | B3 | B2	| B1 | B0 |

-------------------------------------------------

|

------------------------------------+

|

V

---------------------------------------------------------

|		 | :\				|

| 0	 0 x x | __: \______________________	|

|		 |				|

|		 | /:			|

| 0	 1 x x | __/ :______________________	|

|		 |				|

|		 | :\	:\ :\	:\ :\	:\ :\	|

| 1	 0 0 0 | __: \: \: \: \: \: \:_	|

|		 |				|

|		 | :\				|

| 1	 0 0 1 | __: \______________________	|

|		 |				|

|		 | :\	 / \	 / \	 / \	|

| 1	 0 1 0 | __: \ / \ / \ /	|

|		 |	 _____________________	|

|		 | :\	:			|

| 1	 0 1 1 | __: \:			|

|		 |				|

|		 | /: /: /: /: /: /:	|

| 1	 1 0 0 | __/ :/ :/ :/ :/ :/ :/	|

|		 |	______________________	|

|		 | / 			|

| 1	 1 0 1 | __/				|

|		 |				|

|		 | / \ / \ / \	|

| 1	 1 1 0 | __/	 \ /	 \ /	 \ /	|

|		 |				|

|		 | /:			|

| 1	 1 1 1 | __/ :______________________	|

|		 |				|

---------------------------------------------------------

| |

+---+

T



* I/O port (R14, R15)



R14 and R15 are the ports to send and receive 8-bit data in parallel. MSX

uses these as the general-purpose I/O interface. For more information, see section 5.





1.2 Access to the PSG




For access the PSG from assembly language programs, several BIOS routines described below are available.



* GICINI (0090H/MAIN) .................. PSG initialization

Input:		---

Output: 	---

Function:	initializes PSG registers and does the initial settings of the work area in which PLAY statement of BASIC is executed.

Each register of PSG is set to the value as shown in Figure 5.9.



Figure 5.9 Initial values of PSG registers

-----------------------------------------------------------------------------

|			Bit |	 |	| | |	 |	| | |

|			 | 7 | 6	| 5 | 4 | 3 | 2	| 1 | 0 |

| Register		 |	 |	| | |	 |	| | |

|---------------------------+-----------------------------------------------|

| R0 | Channel A	 | 0 1	 0	 1 0 1	 0	 1 |

|----------|		 |-----------------------------------------------|

| R1 | frequency	 | 0 0	 0	 0 0 0	 0	 0 |

|----------+----------------+-----------------------------------------------|

| R2 | Channel B	 | 0 0	 0	 0 0 0	 0	 0 |

|----------|		 |-----------------------------------------------|

| R3 | frequency	 | 0 0	 0	 0 0 0	 0	 0 |

|----------+----------------+-----------------------------------------------|

| R4 | Channel C	 | 0 0	 0	 0 0 0	 0	 0 |

|----------|		 |-----------------------------------------------|

| R5 | frequency	 | 0 0	 0	 0 0 0	 0	 0 |

|----------+----------------+-----------------------------------------------|

| R6 | Noise frequency| 0 0	 0	 0 0 0	 0	 0 |

|----------+----------------+-----------------------------------------------|

| R7 | Channel setting| 1 0	 1	 1 1 0	 0	 0 |

|----------+----------------+-----------------------------------------------|

| R8 | Chan. A volume | 0 0	 0	 0 0 0	 0	 0 |

|----------+----------------+-----------------------------------------------|

| R9 | Chan. B volume | 0 0	 0	 0 0 0	 0	 0 |

|----------+----------------+-----------------------------------------------|

| R10 | Chan. C volume | 0 0	 0	 0 0 0	 0	 0 |

|----------+----------------+-----------------------------------------------|

| R11 |		 | 0 0	 0	 0 1 0	 1	 1 |

|----------| Envelope Cycle |-----------------------------------------------|

| R12 |		 | 0 0	 0	 0 0 0	 0	 0 |

|----------+----------------+-----------------------------------------------|

| R13 | Env. pattern | 0 0	 0	 0 0 0	 0	 0 |

|----------+----------------+-----------------------------------------------|

| R14 | I/O port A |						 |

|----------+----------------+-----------------------------------------------|

| R15 | I/O port B |						 |

-----------------------------------------------------------------------------



* WRTPSG (0093H/MAIN) ................. writing data in PSG registers

Input:		A <-- PSG register number

E <-- data to be written Output: 	---

Function:	writes the contents of the E register in the PSG register whose number is specified by the A register.



* RDPSG (0096H/MAIN) .................. reading PSG register data

Input:		A <-- PSG register number

Output: 	A <-- contents of the specified register Function:	reads the contents of PSG register whose number is specified by the A register and stores the value in the A register.



* STRTMS (0099H/MAIN) ................. starting the music

Input:		(QUEUE) <-- MML which is translated into the intermediate language

Output: 	---

Function:	examines whether the music is played as the background task, and plays the music which is set in the queue, if the music has not yet been played.



List 5.1 Single tone generation

=================================================================



;************************************************

;

; List 5.1 440 Hz tone

;

;************************************************

;

WRTPSG	EQU	0093H



ORG	0B000H



;----- program start -----



LD	A,7		;Select Channel LD	E,00111110B	;Channel A Tone := On CALL	WRTPSG



LD	A,8		;Set Volume LD	E,10

CALL	WRTPSG



LD	A,0		;Set Fine Tune Channel A LD	E,0FEH		;Data 0FEH

CALL	WRTPSG



LD	A,1		;Set Coarse Tune Channel A LD	E,0		;Data 0H

CALL	WRTPSG



RET



END



=================================================================





1.3 Tone Generation by 1-bit Sound Port




MSX has another sound generator in addition to the PSG. This is a simple one that generates sound by turning ON/OFF the 1-bit I/O port output repeatedly using software.



Figure 5.10	1-bit sound port

bit 7 6	 5 4 3	2 1	 0

-----------------------------------------

| . | | |	 | | |	| |

--+--------------------------------------

| PPI port C (I/O address 0AAH) |

|

::::::::::::	 V

: PSG :	 ---------

: output :::::::>| MIX |

::::::::::::	 ---------

|

V

-----

/	 \ Speaker

---------

/ : \





1.4 Access to 1-bit Sound Port




To access to the 1-bit sound port, the following BIOS routine is offered.



* CHGSND (0135H/MAIN)



Input:		A <-- specification of ON/OFF (0 = OFF, others = ON) Output:

Function:	calling this routine with setting 0 in the A register turns the bit of the sound port OFF; calling it with another value turns it ON.



List 5.2 Reading from cassette tape

=================================================================



;********************************************************

;

; List 5.2 Read from cassette tape

;

;	 Set music tape into tape-recorder

;	 and run this program.

;	 Then your MSX will replay it.

;

;********************************************************

;

CHGSNG	EQU	0135H

STMOTR	EQU	00F3H

RDPSG	EQU	0096H

BREAKX	EQU	00B7H



ORG	0B000H



;----- program start -----	Note: Play tape using 1-bit sound port.



START:	LD	A,1		;motor on

CALL	STMOTR



LBL01:	LD	A,14		;register 14

CALL	RDPSG		;read PSG



AND	80H		;check CSAR

CALL	CHGSNG		;change SOUND PORT



CALL	BREAKX		;check Ctrl-STOP

JR	NC,LBL01



XOR	A		;stop cassette motor CALL	STMOTR

RET



END



=================================================================





2. CASSETTE INTERFACE




Cassette tape recorders are the least expensive external storage devices available for the MSX. Knowledge of the cassette interface is required to treat information in cassette tapes within assembly language programs. This section offers the necessary information.





2.1 Baud Rate




The following two baud rates can be used by the MSX cassette interface (see Table 5.2). When BASIC is invoked, 1200bps is set by default.



Table 5.2 MSX baud rate

------------------------------------------------

| Baud rate | Characteristics	 |

|-------------+--------------------------------|

| 1200 bps | Low speed / high reliability |

|-------------+--------------------------------|

| 2400 bps | High speed / low reliability |

------------------------------------------------



The baud rate is specified by the fourth parameter of the SCREEN instruction or the second parameter of the CSAVE instruction. Once the baud rate is set, it stays at that value.



SCREEN		,,,<baud rate>

CSAVE		"filename",<baud rate>

(<baud rate> is 1 for 1200bps, 2 for 2400 bps)





2.2 One bit composition




One bit data, the basis of I/O, is recorded as shown in Figure 5.11. The pulse width is determined by counting the T-STATE of the CPU, so, while the cassette interface is active, any interrupt is inhibited.



The bit data from the cassette can be read through the seventh bit of port B

of the general-purpose I/O interface (register 15 of the PSG). This function was used in the program example of List 5.3, section 1 of chapter 5.



Figure 5.11	One bit composition

--------------------------------------------------------------

| Baud rate | Bit |		 Wave form		 |

|-----------+-------+----------------------------------------|

|	 |	 | :	 -----------		 |

|	 |	0 | :	 |	 | (1200Hz x 1) |

| 1200 |	 | :_________|	 |		 |

|	 |-------+--:-------------------------------------|

| baud |	 | : ------ ------		 |

|	 |	1 | : |	 | | | (2400Hz x 2) |

|	 |	 | :____|	 |____| |		 |

|-----------+-------+--:-------------------------------------|

|	 |	 | : ------	 :		 |

|	 |	0 | : |	 |	 : (2400Hz x 1) |

| 2400 |	 | :____|	 |	 :		 |

|	 |-------+--:-------------------:-----------------|

| baud |	 | : --- ---	 :		 |

|	 |	1 | : | | | |	 : (4800Hz x 2) |

|	 |	 | :__| |__| |	 :		 |

-----------------------:--:-:----:---------:------------------

| : :	 :	 | 2963 T-states (833 micro-sec) +--:-:----:---------+

| : :	 | 1491 T-states (417 micro-sec) +--:-:----+

| : | 746 T-states (208 micro-sec) +--:-+

| | 373 T-states (104 micro-sec) +--+





2.3 One byte composition




One byte data is recorded in the array of bits as shown in Figure 5.12. There is one "0" bit as the start bit, followed by the 8-bit data body from LSB to MSX and by two "1" bit as the stop bits, so 11 bits are used.



Figure 5.12	One byte composition

LSB				 MSB

-------------------------------------------------------------------------

|	0 | X | X | X |	X | X | X | X |	X | 1 : 1 |

-------------------------------------------------------------------------

|	 |						 |	 |

+-----+-----------------------------------------------+-----------+

Start bit			 Data			 Stop bit





2.4 Header Composition




The header is the portion where the signal of the specific frequency is recorded on the tape for a certain period. This allows the cassette tape speed to stabilize after it is started, or divides two files. There is a long header and a short header. The long header is used to wait until the motor is stabilized. The baud rate at reading the tape is determined by reading the long header. The short header is used to divide file bodies.

Table 5.3 shows the compositions of both.



Table 5.3 Header composition

------------------------------------------------------------------

| Baud rate | Header |	 Header composition	 |

|-------------+--------------+-----------------------------------|

|	 | Long header |	2400 Hz x 16000 (about 6.7 sec) |

| 1200 baud |--------------+-----------------------------------|

|	 | Short header |	2400 Hz x 4000 (about 1.7 sec) |

|-------------+--------------+-----------------------------------|

|	 | Long header |	4800 Hz x 32000 (about 6.7 sec) |

| 2400 baud |--------------+-----------------------------------|

|	 | Short header |	4800 Hz x 8000 (about 1.7 sec) |

------------------------------------------------------------------





2.5 File Formats




MSX BASIC supports the following three kinds of cassette format files.



(1) BASIC text file



BASIC programs saved with the CSAVE command are recorded in this format. The file is divided into the preceding file header and the succeeding the body.



Figure 5.13	Binary file format





6.7 sec		 10 bytes		 6 bytes


-------------------------------------------------------------------------


|		 |				 |		 |

|	Long header |		0D3H x 10	 |	 File name |

|		 |				 |		 |

-------------------------------------------------------------------------

|								 |

+----------+		 +------------------------------------+

|		 |

-----------------------------------------------------------------------------

|		| File header | |	 File body 	|	 |

-----------------------------------------------------------------------------

|				|

+-------------------------------+			 ------+

|								 |

-------------------------------------\ \--------------------------------

|	Short	|		 / /	 |		 |

|	header	| BASIC program \ \	 |	 00H x 7 |

|		|		 / /	 |		 |

-------------------------------------\ \--------------------------------





1.7 sec		 Any length			 7 bytes




In the file header, ten bytes each of the value 0D3H follow after the long header and six bytes containing the file name are placed after them. In the file body, program body follows the short header and the end of the file is indicated by seven bytes of 00H.



(2) ASCII text file



BASIC programs saved in ASCII format by the SAVE command and data files created by the OPEN command are recorded in this format.



Figure 5.14	ASCII file format





6.7 sec		 10 bytes		 6 bytes


-------------------------------------------------------------------------


|		 |				 |		 |

|	Long header |		0EAH x 10	 |	 File name |

|		 |				 |		 |

-------------------------------------------------------------------------

|								 |

+----------+		 +------------------------------------+

|		 |

-----------------------------------------------------------------------------

|		| File header | |	 File body 	|	 |

-----------------------------------------------------------------------------

|				|

+-------------------------------+			 ------+

|								 |

-----------------------------------------------\ \----------------------

|		 |	 |		 |	 / /	 | Last |

|	Block 1 | Block 2 |	Block 3 | ..... \ \ .... | block |

|		 |	 |		 |	 / /	 |	 . |

-----------------------------------------------\ \------------+---------

|	 |					 |

+-----------+	 +-----------+		 CTRL+Z (EOF) |					 |		is included in data ------------------------------------------------

|	Short	|			 |

|	header	|	 Data 	 | .....

|		|			 |

------------------------------------------------





1.7 sec 	256 bytes




(3) Machine code file



Machine code files saved by the BSAVE command are recorded in the following format. In the file header, 10 bytes each of the value 0D0H follow after the long header and 6 bytes containing the file name are placed after them.



In the file body, the starting address, the end address, and the entry address are recorded in order after the short header, and the machine codes follow after them. Since the amount of data can be calculated from the starting and ending addresses, there is no special mark for the end of the file. The entry address is the address where the program is executed when the R option of the BLOAD command is used.



Figure 5.15	Machine code file format





6.7 sec		 10 bytes		 6 bytes


-------------------------------------------------------------------------


|		 |				 |		 |

|	Long header |		0D0H x 10	 |	 File name |

|		 |				 |		 |

-------------------------------------------------------------------------

|								 |

+----------+		 +------------------------------------+

|		 |

-----------------------------------------------------------------------------

|		| File header | |	 File body 	|	 |

-----------------------------------------------------------------------------

|				|

+-------------------------------+			 ------+

|								 |

-------------------------------------------------------------------------

|	Short	| Top | End | Starting |		 |

|	header	| address | address | address | Program body |

|		|	 |	 | 	 |		 |

-------------------------------------------------------------------------

1.7 sec	 2 bytes 2 bytes	2 bytes





2.6 Access to cassette files




The following BIOS routines are offered to access cassette files.



* TAPION (00E1H/MAIN) ................. OPEN for read

Input:		---

Output: 	CY flag = ON at abnormal terminations Function:	starts the motor of the tape recorder and reads the long header or the short headet. At the same time, the baud rate in which the file is recorded is detected and the work area is set according to it. Interrupts are inhibited.



* TAPIN (00E4H/MAIN) .................. read one byte

Input:		---

Output: 	A <-- data which has been read CY flag = ON at abnormal terminations Function:	reads one byte of data from the tape and stores it in the A register.



* TAPIOF (00E7H/MAIN) ................. CLOSE for read

Input:		---

Output: 	---

Function:	ends reading from the tape. At this point, interrupts are allowed.



* TAPOON (00EAH/MAIN) ................. OPEN for write

Input:		A <-- type of header (0 = short header, others = long header) Output: 	CY flag = ON at abnormal terminations Function:	starts the motor of the tape recorder and writes the header of the type specified in the A register to the tape.

Interrupts are inhibited.



* TAPOUT (00EDH/MAIN) ................. write one byte

Input:		A <-- data to be written

Output: 	CY flag = ON at abnormal terminations Function:	writes the contents of the A register to the tape.



* TAPOOF (00F0H/MAIN) ................. CLOSE writing

Input:		---

Output: 	---

Function:	ends writing the tape. At this point, interrupts are allowed.



* STMOTR (00F3/MAIN) .................. specify the actions of the motor

Input:		A <-- action (0 = stop, 1 = start, 255 = reverse the current status)

Output: 	---

Function:	sets the status of the motor according to the value specified in the A register.



When READ/WRITE routines for the cassette files are created using these BIOS

calls, only READ or WRITE, without any other action, should be done. For example, reading data from the tape and displaying it on the CRT might cause a READ error.



List 5.3 is a sample program which uses BIOS routines.



List 5.3 Listing names of files saved in the cassette =========================================================================



;************************************************************

;

; List 5.3	 Cassette files

;

;	Set cassette tape into recorder and run this program.

;	Then all the names and attributes of the programs ;	in that tape will be listed.

;

;************************************************************

;

CHPUT	EQU	00A2H

TAPION	EQU	00E1H

TAPIN	EQU	00E4H

TAPIOF	EQU	00E7H



ORG	0C000H



;----- program start -----	Note: View program names on cassette tape.



START:	CALL	TAPION		;motor on and read header

LD	B,16

LD	HL,WORK 	;work area address LBL01:	PUSH	HL

PUSH	BC

CALL	TAPIN		;read a byte of data from tape POP	BC

POP	HL

JR	C,ERROR 	;set carry flag if read error LD	(HL),A

INC	HL

DJNZ	LBL01



LD	HL,FILNAM	;write file name CALL	PUTSTR

LD	HL,WORK+10

CALL	PUTSTR

CALL	CRLF



LD	A,(WORK)	;check file attributes

LD	HL,BINFIL

CP	0D3H		;check binary file JR	Z,LBL03



LD	HL,ASCFIL

CP	0EAH		;check ascii file JR	Z,LBL03



LD	HL,MACFIL

CP	0D0H		;check machine code file JR	Z,LBL03



ERROR:	LD	HL,ERRSTR



LBL03:	CALL	PUTSTR

CALL	TAPIOF

RET



;----- put CRLF -----



CRLF:	LD	HL,STCRLF

CALL	PUTSTR

RET



;----- put string -----



PUTSTR: LD	A,(HL)		;get a character from strings CP	'$' ;check end of strings RET	Z

CALL	CHPUT		;write a character to CRT

INC	HL

JR	PUTSTR



;----- strings data -----



FILNAM: DB	'FILE NAME :$'

ASCFIL: DB	'ASCII FILE',0DH,0AH,'$'

BINFIL: DB	'BINARY FILE',0DH,0Ah,'$'

MACFIL: DB	'BSAVE FILE',0DH,0AH,'$'

ERRSTR: DB	'TAPE READ ERROR',0DH,0AH,'$'

STCRLF: DB	0DH,0AH,'$'



;----- WORK AREA -----



WORK:	DS	16,0

DB	'$' ;end of strings

END



=========================================================================





3. KEYBOARD INTERFACE




Altough the MSX2 keyboard has the same design as that of the MSX1, it is more convenient to use because of the Romand-to-kana translation available for kana input. This chapter describes the keyboard interface of the MSX2.



Descriptions of the key aarangement are based on the Japanese keyboard standard; note that data is slightly different for the international MSX

versions.





3.1 Key Scanning




MSX uses the key matrices as shown in Figure 5.16, Figure 5.17 and Figure 5.17B. The key status can be obtained in real time by examining this key matrix and is available for reading input.



Scanning the key matrix is done by the following BIOS routine.



* SNSMAT (0141H/MAIN) ................. reads the specified line of the key matrix



Input:		A <-- key matrix line to be read (0 to 10) Output: 	A <-- status of the specified line of the key matrix (when pressed, the bit of the key is 0) Function:	specifies a line of the key matrix shown in Figure 5.16, Figure 5.17 or Figure 5.17B and stores its status in the A register. The bit corresponding with the key being pressed is "0", and "1" for the key not being pressed.



Figure 5.16	MSX USA version key matrix

MSB								 LSB

7	6	5	4	3	2	1	0

-----------------------------------------------------------------

0 |	B |	L |	 |	/ |	1 |	S |	X |	, |

|-------+-------+-------+-------+-------+-------+-------+-------|

1 |	V |	J |	= |	` |	Q |	A |	C |	N |

|-------+-------+-------+-------+-------+-------+-------+-------|

2 |	G |	8 |	0 |	] |	W |	F |	Z |	M |

|-------+-------+-------+-------+-------+-------+-------+-------|

3 |	T |	I |	~ |	; |	2 |	D |	U |	\ |

|-------+-------+-------+-------+-------+-------+-------+-------|

4 |	6 |	K |	P |	' | 3 | R | 7 | H |

|-------+-------+-------+-------+-------+-------+-------+-------|

5 |	5 |	0 |	9 |	[ |	4 |	E |	Y |	. |

|-------+-------+-------+-------+-------+-------+-------+-------|

6 |	F3 |	F2 |	F1 | CODE | CAPS | GRAPH | CTRL | SHIFT |

|-------+-------+-------+-------+-------+-------+-------+-------|

7 | RETURN| SELECT|	BS | STOP | TAB | ESC |	F5 |	F4 |

|-------+-------+-------+-------+-------+-------+-------+-------|

8 | RIGHT | DOWN |	UP | LEFT | DEL | INS | HOME | SPACE |

-----------------------------------------------------------------



[TEN KEY]

-----------------------------------------------------------------

9 |	4 |	3 |	2 |	1 |	0 | option| option| option|

|-------+-------+-------+-------+-------+-------+-------+-------|

10 |	. |	, |	- |	9 |	8 |	7 |	6 |	5 |

-----------------------------------------------------------------



Figure 5.17	MSX International version key matrix

MSB								 LSB

7	6	5	4	3	2	1	0

-----------------------------------------------------------------

0 |	B |	L |deadkey|	/ |	1 |	S |	X |	, |

|-------+-------+-------+-------+-------+-------+-------+-------|

1 |	V |	J |	^ |	] |	Q |	A |	C |	N |

|-------+-------+-------+-------+-------+-------+-------+-------|

2 |	G |	8 |	0 |	[ |	W |	F |	Z |	M |

|-------+-------+-------+-------+-------+-------+-------+-------|

3 |	T |	I |	~ |	; |	2 |	D |	U |	\ |

|-------+-------+-------+-------+-------+-------+-------+-------|

4 |	6 |	K |	P |	: |	3 |	R |	7 |	H |

|-------+-------+-------+-------+-------+-------+-------+-------|

5 |	5 |	0 |	9 |	@ |	4 |	E |	Y |	. |

|-------+-------+-------+-------+-------+-------+-------+-------|

6 |	F3 |	F2 |	F1 | CODE | CAPS | GRAPH | CTRL | SHIFT |

|-------+-------+-------+-------+-------+-------+-------+-------|

7 | RETURN| SELECT|	BS | STOP | TAB | ESC |	F5 |	F4 |

|-------+-------+-------+-------+-------+-------+-------+-------|

8 | RIGHT | DOWN |	UP | LEFT | DEL | INS | HOME | SPACE |

-----------------------------------------------------------------



[TEN KEY]

-----------------------------------------------------------------

9 |	4 |	3 |	2 |	1 |	0 | option| option| option|

|-------+-------+-------+-------+-------+-------+-------+-------|

10 |	. |	, |	- |	9 |	8 |	7 |	6 |	5 |

-----------------------------------------------------------------



Figure 5.17B MSX European version key matrix

MSB								 LSB

7	6	5	4	3	2	1	0

-----------------------------------------------------------------

0 |	7 |	6 |	5 |	4 |	3 |	2 |	1 |	0 |

|-------+-------+-------+-------+-------+-------+-------+-------|

1 |	; |	] |	[ |	\ |	= |	- |	9 |	8 |

|-------+-------+-------+-------+-------+-------+-------+-------|

2 |	B |	A | accent|	/ |	. |	, |	` |	' |

|-------+-------+-------+-------+-------+-------+-------+-------|

3 |	J |	I |	H |	G |	F |	E |	D |	C |

|-------+-------+-------+-------+-------+-------+-------+-------|

4 |	R |	Q |	P |	O |	N |	M |	L |	K |

|-------+-------+-------+-------+-------+-------+-------+-------|

5 |	Z |	Y |	X |	W |	V |	U |	T |	S |

|-------+-------+-------+-------+-------+-------+-------+-------|

6 |	F3 |	F2 |	F1 | CODE | CAPS | GRAPH | CTRL | SHIFT |

|-------+-------+-------+-------+-------+-------+-------+-------|

7 | RETURN| SELECT|	BS | STOP | TAB | ESC |	F5 |	F4 |

|-------+-------+-------+-------+-------+-------+-------+-------|

8 | RIGHT | DOWN |	UP | LEFT | DEL | INS | HOME | SPACE |

-----------------------------------------------------------------



[TEN KEY]

-----------------------------------------------------------------

9 |	4 |	3 |	2 |	1 |	0 | option| option| option|

|-------+-------+-------+-------+-------+-------+-------+-------|

10 |	. |	, |	- |	9 |	8 |	7 |	6 |	5 |

-----------------------------------------------------------------



List 5.4 Use of the key scanning routine =================================================================



;********************************************************

;

; List 5.4 scan key-matrix and display it ;

;********************************************************

;

CHPUT	EQU	00A2H

BREAKX	EQU	00B7H

POSIT	EQU	00C6H

SNSMAT	EQU	0141H



ORG	0B000H



;----- program start -----	Note: read key matrix and display key pattern.



SCAN:	LD	C,0		;C := line of key matrix



SC1:	LD	A,C

CALL	SNSMAT		;Read key matrix

LD	B,8

LD	HL,BUF		;HL : = buffer address SC2:	LD	D,'.'

RLA			;Check bit JR	C,SC3

LD	D,'#'



SC3:	LD	(HL),D		;store '.' or '#' to buffer INC	HL

DJNZ	SC2



LD	H,05H		;x := 5

LD	L,C		;y := C+1

INC	L

CALL	POSIT		;set cursor position

LD	B,8		;put out bit patterns to CRT

LD	HL,BUF

SC4:	LD	A,(HL)

CALL	CHPUT

INC	HL

DJNZ	SC4



CALL	BREAKX		;check Ctrl-STOP

RET	C



INC	C		;line No. increment LD	A,C

CP	09

JR	NZ,SC1

JR	SCAN



;----- work area -----



BUF:	DS	8



END



=================================================================





3.2 Character Input




MSX scans the key matrix every 1/60 second using the timer interrupt and, when a key is pressed, stores the character code in the keyboard buffer as shown in Figure 5.18. Key input to MSX is generally done by reading this keyboard buffer.



Figure 5.18	Keyboard ring buffer

+----------------------------------<----------------------------------------+

|			 KEYBUF (FBF0H, 40)			 |

| --------------------------------------/ /-------------------------------- |

+>| D	| E | F | G |	| | \ \ |	 |	| A | B | C |-+

--------------------------------------/ /--------------------------------

^				 ^

|				 |

[PUTPNT]			[GETPNT]



GETPNT (F3FAH, 2) points to the next character to be obtained in CHGET

routine.



PUTPNT (F3F8H, 2) points to the next location for the character to be put when the keyboard is pressed next time.



BIOS routines having functions for key input using this keyboard buffer and functions related to it are described below. Inhibiting the timer interrupt renders them useless, of course.



* CHSNS (009CH/MAIN) .................. checks the keyboard buffer

Input:		---

Output: 	Z flag = ON when the buffer is empty Function:	examines whether any characters remain in the keyboard buffer and sets the Z flag when the buffer is empty.



* CHGET (009FH/MAIN) .................. one character input from the keyboard buffer



Input:		---

Output: 	A <-- character code

Function:	reads one character from the keyboard buffer and stores it in the A register. When the buffer is empty, it displays the cursor and waits for a key input. While a key input is waited for, the CAP lock, KANA lock, and Roman-to-kana translation lock are valid. The related work area is listed below. In the list, since SCNCNT and REPCNT are initialised after the execution of CHGET routine, this area should be set at each CHGET call to change the interval of the auto-repeat.



Work area

CLIKSW (F3DBH, 1)	key click sound (0 = OFF, others = ON) SCNCNT (F3F6H, 1)	key scanning interval (1, normally) REPCNT (F3F7H, 1)	delay until beginning auto-repeat (50, normally)

CSTYLE (FCAAH, 1)	figure of the cursor (0 = block, others = underline) CAPST (FCABH, 1)	CAPS lock (0 = OFF, others = ON) DEADST (FCACH, 1)	dead key lock 0 = on preceding dead key 1 = dead key

2 = shifted dead key 3 = code dead key 4 = code shift dead key

* KILBUF (0156H/MAIN) ................. empty the keyboard buffer

Input:		---

Output: 	---

Function:	empties the keyboard buffer.



List 5.5 Use of one character input routine =================================================================



;********************************************************

;

; List 5.5	get key code

;

;		this routine doesn't wait for key hit ;

;********************************************************

;

CHSNS	EQU	009CH		;check keyboard buffer CHGET	EQU	009FH		;get a character from buffer CHPUT	EQU	00A2H		;put a character to screen BREAKX	EQU	00B7H		;check Ctrl-STOP

KILBUF	EQU	0156H		;clear keyboard buffer REPCNT	EQU	0F3F7H		;time interval until key-repeat KEYBUF	EQU	0FBF0H		;keyboard buffer address

ORG	0B000H



;----- prgram start -----	Note: Real-time input using CHGET



KEY:	CALL	CHSNS		;check keyboard buffer JR	C,KEY1



LD	A,1

LD	(REPCNT),A	;not to wait until repeat CALL	CHGET		;get a character (if exists) JR	KEY2



KEY1:	LD	A,'-' ;A := '-'



KEY2:	CALL	CHPUT		;put the character

CALL	KILBUF		;clear keyboard buffer CALL	BREAKX		;check Ctrl-STOP

JR	NC,KEY



END



=================================================================



* CNVRCHR (00AB/MAIN) ................. graphic character operation

Input:		A <-- character code

Output: 	A <-- translated graphic character (normal characters are not translated) CY flag = OFF (input was the graphic header byte 01H) CY flag = ON, Z flag = ON (input was the graphic character and was translated) CY flag = ON, Z flag = OFF (input was the normal character and was not translated) Function:	executing CNVCHR after CHGET causes the graphic character to be translated to one byte code as shown in Figure 5.19

and causes other character not to be translated and to be returned. Since the graphic character is represented by irregular 2-byte code with the graphic header byte (01H), annoying procedures are required for the character operations; this routine makes it somewhat easy.



Figure 5.19	Graphic character translation chart

-------------------------------------------------------------

| Before | After | Before |	 After |

| conversion | conversion | conversion |	conversion |

|-----------------------------+-----------------------------|

|			 | 0150H --> 50H |

| 0141H --> 41H | 0151H --> 51H |

| 0142H --> 42H | 0152H --> 52H |

| 0143H --> 43H | 0153H --> 53H |

| 0144H --> 44H | 0154H --> 54H |

| 0145H --> 45H | 0155H --> 55H |

| 0146H --> 46H | 0156H --> 56H |

| 0147H --> 47H | 0157H --> 57H |

| 0148H --> 48H | 0158H --> 58H |

| 0149H --> 49H | 0159H --> 59H |

| 014AH --> 4AH | 015AH --> 5AH |

| 014BH --> 4BH | 015BH --> 5BH |

| 014CH --> 4CH | 015CH --> 5CH |

| 014DH --> 4DH | 015DH --> 5DH |

| 014EH --> 4EH | 015EH --> 5EH |

| 014FH --> 4FH | 015FH --> 5FH |

-------------------------------------------------------------



* PINLIN (00AEH/MAIN) ................. one line input

Input:		---

Output: 	HL <-- F55DH

[F55EH] <-- input string (the end of te line is represented by 00H)

CY flag <-- terminated by STOP=ON, terminated by RETURN=OFF

function:	stores input string in the line buffer BUF (F55EH). All functions of the screen editing are available at the string input. Pressing RETURN or STOP causes the input to be finished. The work area is listed below.



Work area

BUF (F55EH, 258)	the line buffer where the string is stored LINTTB (FBB2H, 24)	00H when the one physiscal line is the succession of the line above

* INLIN (00B1H/MAIN) .................. one line input (prompt available)

Input:		---

Output: 	same as PINLIN

Function:	stores input string in the line buffer BUF (F55EH), as PINLIN routine. Note that the portion before the cursor location at the time when the routine begins to execute is not received. List 5.6 shows the difference between PINLIN

and INLIN.



List 5.6 Difference between INLIN and PINLIN

=================================================================



;************************************************

;

; List 5.6 INLIN and PINLIN

;

;************************************************

;

CHPUT	EQU	00A2H

INLIN	EQU	00B1H

PINLIN	EQU	00AEH

KILBUF	EQU	0156H



BUF	EQU	F55EH



ORG	0B000H



;----- program start -----



LD	HL,PRMPT1

CALL	PUTMSG		;put prompt message CALL	INLIN		;use INLIN routine LD	HL,BUF

CALL	PUTMSG



LD	HL,PRMPT2

CALL	PUTMSG		;put prompt message CALL	PINLIN		;use PINLIN routine LD	HL,BUF

CALL	PUTMSG



RET



;----- put a string -----



PUTMSG: LD	A,(HL)

CP	'$'

RET	Z

CALL	CHPUT

INC	HL

JR	PUTMSG



;----- string data -----



PRMPT1: DB	0DH,0AH,'INLIN:$'

PRMPT2: DB	0DH,0AH,'PINLIN:$'



END



=================================================================





3.3 Function Keys




MSX has ten function keys, which can be defined by the user at will. A 16

byte work area is allocated for the definition of each key. The following list shows their addresses.



FNKSTR (F87FH, 16) ............ F1 key definition address + 10H (F88FH, 16) ............ F2 key definition address + 20H (F89FH, 16) ............ F3 key definition address + 30H (F8AFH, 16) ............ F4 key definition address + 40H (F8BFH, 16) ............ F5 key definition address + 50H (F8CFH, 16) ............ F6 key definition address + 60H (F8DFH, 16) ............ F7 key definition address + 70H (F8EFH, 16) ............ F8 key definition address + 80H (F8FFH, 16) ............ F9 key definition address + 90H (F90FH, 16) ............ F10 key definition address

Pressing a function key causes the string defined in that key to be stored in [KEYBUF]. The end of the string is indicated by 00H and a maximum of 15

keystrokes can be defined for one function key (definitions longer than 16

keystrokes are defined over more than one function key definition area). To restore the initial settings of the function keys, use the following BIOS

routine.



* INIFNK (003EH/MAIN) ................. initialize function keys

Input:		---

Output: 	---

Function:	restores the function key definition to the setting when BASIC starts.





3.4 STOP Key During Interrupts




CHGET, the one-character input routine described in 3.3, determines the pressed key in the timer interrupt routine. Thus, when the timer interrupt is inhibited, such as during cassette data I/O, pressed keys cannot be detected.

By using the BIOS routine described below, the CTRL key + STOP key combination can be detected even when interrupts are inhibited.



* BREAKX (00B7H/MAIN) ................. CTRL + STOP detection

Input:		---

Output: 	CY flag = ON, when CTRL + STOP is pressed Function:	scans keys and decides whether CTRL key and STOP key are pressed at the same time. When both are pressed, this routine sets "1" to the CY flag and returns. Otherwise, it resets "0"

to the CY flag and returns. This routine is available while interrupts are inhibited.





4. PRINTER INTERFACE




This section describes how to access the MSX printer interface from assembly language. The information described here is helpful if the printer is going to be used to print bit image graphics.





4.1 Print Interface Overview




The printer interface is supported by BIOS and BASIC. MSX drives the printer through an 8-bit parallel output port and uses a handshaking method with BUSY

and STROBE signals. The standard connector is also defined (Amphenol 14-pin, female side to the machine). Figure 5.20 shows the signal lines.



Figure 5.20	Printer interface

Printer interface pin connections

-------------------------------------------------------------------

\	 ------------------------------------------- 	 /

\	 | (7) | (6) | (5) | (4) | (3) | (2) | (1) | 	/

\	--------------------------------------------------- /

\	|						 | /

\	--------------------------------------------------- /

\ | (14)| (13)| (12)| (11)| (11)| (10)| (9) | /

\ ------------------------------------------- /

---------------------------------------------------



(1) ........... STROBE*

(2) to (9) .... Data (b0 to b7)

(11) .......... BUSY

(14) .......... BGND



-------------------------------------------------

I/O port (91H)		 | X | X	| X | X | X | X	| X | X |

-------------------------------------------------

Data



-------------------------------------------------

I/O port (90H; at WRITE) | . | .	| . | . | . | .	| . | X |

-------------------------------------------------

^

|

STROBE* (send data when "0") ----+



-------------------------------------------------

I/O port (90H; at READ) | . | .	| . | . | . | .	| X | . |

-------------------------------------------------

^

0: Printer READY |

---+





1: Printer BUSY





4.2 Output to the MSX Standard Printer




If data is sent from MSX to the printer, the action depends on whether the printer receiving the data is of the MSX standard. The use of MSX standard printers is described in this section. Descriptions about other printers are in the next section.



An MSX standard printer can print any character that can be displayed on the screen. Special graphic characters corresponding to character codes n = 01H

to 1FH can be also printed by sending the code 40H + n after the graphic character header (01H). In addition to these, the control codes shown in Table 5.4 can be used with MSX standard printers (see the manual of the printer for controlling a printer which has other functions such as printing Chinese characters).



To feed lines in MSX standard printers, send 0DH and 0AH successively. To print the bit image, send nnnn bytes data, where nnnn means four decimal figures, after the escape sequence ESC + "Snnnn". Note that, MSX has a function to transform the tab code (09H) to the adequate number of space codes (20H) for printers not having a tab function. This transformation is normally done. To print a bit image which includes the value 09H correctly, change the following work area.



* RAWPRT (F418H, 1) ................... replaces a tab by spaces when the contents are 00H, othereise not.



Table 5.4 Control codes of the printer

-----------------------------------------------------------------------------

| code	 |			 function			 |

|-----------------+---------------------------------------------------------|

| 0AH		 | line feed						 |

|-----------------+---------------------------------------------------------|

| 0CH		 | form feed						 |

|-----------------+---------------------------------------------------------|

| 0DH		 | carriage return					 |

|-----------------+---------------------------------------------------------|

| ESC + "A" | normal line spacing |

|		 | (spaces between lines; characters are read easily) |

|-----------------+---------------------------------------------------------|

| ESC + "B" | line spacing for graphics (no space between lines) |

|-----------------+---------------------------------------------------------|

| ESC + "Snnnn" | bit image printing |

-----------------------------------------------------------------------------





4.3 Access to the printer




To send output to the printer, the following BIOS routines are offered.



* LPTOUT (00A5H/MAIN)



Input:		A register <-- character code Output: 	CY flag = ON at abnormal termination Function:	sends a character specified by the A register to the printer.



* LPTSTT (00A8/MAIN)



Input:		---

Output: 	A register <-- printer status Function:	examines the current printer status. After calling this routine, the printer can be used when the A register is 255

and the Z flag is 0; when the A register is 0 and the Z flag is 1, the printer cannot be used.



* OUTDLP (014DH,MAIN)



Input:		A register <-- character code Output: 	CY flag = ON at abnormal termination Function:	sends a character specified by the A register to the printer.

Differences between this routine and LPTOUT routine is as following:

* prints corresponding number of spaces for TAB code * transforms hiragana to katakana for printers other than MSX standard

* returns Device I/O error at abnormal termination

5. UNIVERSAL I/O INTERFACE



As described in section 1, the PSG used by MSX has two 8-bit I/O ports, port A and port B, in addition to the sound output function. In MSX, these two ports are connected to the universal I/O interface (joystick port) and are used to exchange data with the joystick or the paddle (see Figure 5.21).

Various devices to be connected to this universal I/O interface have the necessary BIOS routine in ROM, so they are easily accessbile.



In this section, the funtion of each I/O device and the method for accessing with BIOS routines are described.



Figure 5.21	Universal I/O interface

Universal input/output interface -1

-----------------------------------------

|					|

| (1)	 (2)	 (3)	 (4)	 (5) -+- +5V	 Switching signal <---+

| | (6) | (7) | (8) | (9) -----+- GND		(to port B:b6)	 |

| |	| |	| |	| |		|				 |

----:---:---:---:---:---:---:------------				 |

|	| |	| |	| |						 |

|	| |	| | ---:--> To port B:b4	 ------------------------- |

|	| |	| |	 |			 |			 | |

+---+---+---+---+-------+--------------------|			 | |

|	 Switcher	 |--+

+---+---+---+---+-------+--------------------|			 |

|	| |	| |	 |			 |			 |

|	| |	| | ---:--> To port B:b5	 -------------------------

|	| |	| |	| |			 | | | | | |

----:---:---:---:---:---:---:------------	 (1) (2) (3) (4) (6) (7) | |	| |	| |	| |		|	| | | | | | | |

| (1)	 (2)	 (3)	 (4)	 (5) -+- +5V -------------------------+

| (6) (7) (8) (9) -----+- GND		 |

|					|		 V

-----------------------------------------	 To port A:b0 to b5

Universal input/output interface -2





5.1 Functions of the Ports




Two I/O ports of PSG are used as shown in Figure 5.22.



Figure 5.22 (A) Functions of PSG port A

Port A (PSG#14)

-------------------------------------------------

| b7 | . | b5 : b4	: b3 : b2 : b1 : b0	|

-------------------------------------------------

|	 | |	 |	 | | |		 --+

|	 | |	 |	 | | +--> 1st terminal	 | connected |	 | |	 |	 | +--------> 2nd terminal	 | to |	 | |	 |	 +--------------> 3rd terminal	 | universal |	 | |	 +--------------------> 4th terminal	 | I/O

|	 | +--------------------------> 6th terminal	 | interface |	 +--------------------------------> 7th terminal	 |

|							 --+

+-----------------------------------> Data input from the cassette tape

Figure 5.22 (B) Functions of PSG port B



Port B (PSG#15)

-------------------------------------------------

| b7 | b6 | b5 | b4	| b3 | b2 | b1 | b0	|

-------------------------------------------------

|	 | | |	 |	 | | |

|	 | | |	 +-----+-----+-----+--> Unused |	 | | |

|	 | | +---> Connected to 8th terminal of univ. I/O interface 1

|	 | +---------> Connected to 8th terminal of univ. I/O interface 2

|	 |

|	 +---> 0: b0-b5 of port A to be connected to univ. I/O interface 1

|	 1: b0-b5 of port A to be connected to univ. I/O interface 2

|

+---------> 0: Arabic or kana mode display lamp on





1: Arabic or kana mode display lamp off





5.2 Joystick Use




Figure 5.23 shows the joystick circuit. As the circuit shows, sending "0" to the 8th terminal and reading the 1st to 4th and 6th to 7th terminals enable information about the stick and the trigger buttons to be obtained. However, it is advisable to use BIOS for accessing the joystick, in order to give portability to the program.



figure 5.23	Joystick circuit

\

(1)	O---------------o o------------+ ............. Front |

\		|

(2)	O---------------o o------------+ ............. Back |

\		|

(3)	O---------------o o------------+ ............. Left |

\		|

(4)	O---------------o o------------+ ............. Right |

|

\		|

(6)	O---------------o o------------+ ............. Trigger A |

\		|

(7)	O---------------o o------------+ ............. Trigger B

|

|

(8)	O-------------------------------+



The following BIOS routines are offered for accessing the joystick. These routines have similar functions to the STICK function and STRIG function of BASIC. The status of the cursor keys or the space bar, in addition to the joystick, can be read in real time.



* GTSTCK (00D5H/MAIN) ................. read joystick

Input:		A <-- joystick number (0 = cursor key, 1 and 2 = joystick) Output: 	A <-- direction of joystick or cursor key Function:	returns the current status of the joystick or the cursor keys in the A register. The value is the same as the STICK

function in BASIC.



* GTTRIG (00D8H/MAIN) ................. read trigger button

Input:		A <-- trigger button number (0 = space bar, 1 and 2 = trigger button A, 3 and 4 = trigger button B) Output: 	A <-- status of trigger button or space bar (0FFH = pressed, 00H = released) Function:	returns the current status of the trigger buttons or the space bar in the A register. The value is 0FFH when the trigger is pressed, otherwise it is 0.



List 5.7 Joystick use

=================================================================



;************************************************

;

; List 5.7 Joystick and trigger access

;

;************************************************

;

CHPUT	EQU	00A2H

BREAKX	EQU	00B7H

GTSTCK	EQU	00D5H

GTTRIG	EQU	00D8H



ORG	0D00H



;----- program start -----	Note: display joystick status

STICK:	LD	A,1		;choose joystick 1

CALL	GTSTCK		;read joystick status LD	(WK1),A

LD	A,1		;choose joystick 1

CALL	GTTRIG		;read trigger status

OR	A

JR	Z,STCK1

LD	HL,WDON 	;trigger ON

JR	STCK2

STCK1:	LD	HL,WDOFF	;trigger OFF

STCK2:	CALL	PUTSTR

LD	A,(WK1)

OR	A

JR	Z,BRKCH0	;do not use joystick LD	C,0

STCK3:	DEC	A

JR	NZ,STCK4

INC	C

JR	STCK3



STCK4:	SLA	C		;C := C*16

SLA	C

SLA	C

SLA	C

LD	B,0		;Accounting Strings data address LD	HL,WDSTK

ADD	HL,BC

CALL	PUTSTR



BRKCH0: LD	A,0DH		;put carriage return

CALL	CHPUT		;code := 0DH



BRKCHK: CALL	BREAKX		;break check

RET	C

JR	STICK



;----- put strings to screen -----



PUTSTR: LD	A,(HL)

CP	'$'

RET	Z

INC	HL

CALL	CHPUT

JR	PUTSTR



;----- string area -----



WDON:	DB	'Trigger ON: $'

WDOFF:	DB	'Trigger OFF: $'

WDSTK:	DB	'UP only ',0DH,0AH,'$'

DB	'Up and Right ',0DH,0AH,'$'

DB	'Right only ',0DH,0AH,'$'

DB	'Right & Down ',0DH,0AH,'$'

DB	'Down only ',0DH,0AH,'$'

DB	'Down and Left',0DH,0AH,'$'

DB	'Left only ',0DH,0AH,'$'

DB	'Left and Up ',0DH,0AH,'$'



WK1:	DW	0



END



=================================================================





5.3 Paddle Use




Figure 5.24 shows the paddle circuit. Sending a pulse to the 8th terminal causes the single stable multi-vibrator to generate a pulse with a specified interval. This interval depends on the value of the variable register which can range from 10 to 3000 microseconds (0.01 to 3.00 ms). Measuring the pulse length enables the value in the variable register and the turning angle to be obtained.



Figure 5.24	Paddle circuit

--+--

|

<_

_> 150KOhm Variable Resistor <

|

0.04 uF	|

+--| |---+

|	|

---+--------+---

|		 |

|\	 |		 |

| \	 |		 |

(8) -----| >O----O| A 	 Q |------------- (1) (For 2, 3, 4, 6, or 7, | /	 |		 |			a similar circuit |/	 |		 |			would apply) |		 |

|		 |

+----------| B 	 |

|	 |		 |

|	 |		 | (One-shot trigger IC, LS123 compatible) |	 |		 |

+5V	 |	 ----------------

--+--	 |		 O

|	 |		 |

+-----+-----------------+



____

: :

Input to 8	________: :_____________________________________



_________________________________

:				:

Output to 1	________:				:________

|<------- 10 us to 3 ms ------->|



BIOS routines for accessing the paddle are described below.



* GTPDL (00DEH/MAIN) .................. read paddle information

Input:		A <-- paddle number (1 to 12) Output: 	A <-- turning angle (0 to 255) Function:	examines the status of the paddle specified in the A register and returns the result in the A register.



5.4 Use of Touch Panel, Light Pen, Mouse, and Track Ball

The touch panel, light pen, mouse, and track ball (cat) are accessible using the same BIOS routine. This routine is described below.



* GTPAD (00DBH/MAIN) .................. access to various I/O devices

Input:		A <-- device ID (0 to 19)

Output: 	A <-- objective information Function:	obtains various information as shown in Table 5.5 according to the value specified in the A register. This is the same as the PAD function of BASIC. "XXX1" in the table means the "XXX" device connected to the universal I/O interface 1; "XXX2" means the one connected to the universal I/O interface





#2.




Table 5.5 GTPAD BIOS Function

--------------------------------------------------------------------------

| Device ID | Device specified |	 Information returned	 |

--------------+--------------------+-------------------------------------|

| 0 | 		 | 0FFH when touching panel surface, |

|	 | 		 | 00H when not			 |

|-------------| 		 |-------------------------------------|

| 1 | 		 | X-coordinate (0 to 255)		 |

|-------------| Touch panel 1 |-------------------------------------|

| 2 | 		 | Y-coordinate (0 to 255)		 |

|-------------| 		 |-------------------------------------|

| 3 | 		 | 0FFH when button is pressed,	 |

|	 | 		 | 00H when not			 |

|-------------+--------------------+-------------------------------------|

| 4 | 		 |					 |

|-------------| 		 |					 |

| 5 | 		 |					 |

|-------------| Touch panel 2 | Same as above			 |

| 6 | 		 |					 |

|-------------| 		 |					 |

| 7 | 		 |					 |

|-------------+--------------------+-------------------------------------|

| 8 | 		 | 0FFH: valid data, 		 |

|	 | 		 | 00H: invalid data 		 |

|-------------| 		 |-------------------------------------|

| 9 | 		 | X-coordinate (0 to 255)		 |

|-------------| Light pen	 |-------------------------------------|

| 10 | 		 | Y-coordinate (0 to 255)		 |

|-------------| 		 |-------------------------------------|

| 11 | 		 | 0FFH when switch is pressed,	 |

|	 | 		 | 00H when not			 |

|-------------+--------------------+-------------------------------------|

| 12 | 		 | Always 0FFH			 |

|	 | 		 | (used to request for input)	 |

|-------------| 		 |-------------------------------------|

| 13 | Mouse 1 or	 | X-coordinate (0 to 255)		 |

|-------------| track ball 1	 |-------------------------------------|

| 14 | 		 | Y-coordinate (0 to 255)		 |

|-------------| 		 |-------------------------------------|

| 15 | 		 | Always 00H			 |

|	 | 		 | (no meaning)			 |

|-------------+--------------------+-------------------------------------|

| 16 | 		 |					 |

|-------------| 		 |					 |

| 17 | Mouse 2 or	 |					 |

|-------------| track ball 2	 | Same as above			 |

| 18 | 		 |					 |

|-------------| 		 |					 |

| 19 | 		 |					 |

--------------------------------------------------------------------------



Note 1: Though information of the coordinate of the light pen (A = 9, 10) and the switch (A = 11) are read at the same time when BIOS is called with A = 8, other values are valid only when the result is 0FFH.

In the case that the result of BIOS which is called with A = 8 is 00H, the coordinate values and the status of the switch contained after that are meaningless.

Note 2: Mouse and track ball are automatically distinguished.

Note 3: To obtain the coordinate value of the mouse or the track ball, do the input request call (A = 12 or A = 16), then execute the call to obtain the coordinate value actually. In this case, the interval of these two calls must be minimized as possible. Too much interval between the input request and the coordinate input causes the obtained data to be unreliable.

Note 4: To obtain the status of the trigger button of the mouse or the trigger button of the track ball, use GTTRIG (00D8H/MAIN), not GTPAD

routine.



List 5.8 Touch panel use

=================================================================



;************************************************

;

; List 5.8 touch pad access

;

;************************************************

;

BREAKX	EQU	00B7H

GTPAD	EQU	00D8H

WRTVRM	EQU	004DH



ORG	0B000H



;----- program start -----	Note: Displays "*" at position specified by touch pad.



PAD:	XOR	A		;check sense

CALL	GTPAD

OR	A

JR	NZ,PAD1

LD	A,3

CALL	GTPAD		;break check OR	A

RET	NZ

JR	PAD



PAD1:	LD	A,1		;get X axis

CALL	GTPAD

SRL	A		;A := A/8

SRL	A

SRL	A

LD	(WORK),A	;reserve X axis LD	A,2		;get Y axis CALL	GTPAD

LD	L,A		;HL := Y data (0-255) LD	H,0

LD	C,A

LD	B,0

ADD	HL,BC		;HL := HL*3 (HL := 0-767) ADD	HL,BC

LD	A,L

AND	11100000B

LD	L,A

LD	A,(WORK)

ADD	A,L

LD	L,A

LD	BC,1800H	;VRAM start address ADD	HL,BC

LD	A,2AH

CALL	WRTVRM		;write VRAM

LD	A,3

CALL	GTPAD		;break check OR	A

RET	NZ

JR	PAD



;----- work area -----



WORK:	DW	0		;work



END



=================================================================



List 5.9 Mouse and track ball use

=================================================================



;************************************************

;

; List 5.9 mouse and track ball access

;

;************************************************

;

GTPAD	EQU	00DBH

WRTVRM	EQU	004DH

RDVRM	EQU	004AH

BREAKX	EQU	00B7H



ORG	0D000H



;----- program start -----	Note: Displays "*" at position specified by mouse or track ball.



TEST:	CALL	VADR		;Put old data

LD	A,(WKOLD)

CALL	WRTVRM

LD	A,12

CALL	GTPAD		;Request mouse/track ball data LD	A,13

CALL	GTPAD		;Read X val.

LD	(WKXVAL),A

LD	A,14

CALL	GTPAD		;Read Y val.

LD	(WKYVAL),A



LD	A,(WKX)

LD	B,A

LD	A,(WKXVAL)

ADD	A,B

CP	245		;X<0?

JR	C,TEST01

XOR	A		;X=0

JR	TEST02



TEST01: CP	32		;X>31?

JR	C,TEST02

LD	A,31



TEST02: LD	(WKX),A



LD	A,(WKY)

LD	B,A

LD	A,(WKYVAL)

ADD	A,B

CP	245		;Y<0?

JR	C,TEST03

XOR	A		;Y=0

JR	TEST04



TEST03: CP	24		;Y>23?

JR	C,TEST04

LD	A,23



TEST04: LD	(WKY),A



CALL	VADR

CALL	RDVRM		;Read old data LD	(WKOLD),A



CALL	VADR

LD	A,2AH

CALL	WRTVRM		;Put cursor ("*").



CALL	BREAKX		;Break check RET	C



CALL	WAIT



JR	TEST



VADR:	LD	A,(WKY) 	;Make SCREEN Address: LD	H,A		; From X,Y axis on WORK AREA LD	L,0		; To Hl reg.

SRL	H

RR	L

SRL	H

RR	L

SRL	H

RR	L

LD	A,(WKX)

ADD	A,L		; Y=32+X

LD	L,A

LD	BC,1800H	; VRAM start address ADD	HL,BC

RET



WAIT:	LD	A,0		;WAIT routine

WLP1:	INC	A

LD	B,(IX+0)

LD	B,(IX+0)

LD	B,(IX+0)

JR	NZ,WLP1

RET



;----- data -----



WKX:	DB	10		;X axis

WKY:	DB	10		;Y axis

WKOLD:	DB	0		;Character code on (X,Y)

WKXVAL: DB	0		;X variable

WKYVAL: DB	0		;Y variable



END



=================================================================





6. CLOCK AND BATTERY-POWERED MEMORY




MSX2 uses a CLOCK-IC to for its timer function. Since this IC is battery-powered, it remains active even after MSX2 is turned off. MSX2 uses a small amount of RAM inside to set the PASSWORD or to set the screen mode at startup automatically, in addition to the CLOCK functions.





6.1 CLOCK-IC Functions




This IC has the following three functions:

* CLOCK function



- set/read the settings of "year, month, day, day of week, hour, minute, second"

- for the expression of time, 24-hour clock/12-hour clock available - for months, months of 31 days and of 30 days are distinguished (leap years are also recognised)

* Alarm function



- when the time for alarm is set, CLOCK generates signals at that time.

- the time for alarm is set as "XXday XXhour XXminute".



* Battery-powered memory function



- has 26 sets of 4-bit memory, and can be battery-powered.

- MSX2 stores the following data in this memory:

1. adjustment value of CRT display width and height 2. initial values of SCREEN, WIDTH, colour 3. BEEP tone and volume 4. title screen colour





5. country code


6. password	 --+

7. BASIC prompt 	| (one of 6 to 8) 8. title caption --+





6.2 Structure of the CLOCK-IC




The CLOCK-IC has four blocks inside as shown in Figure 5.25. Each block consists of 13 sets of 4-bit registers, which are specified by addresses from 0 to 12. In addition, it has three 4-bit registers for selecting the block or controlling functions; they are specified by the addresses from 13 to 15.



The registers inside the block (#0 to #12) and the MODE register (#13) can be read from and written to. The TEST register (#14) and RESET register (#15) can only be written to.



Figure 5.25	Clock IC structure

BLOCK 0		 BLOCK 1	 BLOCK 2		BLOCK 2

(CLOCK)		 (ALARM)	 (RAM-1)		(RAM-2) ---------------- ----------------	 ---------------- ----------------

| Seconds (the | | 	 |	 |		| |		 |

0 | 1st decimal | | ________ |	 |		| |		 |

| place)	 | | 	 |	 |		| |		 |

|--------------| |--------------|	 |-	 -| |-		 -|

| Seconds (the | | 	 |	 |		| |		 |

1 | 2nd decimal | | ________ |	 |		| |		 |

| place)	 | | 	 |	 |		| |		 |

|--------------| |--------------|	 |-	 -| |-		 -|

. |	 .	 | | .	 |	 | Any data	| |	Any data |

. |	 .	 | | .	 |	 |		| |		 |

. |	 .	 | | .	 |	 |		| |		 |

. |	 .	 | | .	 |	 |		| |		 |

. |	 .	 | | .	 |	 |		| |		 |

|--------------| |--------------|	 |-	 -| |-		 -|

| Year (the	 | | 	 |	 |		| |		 |

12| 2nd decimal | | ________ |	 |		| |		 |

| place)	 | | 	 |	 |		| |		 |

---------------- ----------------	 ---------------- ----------------

:<-- 4 bits -->: :<-- 4 bits -->:	 :<-- 4 bits -->: :<-- 4 bits -->:

----------------

13 |	 MODE	 |

|--------------| --+

14 |	 TEST	 | |

|--------------| |-- Write only 15 |	 RESET	 | |

---------------- --+

:<-- 4 bits -->:





6.3 MODE Register Functions




The MODE register has the following 3 functions:

* Selecting block



To read from or write to registers from #0 to #12, select the block to be used and then access the objective address. The 2 low order bits of the MODE

register are used to select the block.



Registers from #13 to #15 are accessible whichever block is selected.



* Alarm output ON/OFF



To switch the alarm input ON/OFF, use bit 2 of the MODE register. Since the standard MSX2 does not support the alarm, modifying this bit causes nothing to happen in general.



* Terminating CLOCK count



By writing "0" in bit 3 of the MODE register, the count in seconds is stopped (the stages before the seconds are not stopped) and the clock function is terminated. By writing "1" in bit 3, the count is resumed.



Figure 5.26	MODE register functions

B3 B2 B1	 B0

---------------------

| TE | AE | M1 : M0 | MODE register (#13) ---------------------

| | | 00: select block 0

| | | 01: select block 1

| | +----> 10: select block 2

| |	 11: select block 3

| |

| +------------> 0: alarm output OFF

|		 1: alarm output ON

|

+-----------------> 0: CLOCK count stop (in seconds)





1: CLOCK count start





6.4 TEST Register functions




The TEST register (#14) is used to increment the upper counter quickly and to confirm that date and time carries are done correctly. Setting "1" in each bit of the register, the pulse of 2^14 (=16384)[Hz] is directly set in day, hour, minute, and second counters.



Figure 5.27	TEST register functions

B3 B2 B1	 B0

---------------------

| T3 | T2 | T1 | T0 | TEST register (#14) ---------------------

| | |	 |

| Hours | Seconds ........ the location for the pulse to be placed Day	 Minutes





6.5 RESET Register Functions




The RESET register (#15) has the following functions:

* Resetting the alarm



Setting "1" in bit 0 causes all alarm registers to be reset to 0.



* Setting the seconds



Setting "1" in bit 1 causes the stage before the seconds to be reset. Use this function to set the seconds correctly.



* Clock pulse ON/OFF



Setting "1" in bit 2 turns the 16Hz clock pulse output ON, and setting "0" in bit 3 turns the 1Hz clock pulse output ON. Note that both are not supported by the MSX2 standard.



Figure 5.28	RESET register function

B3 B2 B1	 B0

---------------------

| C1 | C16| CR | AR | RESET register (#15) ---------------------

| | |	 |

| | |	 +--> When "1", all alarm registers are reset | | +-------> When "1", fractions smaller than a second are reset | +------------> When "0", 16[Hz] clock pulse is ON

+-----------------> When "0", 1[Hz] clock pulse is ON





6.6 Setting the Clock and Alarm




* Setting date and time



Block 0 is used to set the clock. Selecting block 0 in the MODE register and writing data in the objective register causes the date and the time to be set. The current time is acquired by reading the contents of the register.

See Figure 5.29 for the meaning of the register and its address.



Block 1 is used to set the alarm. Note that the time of the alarm can be set only in days, hours, and minutes. Nothing happens, in general, when the time of the clock meets the time of the alarm.



In the clock, the year is represented by 2 digits (registers #11 and #12). In MSX-BASIC, the 2 low order digits of the year is represented by adding the offset 80 to this value. For example, after setting register #11 to 0 and register #12 to 0, the year would be 80, as "80/XX/XX", when the date is read by using the GET DATE instruction of BASIC.



The day of the week is represented by 0 to 6. This is only a mod 7 counter which is renewed alomg with the date, and the correspondence between the actual day of the week and the number value 0 to 6 is not defined.



Figure 5.29	Setting the CLOCK and ALARM



block 0 : CLOCK

---------------------------------------------------------

|			 | B3 | B2 |	B1 | B0 |

|---------------------------+---------------------------|

0 | Seconds		 |			 |

| (the 1st decimal place) | X	 X	X X |

|---------------------------+---------------------------|

1 | Seconds		 |			 |

| (the 2nd decimal place) | .	 X	X X |

|---------------------------+---------------------------|

2 | Minutes		 |			 |

| (the 1st decimal place) | X	 X	X X |

|---------------------------+---------------------------|

3 | Minutes		 |			 |

| (the 2nd decimal place) | .	 X	X X |

|---------------------------+---------------------------|

4 | Hours		 |			 |

| (the 1st decimal place) | X	 X	X X |

|---------------------------+---------------------------|

5 | Hours		 |			 |

| (the 2nd decimal place) | .	 .	X X |

|---------------------------+---------------------------|

6 | Day of		 |			 |

| the week		 | .	 X	X X |

|---------------------------+---------------------------|

7 | Day		 |			 |

| (the 1st decimal place) | X	 X	X X |

|---------------------------+---------------------------|

8 | Day		 |			 |

| (the 2nd decimal place) | .	 .	X X |

|---------------------------+---------------------------|

9 | Month		 |			 |

| (the 1st decimal place) | X	 X	X X |

|---------------------------+---------------------------|

10 | Month		 |			 |

| (the 2nd decimal place) | .	 .	. X |

|---------------------------+---------------------------|

11 | Year		 |			 |

| (the 1st decimal place) | X	 X	X X |

|---------------------------+---------------------------|

12 | Year		 |			 |

| (the 2nd decimal place) | X	 X	X X |

---------------------------------------------------------



block 1 : ALARM

---------------------------------------------------------

|			 | B3 | B2 |	B1 | B0 |

|---------------------------+---------------------------|

0 |	 _________________ |			 |

|			 | .	 .	. . |

|---------------------------+---------------------------|

1 |	 _________________ |			 |

|			 | .	 .	. . |

|---------------------------+---------------------------|

2 | Minutes		 |			 |

| (the 1st decimal place) | X	 X	X X |

|---------------------------+---------------------------|

3 | Minutes		 |			 |

| (the 2nd decimal place) | .	 X	X X |

|---------------------------+---------------------------|

4 | Hours		 |			 |

| (the 1st decimal place) | X	 X	X X |

|---------------------------+---------------------------|

5 | Hours		 |			 |

| (the 2nd decimal place) | .	 .	X X |

|---------------------------+---------------------------|

6 | Day of		 |			 |

| the week		 | .	 X	X X |

|---------------------------+---------------------------|

7 | Day		 |			 |

| (the 1st decimal place) | X	 X	X X |

|---------------------------+---------------------------|

8 | Day		 |			 |

| (the 2nd decimal place) | .	 .	X X |

|---------------------------+---------------------------|

9 |	 _________________ |			 |

|			 | .	 .	. . |

|---------------------------+---------------------------|

10 | 12 or		 |			 |

| 24 hours		 | .	 .	. X |

|---------------------------+---------------------------|

11 | Leap year 	 |			 |

| counter		 | .	 .	X X |

|---------------------------+---------------------------|

12 |	 _________________ |			 |

|			 | .	 .	. . |

---------------------------------------------------------



Bits indicated by an "." are always 0 and cannot be modified.



* Selecting 12-hour clock/24-hour clock

Two clocks can be selected; one is a 24-hour clock which represents one o'clock in the afternoon as 13 o'clock, and the other is a 12-hour clock which represents it as 1 p.m. Register #10 is used to select between them. As shown in Figure 5.30, the 12-hour clock is selected when B0 is "0" and the 24-hour clock when B0 is "1".



Figure 5.30	Selecting 12-hour clock/24-hour clock

B3 B2 B1	 B0

---------------------

| . |	. | . | B0 | Register #10 (block 1) ---------------------

|

+--> 0: 12-hour clock





1: 24-hour clock




Figure 5.31	Morning/afternoon flag for 12-hour clock

B3 B2 B1	 B0

---------------------

| . |	. | B1 | X | register #5 (block 0) ---------------------

|

+-------> 0: before noon





1: after noon




* Leap year counter



Register #11 of block 1 is a mod 4 counter which is renewed along with the count of the year. When the 2 low order bits of this register are 00H, that is considered as a leap year and 29 days are counted in February.



Figure 5.32	Leap year determination

B3 B2 B1	 B0

---------------------

| . |	. | B1 | B0 | Register #11 (block 1) ---------------------

|	 |

+----+--> Both bits 0 represents leap year.





6.7 Contents of the Battery-powered Memory




Blocks 2 and 3 of the CLOCK-IC are used as the battery-powered 4-bit x 13

memory blocks. MSX2 uses this area as shown below.



* Contents of block 2



Figure 5.33	Contents of block 2



|	 B3	 |	 B2	 |	 B1 | B0 |

|-------------------------------------------------------------------|

0 |				 ID 			 |

|-------------------------------------------------------------------|

1 |			 Adjust X (-8 to +7) 		 |

|-------------------------------------------------------------------|

2 |			 Adjust Y (-8 to +7) 		 |

|-------------------------------------------------------------------|

3 | __________ |	__________ | Interlace mode | Screen mode |

|-------------------------------------------------------------------|

4 |			 WIDTH value (Lo)			 |

|-------------------------------------------------------------------|

5 |			 WIDTH value (Hi)			 |

|-------------------------------------------------------------------|

6 |			 Foreground color			 |

|-------------------------------------------------------------------|

7 |			 Background color			 |

|-------------------------------------------------------------------|

8 |			 Border color			 |

|-------------------------------------------------------------------|

9 | Cassette speed | Printer mode |	 Key click | Key ON/OFF |

|---------------------------------+---------------------------------|

10 |		BEEP tone	 |		 BEEP volume	 |

|---------------------------------+---------------------------------|

11 | __________ |	__________ |		 Title colour	 |

|-------------------------------------------------------------------|

12 |				Native code			 |

---------------------------------------------------------------------



* Contents of block 3



Block 3 has three functions, depending on the contents of the ID value (register #0). Figure 5.34 shows the functions.



Figure 5.34	Contents of block 3



ID=0: displays the title (within 6 characters) on the initial screen ------------------------------------------------------

0 | 0 						|

|----------------------------------------------------| --+

1 | Lo 1 --+--- 1st character of the title		| |

|	 |						| |

2 | Hi 1 --+						| |

|----------------------------------------------------| |

. |	 .						| |

. |	 .						| | 6 characters

. |	 .						| |

|----------------------------------------------------| |

11 | Lo 6 --+--- 6th character of the title		| |

|	 |						| |

12 | Hi 6 --+						| |

------------------------------------------------------ --+



ID=1: sets the password

------------------------------------------------------

0 | 1 						|

|----------------------------------------------------|

1 | Usage ID=1					|

|							|

2 | Usage ID=2					|

|							|

3 | Usage ID=3					|

|----------------------------------------------------|

4 | Password	--+					|

|		 |					|

5 | Password	 | Password data is stored		|

|		 |-- compressed in 4bits x 4 bits	|

6 | Password	 |					|

|		 |					|

7 | Password	--+					|

|----------------------------------------------------|

8 | Key cartridge flag				|

|----------------------------------------------------|

9 | Key cartridge value				|

|							|

10 | Key cartridge value				|

|							|

11 | Key cartridge value				|

|							|

12 | Key cartridge value				|

------------------------------------------------------



ID=2: sets the prompt on BASIC

------------------------------------------------------

0 | 2 						|

|----------------------------------------------------| --+

1 | Lo 1 --+--- 1st character of the prompt		| |

|	 |						| |

2 | Hi 1 --+						| |

|----------------------------------------------------| |

. |	 .						| |

. |	 .						| | 6 characters

. |	 .						| |

|----------------------------------------------------| |

11 | Lo 6 --+--- 6th character of the prompt		| |

|	 |						| |

12 | Hi 6 --+						| |

------------------------------------------------------ --+





6.8 Access to the CLOCK-IC




The following BIOS routines are offered to access the clock and the battery-powered memory. Since these routines reside in SUB-ROM, they are called by using the inter-slot call.



* REDCLK (015FH/SUB) .................. read CLOCK-IC data

Input:		C <-- CLOCK-IC address (see Figure 5.35) Output: 	A <-- data obtained (only 4 low order bits valid) Function:	reads CLOCK-IC register in the address specified by the C register and stores in the A register. Since the address specification includes the block selection information as shown in Figure 5.35, it is not necessary to set the MODE

register and then read the objective register.



Figure 5.35	CLOCK-IC register specification method

-----------------------------------------

C register	| . |	. | M1 : M0 | A3 : A2 : A1 : A0 |

-----------------------------------------

|	 |			|

+---------+-------------------+

Block to be	 Register selected	 address

* WRTCLK (01F9H/SUB) .................. write CLOCK-IC data

Input:		C <-- CLOCK-IC address (see Figure 5.35) A <-- data to be written (4 low order bits) Output: 	---

Function:	write the contents of the A register in the CLOCK-IC at the address specified by the C register. The address is specified in the format shown in Figure 5.35 as REDCLK.



List 5.10 shows an example of this BIOS routine.



List 5.10 Setting the prompt

=================================================================



;************************************************

;

; List 5.10 set prompt message

;

;************************************************

;

WRTCLK: EQU	01F9H

EXTROM: EQU	015FH



ORG	0B000H



;----- program start -----	;Note:	Set prompt message for BASIC.



START:	LD	C,00110000B	;address data

LD	A,2		;ID := prompt mode CALL	WRTRAM		;write to back-up RAM



LD	B,6		;loop counter LD	HL,STRING	;prompt data L01:	LD	A,(HL)		;read string data

AND	0FH		;A := hi 4 bit INC	C		;increment address CALL	WRTRAM		;write data to back-up RAM

LD	A,(HL)

RRCA

RRCA

RRCA

RRCA

AND	0FH

INC	C		;increment address CALL	WRTRAM		;write low 4 bits INC	HL

DJNZ	L01

RET



;----- write data to back-up RAM -----



WRTRAM: PUSH	HL

PUSH	BC

LD	IX,WRTCLK

CALL	EXTROM		;use interslot call POP	BC

POP	HL

RET



;----- string data -----



STRING: DB	'Ready?'



END



=================================================================





MSX2 TECHNICAL HANDBOOK

-----------------------



Edited by:		ASCII Systems Division

Published by:		ASCII Coprporation - JAPAN

First edition:		March 1987

<i>

Text file typed by:	Nestor Soriano (Konami Man) - SPAIN

October 1997



Changes from the original:



- In description of SUBROM routine, comment "see page 352" has been changed to "see appendix 2..."



- In description of SLTATR and SLTWRK work areas, expressions for calculate the concrete work area for a given slot and page have been added.



- In the first line after beginning of section 7.2.3, "The following routines..." has been corrected to "The following addresses..."



- In Figure 5.52, indication of F380H address was placed in the middle of the user's area. It has been moved to the beginning of system work.

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



CHAPTER 5 - ACCESS TO PERIPHERALS THROUGH BIOS (Part 7)





7. SLOTS AND CARTRIDGES




The CPU (Z80) used in the MSX can access an address space of only 64K bytes (0000H to FFFFH). MSX is set up to access an effective space of 1M bytes.

This is accomplished by using "slots", which allocate more than one memory byte or device to the same address.



This chapter introduces the use of the slot and information necessary to connect the cartridge software or the new device to MSX via the slot.





7.1 Slots




A slot is an interface to effectively use a large address space, and to interface any memory or devices connected to the MSX address bus installed via the slot. The BASIC ROM inside the machine or RAM at MSX-DOS mode are not exceptions. The place at which the cartridge software is installed is also one of the slots. The following descriptions introduce how the software and the devices are connected to the slot.



7.1.1 Basic slot and expansion slot



The slot is either a basic slot or a expansion slot. A "basic slot" is a slot directly connected to the CPU address bus, as shown in Figure 5.36. The standard MSX machine can have up to four basic slots. The basic slot can be expanded up to four slots by connecting a slot expansion box (in some cases, the expansion is already done inside the machine), and is called "expansion slots". When each of four basic slots is expanded to four expansion slots, the maximum number of slots is 16. If you multiply 16 slots x 64K bytes you will get 1M bytes of accessible address space.



Note that the system itself cannot be started when expansion slot boxes are connected to the expansion slot. So the user should only connect expansion slot boxes to the basic slots. (Though the slot for the standard MSX

cartridge is always a basic slot, in some cases the connector for the optional hardware of each machine might be connected to the expansion slot).



Figure 5.36	Basic slot and expansion slot

---------

|	|

| CPU	|

|	|

|	|

---------

|

O

\

\

\

\

O		 O		 O		 O

|		 |		 |		 |

---------	---------	---------	---------

|	|	|	|	|	|	|	|

Basic slot	|	|	|	|	|	|	|	|

|	|	|	|	|	|	|	|

|	|	|	|	|	|	|	|

---------	---------	---------	---------

Slot #0	 O		 Slot #2	 Slot #3

/

/

/

O	 O		 O		 O

|	 |		 |		 |

---------	 --------- --------- ---------

|	 |	 |	 | | | |	 |

Expansion |	 |	 |	 | | | |	 |

slot	 |	 |	 |	 | | | |	 |

|	 |	 |	 | | | |	 |

---------	 --------- --------- ---------

Slot #1-0	 Slot #1-1 Slot #1-2 Slot #1-3



Each slot has 64K bytes from 0000H to FFFFH of address space and MSX manages it by dividing it into four "pages" of 16K bytes each. The CPU can select and access any slot for each page, and, as shown in Figure 5.37, it is possible to select and combine portions of several slots. Note that a pages with a given page number cannot be assigned to a page with a different page number (that is, page n of each slot is also page n to the CPU).



Figure 5.37	Example of the page selection

------- ------- -------	 -------		-------

Page 0	| A | | E | | I |	 | M | <---------->	| A |

|-----| |-----| |-----|	 |-----|		|-----|

Page 1	| B | | F | | J |	 | N | <---------->	| J |

|-----| |-----| |-----|	 |-----|		|-----|

Page 2	| C | | G | | K |	 | O | <---------->	| G |

|-----| |-----| |-----|	 |-----|		|-----|

Page 3	| D | | H | | L |	 | P | <---------->	| H |

------- ------- -------	 -------		-------

Slot 0 Slot 1 Slot 2	 Slot 3	 CPU address space



7.1.2 Selecting slots



Selecting slots is different for the basic slot than for the expansion slot.

For basic slots, it is done through the I/O port at A8H (see Figure 5.38), and for expansion slots, it is done through the "expansion slot selection register (FFFFH)" of the installed expansion slot (see Figure 5.39). It is not recommended to change them directly, so the user should not switch the slots without careful planning. When the program switches the slot of the page in which it resides, the action is not always predictable. To call the program in another slot, use the inter-slot call described in the next section.



Figure 5.38	Selecting the basic slot

I/O port (A8H)

-----------------------------------------

| :	 | : |	 : | :	|

-----------------------------------------

|	 |	 |	 | 	|

+---------+---------+---------+---------+

|	 |	 |	 |

|	 |	 |	 +---> Basic slot number of page 0 (0 to 3) |	 |	 +-------------> Basic slot number of page 1 (0 to 3) |	 +-----------------------> Basic slot number of page 2 (0 to 3) +---------------------------------> Basic slot number of page 3 (0 to 3)

Figure 5.39	Selecting the expansion slot

Expansion slot selection (FFFFH in expansion slot) -----------------------------------------

| :	 | : |	 : | :	|

-----------------------------------------

|	 |	 |	 | 	|

+---------+---------+---------+---------+

|	 |	 |	 |

|	 |	 |	 +---> Expn. slot number of page 0 (0 to 3) |	 |	 +-------------> Expn. slot number of page 1 (0 to 3) |	 +-----------------------> Expn. slot number of page 2 (0 to 3) +---------------------------------> Expn. slot number of page 3 (0 to 3)

Note: to identify the kind of slot, in the case of the expansion slot, the value written is read as the reversed value. The value of this register is the same inside the basic slot.



The slot where MAIN-ROM or RAM is installed and the slot number of the slot for the cartridge depend on the machine. Refer to the appropriate manual to see how slots are used on your MSX. But the MSX standard guarantees the normal operation no matter what is in the slots, so it is not necessary to worry about the slot use, as long as you are following the standard.



In some cases, however, it is required to know the slot number of the specified software. For example, in the previous version, BASIC MAIN-ROM was placed in basic slot #0 or in expansion slot #0-0 when basic slot #0 was expanded. So when MSX1 is upgraded to have the MSX2 functions by installing MSX-VIDEO and BASIC ver 2.0 ROM, the MAIN ROM should be placed somewhere other than slot #0 or slot #0-0. The slot where MSX2 SUB-ROM resides depends on the machine, but the information about the slot where BASIC interpreter ROM resides can be obtained by referring to the work area described below (the slot information can be obtained in the format shown in Figure 5.40).

When calling BIOS from DOS, examine the slot of MAIN-ROM in this way.



* EXPTBL (FCC1H, 1)	the slot of MAIN-ROM

* EXBRSA (FAF8H, 1)	the slot of SUB-ROM (0 for MSX1)

Figure 5.40	Format for the slot

MSB				 LSB

7	6 5	 4 3 2	 1 0

-----------------------------------------

| |	 : : |	 : | :	|

-----------------------------------------

| |		 |	 | 	|

+----+--------------+---------+---------+

|	 Unused	 |	 |

|			 |	 +---> Basic slot number (0 to 3) |			 +-------------> Expansion slot number (0 to 3) |

+------------------------------------> "1" if expansion slot

When a given routine resides over page 1 and page 2 (4000H to BFFFH), the same slot for page 2 as the one for page 1 should be selected when the jump from page 1 to page 2 occurs within this routine. To do this, you need to examine the slot, in page 1, where the program resides and then to switch page 2 to that slot. To obtain information about the slot where the program currently is, execute the program shown in List 5.11.



List 5.11 Program to know the current slot =================================================================



;********************************************************

; List 5.11 to know where you are

;********************************************************

;	Suppose your program cartridge is 32K bytes ;	long (4000h..0BFFFH). You set the ID at 4000H

;	and 4001H and the execution start address within ;	page 1 (4000h..7FFFH), MSX passes control ;	to this address so the part which resides in ;	page 2 is not yet enabled at this point. You ;	have to know where you are (in what primary ;	slot, in what secondary slot) and enable the ;	part at page 2. Below is the sample program ;	to do this.

;

ENASLT	EQU	0024H		;enable slot

RSLREG	EQU	0138H		;read primary slot select register EXPTBL	EQU	0FCC1H		;slot is expanded or not

;----- program start -----



ENAP2:

CALL	RSLREG		;read primary slot #

RRCA			;move it to bit 0,1 of [Acc]

RRCA

AND	00000011B

LD	C,A

LD	B,0

LD	HL,EXPTBL	;see if this slot is expanded or not ADD	HL,BC

LD	C,A		;save primary slot #

LD	A,(HL)		;See if the slot is expanded or not AND	80H

OR	C		;set MSB if so LD	C,A		;save it to [C]

INC	HL		;Point to SLTTBL entry INC	HL

INC	HL

INC	HL

LD	A,(HL)		;Get what is currently output ;to expansion slot register AND	00001100B

OR	C		;Finally form slot address LD	H,80H

JP	ENASLT		;enable page 2



END



=================================================================



7.2 Inter-slot Calls (calls between slots)

As described above, programs reside in different slots, so a program not in the current slot might be needed in some cases. The most common cases are listed below:



(1) calling BIOS in MAIN-ROM from MSX-DOS level (2) calling BIOS in SUB-ROM from BASIC level (only the case of MSX2) (3) calling BIOS in MAIN-ROM or SUB-ROM from cartridge software

In doing such calls, to switch slots easily and safely, there is a group of BIOS routines called the inter-slot calls, which can be called from the routine in any slot. This section describes the use of the inter-slot calls.



7.2.1 Inter-slot call operation



When calling BIOS in MAIN-ROM from MSX-DOS, the state of slots changes as described below.



(1) Since, in the initial MSX-DOS mode, RAM is selected all over 64K address space, BASIC-ROM cannot be accessible in this state (see Figure 5.41-a).



(2) To call BIOS in ROM, switch page 0 to MAIN-ROM or BASIC to access. Then, call BIOS (see Figure 5.41-b).



(3) Restore the original status after BIOS operations and return to the initial address.



Figure 5.41	Inter-slot call

a) When using MSX-DOS



MSX-DOS BASIC-ROM			 MSX-DOS BASIC-ROM

------- -------			 ------- -------

Page 0	| RAM | | ROM |		 Page 0 | RAM | | ROM | BIOS is |-----| |-----|			 |-----| |-----| called Page 1	| RAM | | ROM |		 Page 1 | RAM | | ROM |

|-----| |-----| <---------->	 |-----| |-----|

Page 2	| RAM | | ___ |		 Page 2 | RAM | | ___ |

|-----| |-----|			 |-----| |-----|

Page 3	| RAM | | ___ |		 Page 3 | RAM | | ___ |

------- -------			 ------- -------

Slot 3 Slot 0			 Slot 3 Slot 0



This is easily done when the program resides in other than page 0, but there can be some problem when the calling program resides in page 0 which is the same page as BIOS of the called program. Care is needed to prevent the program from disappearing itself and generating unpredictable results when it is switched to page 0. The inter-slot call settles this problem by jumping to page 3 temporarily and then switching slots.



7.2.2 Inter-slot call use



There are several ways to execute inter-slot calls, as described below. They are included in MAIN-ROM as BIOS calls. Some of them are offered in MSX-DOS, so inter-slot calls can be executed under MSX-DOS.



(1) Inter-slot call routines in BIOS



* RDSLT (000CH/MAIN) .................. read value at specified address of specified slot



Input:		A register <-- slot specification HL register <-- address to be read at Output: 	A register <-- value which has been read out Use:		AF, BC, DE

Function:	reads the value at the specified address of the specified slot and stores it in the A register. The slot specification is done using the A register in the form shown in Figure 5.40. At this point, when the objective slot is the basic slot, set "0" to the 6 high order bits and define the slot #0 to #3 using the 2 low order bits. When specifying the expansion slot, specify the basic slot by bit 0 and bit 1 and the expansion slot by bit 2 and bit 3 and set bit 7 to "1".



* WRSLT (0014H/MAIN) .................. write value at specified address of specified slot



Input:		A register <-- slot specification (same format as in Figure 5.40)

HL register <-- address to be written in E register <-- data to be written Output: 	---

Use:		AF, BC, D

Function:	writes E register value in the address specified by HL

register of the slot specified by the A register (the specification format is the same as in Figure 5.40).



* CALSLT (001CH/MAIN) ................. call specified address of specified slot



Input:		8 high order bits of IY register <-- slot (same format as in Figure 5.40) IX register <-- address to be called Output: 	depends on the result of the called program Use:		depends on the result of the called program Function:	calls the routine at the address specified by IX register of the slot specified by the 8 high order bits of IY register (the specification format is the same as in Figure 5.40).



* ENASLT (0024H/MAIN) ................. swicth slots

Input:		A register <-- slot (same format as in Figure 5.40) HL register <-- specifies the page to switch the slot by 2 high order bits Output: 	---

Use:		all

Function:	switches the page specified by the 2 high order bits of the HL register to the slot specified by the A register.



* CALLF (0030H/MAIN) .................. call specified address of specified slot



Input:		specifies the slot and the address in the inline parameter format

Output: 	depends on the result of the called program Use:		depends on the result of the called program Function:	calls the specified address of the specified slot, but, different from CALSLT described above, the slot and the address is specified in the inline parameter format, as described below. That is, parameters are passet by one byte (same format as RDSLT) to specify that the slot is placed just after the instruction which calls CALLF and the next two bytes to specify the address are placed. "CALL 0030H"

may be replaced by the RST (restart) instruction, "RST 30H".

In this case, the inter-slot call is done in 4 bytes.



Figure 5.42	Example of the inter-slot call execution

-----------------------------------------------------------------

|								|

|	RST	30H		;interslot call 		|

|	DB	00000000B	;select slot#0			|

|	DW	006CH		;call address = 006CH		|

|								|

-----------------------------------------------------------------



* RSLREG (0138H/MAIN) ................. read the basic slot selection register



Input:		---

Output: 	A register <-- value which has been read Use:		---

Function:	reads the contents of the basic slot selection register and stores it in the A register.



* WSLREG (013BH/MAIN) ................. write in the basic slot selection register



Input:		A register <-- value to be written Output: 	---

Use:		---

Function:	writes the A register value in the basic slot selection register and selects the slot.



* SUBROM (015CH/MAIN) ................. call specified address in SUB-ROM



Input:		IX register <-- address to be called, PUSH IX

(see Appendix 2, SUB-ROM list) Output: 	depends on the result of the called program Use:		background register and IX, IY registers are reserved Function:	This is the routine to call BASIC SUB-ROM especially. The slot where SUB-ROM resides is automatically examined.

Normally, EXTROM, described below, is used.



* EXTROM (015FH/MAIN) ................. call specified address in SUB-ROM



Input:		IX register <-- address to be called Output: 	depends on the result of the called program Use:		background register and IY register are reserved Function:	This is the routine to call BASIC SUB-ROM. The difference between this and SUB-ROM above is the point whether the IX register value is pushed.



(2) Inter-slot call in MSX-DOS



In MSX-DOS, five kinds of inter-slot calls are offered and their entry addresses are defined at jump vectors of MSX-DOS. These are the same as ones in BIOS, so refer to BIOS above for their functions or use. Note that these routines should not be used when calling routines in SUB-ROM from MSX-DOS.



* RDSLT (000CH) ....... read value at specified address of specified slot * WRSLT (0014H) ....... write value at specified address of specified slot * CALSLT (001CH) ...... call specified address of specified slot * ENASLT (0024H) ...... make specified slot available * CALLF (0030H) ....... call specified address of specified slot

List 5.12 Calling BIOS from MSX-DOS

=================================================================



;********************************************************

; List 5.12	How to use BIOS from MSX-DOS.

;********************************************************

;

CALSLT	EQU	001CH		;Inter slot call

EXBRSA	EQU	0FAF0H		;Slot address of BIOS (main) ROM

EXPTBL	EQU	0FCC1H		;Slot address of extended ROM

;

;	LD	IY,(EXPTBL-1)	;Load slot address of the BIOS ROM

;				;in high byte of IY

;	LD	IX,address of the BIOS jump table

;	CALL	CALSLT

;

;----- Sample program to set text mode -----



INITXT	EQU	006CH

LINL40	EQU	0F3AEH

;

TOTEXT: LD	B,40

LD	A,(EXBRSA)	;slot address of SUB-ROM

OR	A		;0 if MSX1

JR	Z,TO40

LD	B,80



TO40:	LD	(LINL40),B	;set width into work area LD	IX,INITXT

LD	IY,(EXPTBL-1)	;get expanded slot status to IYH

CALL	CALSLT		;perform an inter-slot call EI			;because CALSLT do DI RET



END



=================================================================



7.2.3 Work area to obtain the slot status

The following addresses involve the slot work area.



* EXBRSA (FAF8H, 1) ........... SUB-ROM slot

Figure 5.43 SUB-ROM slot

MSB				 LSB

7	6 5	 4 3 2	 1 0

-----------------------------------------

| |	 : : |	 : | :	|

-----------------------------------------

| |		 |	 | 	|

+----+--------------+---------+---------+

|	 Unused	 |	 |

|			 |	 +---> Basic slot number (0 to 3) |			 +-------------> Expansion slot number (0 to 3) |

+------------------------------------> "1" if expansion slot

* EXPTBL (FCC1H, 4) ........... whether the basic slot is expanded or not

Figure 5.44	Selecting the basic slot

MSB				 LSB

7	 6 5 4	3 2	 1 0

-----------------------------------------

[FCC1H] | | :	: |	 : | :	 | MAIN-ROM slot -----------------------------------------



-----------------------------------------

[FCC2H] | | 	 Unused		 | Slot #1

-----------------------------------------



-----------------------------------------

[FCC3H] | | 	 Unused		 | Slot #2

-----------------------------------------



-----------------------------------------

[FCC4H] | | 	 Unused		 | Slot #3

-----------------------------------------

|

+--> 0: slot is not expanded





1: slot is expanded




* SLTTBL (FCC5H, 4) ........... preservation area for the expansion slot selection register value

Figure 5.45	Selecting the expansion slot

MSB				 LSB

7	 6 5 4	3 2	 1 0

----------------------------------------- expansion slot selection [FCC5H] | : |	: |	 : | :	 | register value of slot #0

-----------------------------------------



----------------------------------------- expansion slot selection [FCC6H] | : |	: |	 : | :	 | register value of slot #1

-----------------------------------------



----------------------------------------- expansion slot selection [FCC7H] | : |	: |	 : | :	 | register value of slot #2

-----------------------------------------



----------------------------------------- expansion slot selection [FCC8H] | : |	: |	 : | :	 | register value of slot #3

-----------------------------------------

|	 |	 |	 |	 |

+---------+---------+---------+---------+

| 	|	 |	 |

| 	|	 |	 +----> exp. slot num. for page 0

| 	|	 +--------------> exp. slot num. for page 1

| ------------------------> exp. slot num. for page 2

+----------------------------------> exp. slot num. for page 3



* SLTATR (FCC9H, 64) .......... test for existance of application in each slot/page



Figure 5.46	Test for existence of application

-----------------------------------------

[FCC9H] | | |	|	 Unused	 | Slot #0-0, page 0

|----+----+----+------------------------|

[FCCAH] | | |	|	 Unused	 | Slot #0-0, page 1

|----+----+----+------------------------|

| | |	|			 |

.	 .	. .

.	 .	. .

.	 .	. .

| | |	|			 |

|----+----+----+------------------------|

[FD08H] | | |	|	 Unused	 | Slot #3-3, page 3

-----------------------------------------

|	| |

|	| +--> Routine to process expanded statements 1:yes 0:no | -------> Routine to process expansion device	 1:yes 0:no +------------> BASIC text				 1:yes 0:no

The concrete work area for a given slot and page can be obtained with the following expression:



SLTATR address = FCC9H + 16*basic slot + 4*expansion slot + page

* SLTWRK (FD09H, 128) ......... work area for application

Figure 5.47	Work area for application

----------------------------------------- Work area for [FD09H] | ................................... | slot 0-0 page 0

|---------------------------------------|

[FD0BH] | ................................... | Work area for |---------------------------------------| slot 0-0 page 1

|					 |

.	 .					 .

.	 .					 .

.	 .					 .

|					 |

|---------------------------------------| Work area for [FD87H] | ................................... | slot 3-3 page 3

-----------------------------------------



The concrete work area for a given slot and page can be obtained with the following expression:



SLTWRK address = FD09H + 32*basic slot + 8*expansion slot + 2*page





7.3 Developing Cartridge Software




MSX machines usually have at least one external slot and the hardware to be put there is called a "cartridge". There are cartridges such as the ROM

cartridges for application programs or games, input-output device cartridges for a disk or RS-232 interface, RAM expansion cartridges for expanding RAM, and slot expansion cartridges for expanding slots. These cartridges make the MSX easy to upgrade. BASIC and assembly language programs can also be stored in ROM cartridge easily. This section describes how to develop cartridge software.



7.3.1 Catridge header



MSX cartridges have a 16-bye common header and, when the system is reset, the cartridge is initialised by the information written in this header. For ROM

cartridges of BASIC or assembly language programs, they can be automatically started by using the information written in the header. Figure 5.48 shows the cartridge header configuration.



Figure 5.48	Program cartridge header

------------------- 4000H or 8000H

+0000H	|	ID	 |

|-----------------|

+0002H	| INIT	 |

|-----------------|

+0004H	| STATEMENT	 |

|-----------------|

+0006H	| DEVICE	 |

|-----------------|

+0008H	| TEXT	 |

|-----------------|

+000AH	|		 |

|		 |

| Reserved	 | Note: Reserved area should |		 |	 be filled with 00H.

|		 |

+0010H	-------------------



* ID



In the case of ROM cartridges, these two bytes have codes "AB" (41H, 42H).

For SUB-ROM cartridges, the ID is "CD".



* INIT



When the cartridge is made to initialise the work area or I/O, these two bytes are the addresses for the initialization routine; otherwise 0000H is assumed. After instructions such as getting the work area in the initialization routine are placed, end with "RET". All registers except the SP register may be destroyed. For assembly language programs, such as games, which loop within the cartridge, it is possible to execute the object program from here.



* STATEMENT



When the cartridge is made to expand the CALL statement, these two bytes are the address for the statement expansion routine; otherwise 0000H is assumed.

If so, the statement expansion routine should reside at 4000H to 7FFFH.



The CALL statement is described in the following format:

CALL <expression statement name> [(<argument>[, <argument>...])]



The expression statement name can have up to 15 characters. As an abbreviation for CALL, "_" (underscore) is available.



When the BASIC interpreter finds a CALL statement, it puts the expansion statement name in PROCNM (FD89H, 16) in the work area and passes the control to cartridges, whose contents of STATEMENT of the header is other than 0, in the order from the one with the smaller slot number. The HL register points to the text address next to the expansion statement name at this point (see Figure 5.49a).



Figure 5.49	Input-output of the operation routine of the expansion statement



---------------------------------------------------------------------

|									|

a) | Input setup when the interpreter calls routines to process	|

| expanded statements						|

|									|

| CALL ABCDE(0,0,0):A=0						|

|		 ^							|

|		 |							|

|		 HL							|

|									|

| CY flag = 1				 +---- End of the name	|

|						 | of the expanded	|

|		------------------------------------- statement	|

|	PROCNM	| A | B | C | D	| E | 00H |			|

|		-------------------------------------			|

|									|

|-------------------------------------------------------------------|

|									|

b) | Output setup when the expanded statement was not processed	|

|									|

| CALL ABCDE(0,0,0):A=0						|

|		 ^							|

|		 |							|

|		 HL							|

|									|

| CY flag = 1							|

|									|

|-------------------------------------------------------------------|

|									|

c) | Output setup when the expanded statement was processed		|

|									|

| CALL ABCDE(0,0,0):A=0						|

|			^						|

|			|						|

|			HL						|

|									|

| CY flag = 0							|

|									|

---------------------------------------------------------------------



To develop the statement expansion routine, recognise the name of the expansion statement written in PROCNM first, then return with setting "1" to the carry flag without modifying the HL register if the statement is not to be handled (see Figure 5.49b); otherwise, handle it properly and set the HL

register (text pointer) to the next handled statement (where 00H or 3AH is placed usually), then return after setting "0" to the carry flag (see Figure 5.49c).



The BASIC interpreter determines the status of the carry flag whether a CALL

statement has been executed, and, if not, calls the next cartridge. When all cartridges have not executed the statement (when the carry flag has been "1"

all the time), it displays "SYNTAX ERROR". To test arguments of the statement, it is convenient to use "internal routines for the statement expansion" in section 4.4 of chapter 2.



* DEVICE



These two bytes are the addresses of the device expansion routine, when the cartridge does the device expansion (the input-output device expansion); otherwise 0000H is used. When doing the device expansion, the device expansion routine should be in 4000H-7FFFH. One cartridge can have up to 4

devices. The name of the expansion device should be less than 16 characters.



When the BASIC interpreter finds an undefined device, it stores that in PROCNM (FD89H, 16) and put FFH in the A register and passes control to the cartridge whose contents is not 0 in the order from the one with the smaller slot number (see Figure 5.50a).



When creating device expansion routines, identify the file descriptor of PROCNM first, and, when it is not for the device to be processed, return with setting 1 to the carry flag (see Figure 5.50b). Otherwise, process it and set the device ID (0-3) in the A register, then return with setting 0 to the carry flag (see Figure 5.50c).



The BASIC interpreter determines by the status of the carry flag whether or not it is processed, and, if not, call the next cartridge. When all cartridges were not processed (that is, when the carry flag was "1" all the time), "Bad file name ERROR" is displayed.



When the actual input-output operations are done, the BASIC interpreter sets the device ID (0-3) in DEVICE (FD99H) and sets the request to the device in the A register (see Table 5.6), then calls the device expansion routine. The device expansion routine should refer to it to handle the request.



Figure 5.50	Input-output to the device expansion routine

---------------------------------------------------------------------

|									|

a) | Input setup when the interpreter calls routines to process	|

| the expanded device						|

|									|

| OPEN "ABC:"... |

|									|

| A register = FFH 						|

| CY flag = 1		 +---- End of the file descriptor	|

|				 |					|

|		-------------------------				|

|	PROCNM	| A | B | C | 00H |				|

|		-------------------------				|

|									|

|-------------------------------------------------------------------|

|									|

b) | Output setup when the expanded device was not processed		|

|									|

| CY flag = 1							|

|									|

|-------------------------------------------------------------------|

|									|

c) | Output setup when the expanded device was processed		|

|									|

| A register = device ID (0 to 3)					|

| CY flag = 0							|

|									|

---------------------------------------------------------------------



Table 5.6 Requests to the device

--------------------------------------

| Register A | Request	 |

|--------------+---------------------|

|	0 | OPEN		 |

|--------------+---------------------|

|	2 | CLOSE 	 |

|--------------+---------------------|

|	4 | Random access |

|--------------+---------------------|

|	6 | Sequential output |

|--------------+---------------------|

|	8 | Sequential input |

|--------------+---------------------|

| 10 | LOC function	 |

|--------------+---------------------|

| 12 | LOF function	 |

|--------------+---------------------|

| 14 | EOF function	 |

|--------------+---------------------|

| 16 | FPOS function |

|--------------+---------------------|

| 18 | Backup character |

--------------------------------------



* TEXT



These two bytes are text pointers of the BASIC program, when the BASIC

program in the cartridge would be auto-started (executed at reset); otherwise they are 0000H. The size of the program must be under 16K bytes, 8000H to BFFFH.



The BASIC interpreter examines the contents of TEXT of the header after the initialization (INIT) and after the system is started. When they are not 0000H, it begins the execution from the address as BASIC text pointer (see Figure 5.51). BASIC programs should be stored in the form of the intermediate code and the beginning of it (the address pointed by TEXT) must be 00H, which indicates the beginning of the program.



The execution speed of the program will be improved when the objective line number of statements such as GOTO is the absolute address of the objective text pointer.



Figure 5.51	Executing BASIC program cartridge

---------------------

|		 | 8000H

|-------------------|

|	TEXT	 |----+

|-------------------|	 |

|		 |	 |

|		 |	 |

|-------------------|<---+

|		 |

| BASIC program | The first byte must be 00H

|		 |

|-------------------|

|		 |

|		 |

|		 |

--------------------- BFFFH



* How to place BASIC programs in ROM



1. Change the starting address of BASIC text to 8021H.



POKE &HF676,&H21 : POKE &HF677,&H80 : POKE &H8020,0 : NEW



Note: these statements must be in one line

2. Load the objective BASIC program.



LOAD "PROGRAM"



3. Create ID.



AD = &H8000

FOR I = 0 TO 31 ----+

POKE AD + I, 0 | clears ID area NEXT I		 ----+

POKE &H8000,ASC("A") POKE &H8001,ASC("B") POKE &H8008,&H20

POKE &H8009,&H80



4. Put 8000H to BFFFH in ROM.



7.3.2 notes on the creation of the cartridge software

In programs not requiring software from other cartridges (stand-alone software such as games), the portion with the smaller address than the work area used by BIOS (F380H) can be used freely.



But in programs which are executed by using BASIC interpreter functions, the same area cannot be shared as the work area. To do this, there are three methods:



(1) Place RAM on the cartridge itself (the safest and most reliable method).



(2) When one or two bytes are needed for the work area, use two bytes corresponding to itself in SLTWRK (FD09H to ...) as the work area.



(3) When more than three bytes are needed for the work area, allocates it from RAM used by BASIC. To do this, put the contents of BOTTOM (FC48H) to the area corresponding to SLTWRK (FD09H to ...), and increase the value of BOTTOM by the needed work area, then allocate it for the work area (see figure 5.52).



Figure 5.52	Allocating the work area

8000H	----------------- <-- (BOTTOM)	 ----------------- <-- (SLTWRK) |		|		 | Work area |

|		|		 |---------------| <-- (BOTTOM) | User's area | | |

|		|	--->	 | User's area |

|		|		 |		 |

F380H	|---------------|		 |---------------|

| System work	|		 | System work |

FFFFH	-----------------		 -----------------



See the following list for the reference of (2) and (3).



List 5.13 Example of allocating the work area =================================================================



;********************************************************

; List 5.13 subroutines to support slot ;	 for ROM in 1 page

;********************************************************



RSLGREG EQU	0138H

EXPTBL	EQU	0FCC1H

BOTTOM	EQU	0FC48H

HIMEM	EQU	0FC4AH

SLTWRK	EQU	0FD09H



;--------------------------------------------------------

;

;	GTSL1	Get slot number of designated page ;	Entry	None

;	Return	A	Slot address as follows

;	Modify	Flags

;

;	 FxxxSSPP

;	 |	||||

;	 |	||++-- primary slot # (0-3)

;	 | +---- secondary slot # (0-3)

;	 |	 00 if not expanded

;	 +--------- 1 if secondary slot # specified ;

;	This value can later be used as an input parameter ;	for the RDSLT, WRSLT, CALSLT, ENASLT and 'RST 10H'

;

PUBLIC	GTSL10

GETSL10:

PUSH	HL		;Save registers PUSH	DE



CALL	RSLREG		;read primary slot #

RRCA

RRCA

AND	11B		;[A]=000000PP

LD	E,A

LD	D,0		;[DE]=000000PP

LD	HL,EXPTBL

ADD	HL,DE		:[HL]=EXPTBL+000000PP

LD	E,A		;[E]=000000PP

LD	A,(HL)		;A=(EXPTBL+000000PP) AND	80H		;Use only MSB

JR	Z,GTSL1NOEXP

OR	E		;[A]=F00000PP

LD	E,A		;save primary slot number INC	HL		;point to SLTTBL entry INC	HL

INC	HL

INC	HL

LD	A,(HL)		;get current expansion slot register RRCA

RRCA

AND	11B		;[A] = 000000SS

RLCA

RLCA			;[A] = 0000SS00

OR	E		;[A] = F000SSPP

;

GTSL1END:

POP	DE

POP	HL

RET

GTSL1NOEXP:

LD	A,E		;[A] = 000000PP

JR	GTSL1END



;--------------------------------------------------------

;

;	ASLW1	Get address of slot work

;	Entry	None

;	Return	HL	address of slot work

;	Modify	None

;

PUBLIC	ASLW10

ASLW10:

PUSH	DE

PUSH	AF

CALL	GTSL10		;[A] = F000SSPP, SS = 00 if not expanded AND	00001111B	;[A] = 0000SSPP

LD	L,A		:[A] = 0000SSPP

RLCA

RLCA

RLCA

RLCA			;[A] = SSPP0000

AND	00110000B	;[A] = 00PP0000

OR	L		;[A] = 00PPSSPP

AND	00111100B	;[A] = 00PPSS00

OR	01B		;[A] = 00PPSSBB

;

;	Now, we have the sequence number for this cartridge ;	as follows.

;

;	00PPSSBB

;	 ||||||

;	 ||||++-- higher 2 bits of memory address (1) ;	 ||++---- seconday slot # (0..3)

;	 ++------ primary slot # (0..3)

;

RLCA			;*=2

LD	E,A

LD	D,0		;[DE] = 0PPSSBB0

LD	HL,SLTWRK

ADD	HL,DE

POP	AF

POP	DE

RET



;--------------------------------------------------------

;

;	RSLW1	Read slot work

;	Entry	None

;	Return	HL	Content of slot work

;	Modify	None

;

PUBLIC	RSLW10

RSLW10:

PUSH	DE

CALL	ASLW10		;[HL] = address of slot work LD	E,(HL)

INC	HL

LD	D,(HL)		;[DE] = (slot work) EX	DE,HL		;[HL] = (slot work) POP	DE

RET



;--------------------------------------------------------

;

;	WSLW1	Write slot work

;	Entry	HL	Data to write

;	Return	None

;	Modify	None

;

PUBLIC	WSLW10

WSLW10:

PUSH	DE

EX	DE,HL		;[DE] = data to write CALL	ASLW10		;[HL] = address of slot work LD	(HL),E

INC	HL

LD	(HL),D

EX	DE,HL		;[HL] = data tow write POP	DE

RET



;--------------------------------------------------------

;

; How to allocate work area for cartridges ; If the work area is greater than 2 bytes, make the SLTWRK point ; to the system variable BOTTOM (0FC48H), then update it by the ; amount of memory required. BOTTOM is set up by the initizalization ; code to point to the bottom of equipped RAM.

;

;	 Ex, if the program is at 4000H..7FFFH.

;

;	WORKB	allocate work area from BOTTOM

;		(my slot work) <- (old BOTTOM)

;	Entry	HL	required memory size

;	Return	HL	start address of my work area = old BOTTOM

;			0 if cannot allocate

;	Modify	None

;

PUBLIC	WORKB0

WORKB0:

PUSH	DE

PUSH	BC

PUSH	AF



EX	DE,HL		;[DE] = Size LD	HL,(BOTTOM)	;Get current RAM bottom CALL	WSLW10		;Save BOTTOM to slot work PUSH	HL		;Save old BOTTOM

ADD	HL,DE		;[HL] = (BOTTOM) + SIZE

LD	A,H		;Beyond 0DFFFH?

CP	0E0H

JR	NC,NOROOM	;Yes, cannot allocate this much LD	(BOTTOM),HL	;Updtae (BOTTOM) POP	HL		;[HL] = old BOTTOM

WORKBEND:

POP	AF

POP	BC

POP	DE

RET

;

;	BOTTOM became greater than 0DFFFH, there is ;	no RAM to be allocated.

;

NOROOM:

LD	HL,0

CALL	WSLW10		;Clear slot work JR	WORKBEND	;Return 0 in [HL]



END



=================================================================



* Hook



The area called "hook" is used for expanding BASIC functions in FD9AH to FFC9H of the work area used by MSX-BASIC. One hook has five bytes, which are normally "RET".



When MSX-BASIC does a certain operation (such as the one in the description about the hook of the work area), it calls this hook from there once. When the hook is "RET", the control returns immediately; but the function of BASIC

can be expanded, when these five bytes were re-written to do the inter-slot call to the program inside the cartridge by the initialization routine (INIT) (see Figure 5.53).



List 5.14 shows an example of the program that the cartridge uses to hook H.KEYI for the timer interrupt ptocess.



Figure 5.53	Setting the hook

BASIC internal routine	 HOOK -----------------

.	 -----> | RET	|

.		| +--- |---------------|

.		| |	| RET	|

CALL HOOK ------+ |	|---------------|

.	 <--------+	| RET	|

.			|---------------|

.			| RET	|

|---------------|

| RET	|

-----------------



|

V

Interslot call

BASIC internal routine	 HOOK ----------------- -----> .

.	 -----> | RST 30H	|	 .

.		|	|---------------|	 .

.		|	| Slot number	| Expanded process CALL HOOK ------+	|---------------|	 .

.	 <-----+	| Branch	|	 .

.		|	|- address -|	 .

.		|	|		|	 .

|	|---------------|	 .

+------ | RET	| <---- RET

-----------------



List 5.14 Using the hook

=================================================================



;********************************************************

; List 5.14 Sample program to use HOOK

;********************************************************

;

; Start-up initialize entry

; This program will be called when system initializing.

;

H.KEYI	EQU	0FD9AH		; interrupt hook

EXPTBL	EQU	0FCC1H		; slots expanded or not PSLTRG	EQU	0A8H		; I/O port address of primary slot register EXT	MYINT



INIT:

;	<<< Please insert other initialization routine here, if you need. >>>

; Set interrupt entry



DI			; start of critical region

; Get old interrupt entry inter-slot call hook

LD	DE,OLDINT	; get address of old int. hook saved area LD	HL,H.KEYI	; get address of interrupt entry hook LD	BC,5		; lenght of hook is 5 bytes LDIR			; transfer

; Which slot address is this cartridge placed?



CALL	GETMSLT 	; get my slot address

; Set new inter-slot call of interrupt entry

LD	(H.KEYI+1),A	; set slot address LD	A,0F7H		; 'RST 30H' inter-slot call operation code LD	(H.KEYI),A	; set new hook op-code LD	HL,INTENT	; get our interrupt entry point LD	(H.KEYI+2),HL	; set new interrupt entry point LD	A,0C9H		; 'RET' operation code LD	(H.KEYI+4),A	; set operation code of 'RET'

EI			; end of critical region RET



;--------------------------------------------------------

; Which slot address is the cartridge placed?

; Entry: No

; Action: Compute my slot address

; Return: A = slot address

; Modify: Flag



GTMSLT:

PUSH	BC		; save environment PUSH	HL

IN	A,(PSLTRG)	; read primary slot register RRCA			; move it to bit 0,1 of A RRCA

AND	00000011B	; get bit 1,0

LD	C,A		; set primary slot No.

LD	B,0

LD	HL,EXPTBL	; see if the slot is expanded or not ADD	HL,BC

OR	(HL)		; set MSB if so LD	C,A

INC	HL		; point to SLTTBL entry INC	HL

INC	HL

INC	HL

LD	A,(HL)		; get what is currently output to ; expansion slot register

AND	00001100B	; get bits 3,2

OR	C		; finally form slot address

POP	HL		; restore environment POP	BC

RET			; return to main

;----- Interrupt entry -----



INTENT:

CALL	MYINT		; call interrupt handler JP	OLDINT		; go to old interrupt handler

;----- HOOK save area -----



OLDINT: DS	5



END



=================================================================



* Stack pointer initialisation



When MSX has an internal disk, sometimes the disk interface ROM does the initialisation before the cartridge does, depending on the slot location, and pushes down the stack pointer in the direction of the low order address to allocate the work area. In this case, software not using the disk should set the stack pointer again after the cartridge received control; otherwise, the stack area might be exhausted and a system crash might occur. Remember to initialise the stack pointer at the beginning of the program.



* Testing the preformance of the expansion slot

When general software in the market is put in the expansion slot or when RAM

resides in the expansion slot, sometimes the application program do not work.

Since most MSX2 machines use the expansion slot inside, problems may sometime result. Software to be sold in the market should be thoroughly tested in both cases that it is put in the expansion slot and that RAM resides in expansion slot.



Since the expansion slot register is placed in FFFFH, do not use it as if it were RAM. For example, setting the stack in FFFFH using "LD SP, 0" in the program causes machines using the expansion slot to go out of control.



* Notes on CALSLT use



Executing the inter-slot call in CALSLT and CALLF destroys the contents of IX, IY, and the background processing register. When returning from this routine, in MSX1 the interrupt is inhibited, but in MSX2 the state before the call is restored.



When using CALSLT or CALLF to execute the inter-slot call, the interrupt is always inhibited when calling the object program (see 2 in the figure below) and when returning to the calling program (see 6 below).



Caller		Interslot call		 Called

LD IY,SLOT			 (3)

+-----------------> CALLME: LD IX,CALLME		 | 		 .

(1)	 |(2)		 .

CALL CALSLT ------------------+ 		 .

(4)	 .

+------------------ RET

(6)	 |(5)

<-----------------+



In MSX2, the state of the interrupt is reserved before and after the inter-slot call. That is, 3 in the figure is in the same state as 1, and 6 is in the same state as 4. Note when the called program executes "EI" or "DI".





MSX2 TECHNICAL HANDBOOK

-----------------------



Edited by:		ASCII Systems Division

Published by:		ASCII Coprporation - JAPAN

First edition:		March 1987

<i>

Text file typed by:	Nestor Soriano (Konami Man) - SPAIN

October 1997



Changes from the original in APPENDIX 1:

- In description of ENASLT, the needed input in HL has been added.



- In description of GETYPR, the Input field has been added.



- In description of INITXT (MAIN), the reference to "INIPLOT" has been corrected to "INIPLT".



- In description of SUBROM routine, the mark "*1" has been erased.



- In description of INITXT (SUB), the needed input in LINL40 has been added.



- Description of PHYDIO routine has been added.

Changes from the original in APPENDIX 2:

- In the explanation before Figure A.3, the indication about the excess 64

method has been added.



- In Figure A.3, in the third byte, "63rd power of 10" has been corrected to "-63rd power of 10".



- In the explanation before Figure A.3, the indication about the excess 64

method has been added.



- In Figure A.3, in the third byte, "63rd power of 10" has been corrected to "-63rd power of 10".

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



APPENDIX 1 - BIOS LISTING



This section lists the 126 BIOS entries available to the user.



There are two kinds of BIOS routines, the ones in MAIN-ROM and the ones in SUB-ROM. They each have different calling sequences which will be described later. The following is the entry notation.



Label name (address)	*n

Function: descriptions and notes about the function Input: parameters used by call Output: parameters returned by call Registers: registers which will be used (original contentes are lost)

The value of *n has the following meanings.



*1 ... same as MSX1

*2 ... call SUB-ROM internally in screen modes 5 to 8

*3 ... always call SUB-ROM

*4 ... do not call SUB-ROM while screen modes 4 to 8 are changed

Routines without "*n" are appended for MSX2.



MAIN-ROM

-----------------------------------------------------------------



To call routines in MAIN-ROM, the CALL or RTS instruction is used as an ordinary subroutine call.



* RSTs



Among the following RSTs, RST 00H to RST 28H are used by the BASIC

interpreter. RST 30H is used for inter-slot calls and RST 38H is used for hardware interrupts.



CHKRAM (0000H)		*1

Function:	tests RAM and sets RAM slot for the system Input:	none

Output:	none

Registers:	all



SYNCHR (0008H)		*1

Funtcion:	tests whether the character of [HL] is the specified character. If not, it generates SYNTAX ERROR, otherwise it goes to CHRGTR (0010H).

Input:	set the character to be tested in [HL] and the character to be compared next to RST instruction which calls this routine (inline parameter).



Example:	LD	HL,LETTER

RST	08H

DB	"A"

.

.

.

LETTER: DB	"B"



Output:	HL is increased by one and A receives [HL]. When the tested character is numerical, the CY flag is set; the end of the statement (00H or 3AH) causes the Z flag to be set.

Registers:	AF, HL



RDSLT (000CH)		*1

Function:	selects the slot corresponding to the value of A and reads one byte from the memory of the slot. When this routine is called, the interrupt is inhibited and remains inhibited even after execution ends.

Input:	A for the slot number.



F000EEPP

- ----

| ||++-------------- Basic slot number (0 to 3) | ++---------------- Expansion slot number (0 to 3) +--------------------- "1" when using expansion slot

HL for the address of memory to be read Output:	the value of memory which has been read in A Registers:	AF, BC, DE



CHRGTR (0010H)		*1

Function:	gets a character (or a token) from BASIC text Input:	[HL] for the character to be read Output:	HL is incremented by one and A receives [HL]. When the character is numerical, the CY flag is set; the end of the statement causes the Z flag to be set.

Registers:	AF, HL



WRSLT (0014H)		*1

Function:	selects the slot corresponding to the value of A and writes one byte to the memory of the slot. When this routine is called, interrupts are inhibited and remain so even after execution ends.

Input:	specifies a slot with A (same as RDSLT) Output:	none

Registers:	AF, BC, D



OUTDO (0018H)		*2

Funtion:	sends the value to current device Input:	A for the value to be sent sends output to the printer when PTRFLG (F416H) is other than 0

sends output to the file specified by PTRFIL (F864H) when PTRFIL is other than 0

Output:	none

Registers:	none

CALSLT (001CH)		*1

Function:	calls the routine in another slot (inter-slot call) Input:	specify the slot in the 8 high order buts of the IY register (same as RDSLT). IX is for the address to be called.

Output:	depends on the calling routine Registers:	depends on the calling routine

DCOMPR (0020H)		*1

Function:	compares the contents of HL and DE

Input:	HL, DE

Output:	sets the Z flag for HL = DE, CY flag for HL < DE

Registers:	AF



ENASLT (0024H)		*1

Function:	selects the slot corresponding to the value of A and enables the slot to be used. When this routine is called, interrupts are inhibited and remain so even after execution ends.

Input:	specify the slot by A (same as RDSLT) specify the page to switch the slot by 2 high order bits of HL

Output:	none

Registers:	all



GETYPR (0028H)		*1

Function:	returns the type of DAC (decimal accumulator) Input:	none

Output:	S, Z, P/V flags are changed depending on the type of DAC:

integer type			single precision real type C = 1				C = 1

S = 1 *				S = 0

Z = 0				Z = 0

P/V = 1				P/V = 0 *



string type			double precision real type C = 1				C = 0 *

S = 0				S = 0

Z = 1 *				Z = 0

P/V = 1				P/V = 1



Types can be recognised by the flag marked by "*".

Registers:	AF



CALLF (0030H)		*1

Function:	calls the routine in another slot. The following is the calling sequence:

RST	30H

DB	n	;n is the slot number (same as RDSLT) DW	nn	;nn is the called address

Input:	In the method described above Output:	depends on the calling routine Registers:	AF, and other registers depending on the calling routine

KEYINT (0038H)		*1

Function:	executes the timer interrupt process routine Input:	none

Output:	none

Register:	none



* I/O initialisation



INITIO (003BH)		*1

Function:	initialises the device Input:	none

Output:	none

Registers:	all



INIFNK (003EH)		*1

Function:	initialises the contents of function keys Input:	none

Output:	none

Registers:	all



* VDP access



DISSCR (0041H)		*1

Function:	inhibits the screen display Input:	none

Output:	none

Registers:	AF, BC



ENASCR (0044H)		*1

Function:	displays the screen Input:	none

Output:	none

Registers:	all



WRTVDP (0047H)		*2

Function:	writes data in the VDP register Input:	C for the register number, B for data; the register number is 0 to 23 and 32 to 46

Output:	none

Registers:	AF, BC



RDVRM (004AH)		*1

Function:	reads the contents of VRAM. This is for TMS9918, so only the 14 low order bits of the VRAM address are valid. To use all bits, call NRDVRM.

Input:	HL for VRAM address to be read Output:	A for the value which was read Registers:	AF



WRTVRM (004DH)		*1

Function:	writes data in VRAM. This is for TMS9918, so only the 14 low order bits of the VRAM address are valid. To use all bits, call NWRVRM.

Input:	HL for VRAM address, A for data Output:	none

Registers:	AF



SETRD (0050H)		*1

Function:	sets VRAM address to VDP and enables it to be read. This is used to read data from the sequential VRAM area by using the address auto-increment function of VDP. This enables faster readout than using RDVRM in a loop. This is for TMS9918, so only the 14 low order bits of VRAM address are valid. To use all bits, call NSETRD.

Input:	HL for VRAM address Output:	none

Registers:	AF



SETWRT (0053H)		*1

Function:	sets VRAM address to VDP and enables it to be written. The purpose is the same as SETRD. This is for TMS9918, so only the 14 low order bits of VRAM address are valid. To use all bits, call NSETRD.

Input:	HL for VRAM address Output:	none

Registers:	AF



FILVRM (0056H)		*4

Function:	fills the specified VRAM area with the same data. This is for TMS9918, so only the 14 low order bits of the VRAM address are valid. To use all bits, see BIGFIL.

Input:	HL for VRAM address to begin writing, BC for the length of the area to be written, A for data.

Output:	none

Registers:	AF, BC



LDIRMV (0059H)		*4

Function:	block transfer from VRAM to memory Input:	HL for source address (VRAM), DE for destination address (memory), BC for the length. All bits of the VRAM address are valid.

Output:	none

Registers:	all



LDIRVM (005CH)		*4

Function:	block transfer from memory to VRAM

Input:	HL for source address (memory), DE for destination address (VRAM), BC for the length. All bits of the VRAM address are valid.

Output:	none

Registers:	all



CHGMOD (005FH)		*3

Function:	changes the screen mode. The palette is not initialised. To initialise it, see CHGMDP in SUB-ROM.

Input:	A for the screen mode (0 to 8) Output:	none

Registers:	all



CHGCLR (0062H)		*1

Function:	changes the screen colour Input:	A for the mode FORCLR (F3E9H) for foreground color BAKCLR (F3EAH) for background color BDRCLR (F3EBH) for border colour Output:	none

Registers:	all



NMI (0066H)		*1

Function:	executes NMI (Non-Maskable Interrupt) handling routine Input:	none

Output:	none

Registers:	none

CLRSPR (0069H)		*3

Function:	initialises all sprites. The sprite pattern is cleared to null, the sprite number to the sprite plane number, the sprite colour to the foregtound colour. The vertical location of the sprite is set to 209 (mode 0 to 3) or 217

(mode 4 to 8).

Input:	SCRMOD (FCAFH) for the screen mode Output:	none

Registers:	all



INITXT (006CH)		*3

Function:	initialises the screen to TEXT1 mode (40 x 24). In this routine, the palette is not initialised. To initialise the palette, call INIPLT in SUB-ROM after this call.

Input:	TXTNAM (F3B3H) for the pattern name table TXTCGP (F3B7H) for the pattern generator table LINL40 (F3AEH) for the length of one line Output:	none

Registers:	all



INIT32 (006FH)		*3

Function:	initialises the screen to GRAPHIC1 mode (32x24). In this routine, the palette is not initialised.

Input:	T32NAM (F3BDH) for the pattern name table T32COL (F3BFH) for the colour table T32CGP (F3C1H) for the pattern generator table T32ATR (F3C3H) for the sprite attribute table T32PAT (F3C5H) for the sprite generator table Output:	none

Registers:	all



INIGRP (0072H)		*3

Function:	initialises the screen to the high-resolution graphics mode.

In this routine, the palette is not initialised.

Input:	GRPNAM (F3C7H) for the pattern name table GRPCOL (F3C9H) for the colour table GRPCGP (F3CBH) for the pattern generator table GRPATR (F3CDH) for the sprite attribute table GRPPAT (F3CFH) for the sprite generator table Output:	none

Registers:	all



INIMLT (0075H)		*3

Function:	initialises the screen to MULTI colour mode. In this routine, the palette is not initialised.

Input:	MLTNAM (F3D1H) for the pattern name table MLTCOL (F3D3H) for the colour table MLTCGP (F3D5H) for the pattern generator table MLTATR (F3D7H) for the sprite attribute table MLTPAT (F3D9H) for the sprite generator table Output:	none

Registers:	all



SETTXT (0078H)		*3

Function:	set only VDP in TEXT1 mode (40x24) Input:	same as INITXT

Output:	none

Registers:	all



SETT32 (007BH)		*3

Function:	set only VDP in GRAPHIC1 mode (32x24) Input:	same as INIT32

Output:	none

Registers:	all



SETGRP (007EH)		*3

Function:	set only VDP in GRAPHIC2 mode Input:	same as INIGRP

Output:	none

Registers:	all



SETMLT (0081H)		*3

Function:	set only VDP in MULTI colour mode Input:	same as INIMLT

Output:	none

Registers:	all



CALPAT (0084H)		*1

Funtion:	returns the address of the sprite generator table Input:	A for the sprite number Output:	HL for the address Registers:	AF, DE, HL



CALATR (0087H)		*1

Function:	returns the address of the sprite attribute table Input:	A for the sprite number Output:	HL for the address Registers:	AF, DE, HL



GSPSIZ (008AH)		*1

Function:	returns the current sprite size Input:	none

Output:	A for the sprite size (in bytes). Only when the size is 16 x 16, the CY flag is set; otherwise the CY flag is reset.

Registers:	AF



GRPPRT (008DH)		*2

Function:	displays a character on the graphic screen Input:	A for the character code. When the screen mode is 0 to 8, set the logical operation code in LOGOPR (FB02H).

Output:	none

Registers:	none

* PSG



GICINI (0090H)		*1

Function:	initialises PSG and sets the initial value for the PLAY

statement

Input:	none

Output:	none

Registers:	all



WRTPSG (0093H)		*1

Function:	writes data in the PSG register Input:	A for PSG register number, E for data Output:	none

Registers:	none

RDPSG (0096H)		*1

Function:	reads the PSG register value Input:	A for PSG register number Output:	A for the value which was read Registers:	none

STRTMS (0099H)		*1

Function:	tests whether the PLAY statement is being executed as a background task. If not, begins to execute the PLAY statement Input:	none

Output:	none

Registers:	all



* Keyboard, CRT, printer input-output



CHSNS (009CH)		*1

Function:	tests the status of the keyboard buffer Input:	none

Output:	the Z flag is set when the buffer is empty, otherwise the Z flag is reset Registers:	AF



CHGET (009FH)		*1

Function:	one character input (waiting) Input:	none

Output:	A for the code of the input character Registers:	AF



CHPUT (00A2H)		*1

Function:	displays the character Input:	A for the character code to be displayed Output:	none

Registers:	none

LPTOUT (00A5H)		*1

Function:	sends one character to the printer Input:	A for the character code to be sent Output:	if failed, the CY flag is set Registers:	F



LPTSTT (00A8H)		*1

Function:	tests the printer status Input:	none

Output:	when A is 255 and the Z flag is reset, the printer is READY.

when A is 0 and the Z flag is set, the printer is NOT READY.

Registers:	AF



CNVCHR (00ABH)		*1

Function:	test for the graphic header and transforms the code Input:	A for the character code Output:	the CY flag is reset to not the graphic header the CY flag and the Z flag are set to the transformed code is set in A

the CY flag is set and the CY flag is reset to the untransformed code is set in A Registers:	AF



PINLIN (00AEH)		*1

Function:	stores in the specified buffer the character codes input until the return key or STOP key is pressed.

Input:	none

Output:	HL for the starting address of the buffer minus 1, the CY

flag is set only when it ends with the STOP key.

Registers:	all



INLIN (00B1H)		*1

Function:	same as PINLIN except that AUTFLG (F6AAH) is set Input:	none

Output:	HL for the starting address of the buffer minus 1, the CY

flag is set only when it ends with the STOP key.

Registers:	all



QINLIN (00B4H)		*1

Function:	executes INLIN with displaying "?" and one space Input:	none

Output:	HL for the starting address of the buffer minus 1, the CY

flag is set only when it ends with the STOP key.

Registers:	all



BREAKX (00B7H)		*1

Function:	tests Ctrl-STOP key. In this routine, interrupts are inhibited.

Input:	none

Output:	the CY flag is set when pressed Registers:	AF



BEEP (00C0H)		*3

Function:	generates BEEP

Input:	none

Output:	none

Registers:	all



CLS (00C3H)		*3

Function:	clears the screen Input:	set zero flag Output:	none

Registers:	AF, BC, DE



POSIT (00C6H)		*1

Function:	moves the cursor Input:	H for the X-coordinate of the cursor, L for the Y-coordinate Output:	none

Registers:	AF



FNKSB (00C9H)		*1

Function:	tests whether the function key display is active (FNKFLG).

If so, displays them, otherwise erases them.

Input:	FNKFLG (FBCEH) Output:	none

Registers:	all



ERAFNK (00CCH)		*1

Function:	erases the function key display Input:	none

Output:	none

Registers:	all



DSPFNK (00CFH)		*2

Function:	displays the function keys Input:	none

Output:	none

Registers:	all



TOTEXT (00D2H)		*1

Function:	forces the screen to be in the text mode Input:	none

Output:	none

Registers:	all



* Game I/O access



GTSTCK (00D5H)		*1

Function:	returns the joystick status Input:	A for the joystick number to be tested Output:	A for the joystick direction Registers:	all



GTTRIG (00D8H)		*1

Function:	returns the trigger button status Input:	A for the trigger button number to be tested Output:	When A is 0, the trigger button is not being pressed.

When A is FFH, the trigger button is being pressed.

Registers:	AF



GTPAD (00DBH)		*1

Function:	returns the touch pad status Input:	A for the touch pad number to be tested Output:	A for the value Registers:	all



GTPDL (00DEH)		*2

Function:	returns the paddle value Input:	A for the paddle number Output:	A for the value Registers:	all



* Cassette input-output routine



TAPION (00E1H)		*1

Function:	reads the header block after turning the cassette motor ON.

Input:	none

Output:	if failed, the CY flag is set Registers:	all



TAPIN (00E4H)		*1

Function:	reads data from the tape Input:	none

Output:	A for data. If failed, the CY flag is set.

Registers:	all



TAPIOF (00E7H)		*1

Function:	stops reading the tape Input:	none

Output:	none

Registers:	none

TAPOON (00EAH)		*1

Function:	writes the header block after turning the cassette motor ON

Input:	A = 0, short header; A <> 0, long header Output:	if failed, the CY flag is set Registers:	all



TAPOUT (00EDH)		*1

Function:	writes data on the tape Input:	A for data Output:	if failed, the CY flag is set Registers:	all



TAPOOF (00F0H)		*1

Function:	stops writing to the tape Input:	A for data Output:	if failed, the CY flag is set Registers:	all



STMOTR (00F3H)		*1

Function:	sets the cassette motor action Input:	A = 0		->	stop A = 1		->	start A = 0FFH	->	reverse the current action Output:	none

Registers:	AF



* Miscellaneous



CHGCAP (0132H)		*1

Function:	alternates the CAP lamp status Input:	A = 0		->	lamp off A <>0		->	lamp on Output:	none

Registers:	AF



CHGSND (0135H)		*1

Function:	alternates the 1-bit sound port status Input:	A = 0		->	OFF

A <>0		->	ON

Output:	none

Registers:	AF



RSLREG (0138H)		*1

Function:	reads the contents of current output to the basic slot register

Input:	none

Output:	A for the value which was read Registers:	A



WSLREG (013BH)		*1

Function:	writes to the primary slot register Input:	A for the value to be written Output:	none

Registers:	none

RDVDP (013EH)		*1

Function:	reads VDP status register Input:	none

Output:	A for the value which was read Registers:	A



SNSMAT (0141H)		*1

Function:	reads the value of the specified line from the keyboard matrix

Input:	A for the specified line Output:	A for data (the bit corresponding to the pressed key will be 0)

Registers:	AF, C



PHYDIO (0144H)

Function:	Physical input/output for disk devices Input:	A for the drive number (0 = A:, 1 = B:,...) B for the number of sector to be read from or written to C for the media ID

DE for the first sector number to be read rom or written to HL for the startinga address of the RAM buffer to be read from or written to specified sectors CY set for sector writing; reset for sector reading Output:	CY set if failed B for the number of sectors actually read or written A for the error code (only if CY set): 0 = Write protected 2 = Not ready

4 = Data error

6 = Seek error

8 = Record not found 10 = Write error 12 = Bad parameter 14 = Out of memory 16 = Other error Registers:	all



ISFLIO (014AH)		*1

Function:	tests whether the device is active Input:	none

Output:	A = 0		->	active A <>0		->	inactive Registers:	AF



OUTDLP (014DH)		*1

Function:	printer output.Different from LPTOUT in the following points: 1. TAB is expanded to spaces





2. For non-MSX printers, hiragana is transformed to


katakana and graphic characters are transformed to 1-byte characters.

3. If failed, device I/O error occurs.

Input:	A for data Output:	none

Registers:	F



KILBUF (0156H)		*1

Function:	clears the keyboard buffer Input:	none

Output:	none

Registers:	HL



CALBAS (0159H)		*1

Function:	executes inter-slot call to the routine in BASIC interpreter Input:	IX for the calling address Output:	depends on the called routine Registers:	depends on the called routine

* Entries appended for MSX2



SUBROM (015CH)

Function:	executes inter-slot call to SUB-ROM

Input:	IX for the calling address and, at the same time, pushes IX

on the stack

Output:	depends on the called routine Registers:	background registers and IY are reserved

EXTROM (015FH)

Function:	executes inter-slot call to SUB-ROM

Input:	IX for the calling address Output:	depends on the called routine Registers:	background registers and IY are reserved

EOL (0168H)

Function:	deletes to the end of the line Input:	H for X-coordinate of the cursor, L for Y-coordinate Output:	none

Registers:	all



BIGFIL (016BH)

Function:	same function as FILVRM. Differences are as follows: In FILVRM, it is tested whether the screen mode is 0 to 3.

If so, it treats VDP as the one which has only 16K bytes VRAM (for the compatibility with MSX1). In BIGFIL, the mode is not tested and actions are carried out by the given parameters.

Input:	same as FILVRM

Output:	same as FILVRM

Registers:	same as FILVRM



NSETRD (016EH)

Function:	enables VRAM to be read by setting the address Input:	HL for VRAM address Output:	none

Registers:	AF



NSTWRT (0171H)

Function:	enables VRAM to be written by setting the address Input:	HL for VRAM address Output:	none

Registers:	AF



NRDVRM (0174H)

Function:	reads the contents of VRAM

Input:	HL for VRAM address to be read Output:	A for the value which was read Registers:	F



NWRVRM (0177H)

Function:	writes data in VRAM

Input:	HL for VRAM address, A for data Output:	none

Registers:	AF



SUB-ROM

-----------------------------------------------------------------



The calling sequence of SUB-ROM is as follows:

.

.

.

LD	IX, INIPLT

; Set BIOS entry address CALL	EXTROM

; Returns here .

.

.



When the contents of IX should not be destroyed, use the call as shown below.



.

.

.

INIPAL: PUSH	IX

; Save IX

LD	IX, INIPLT

; Set BIOS entry address JP	SUBROM

;Returns caller of INIPAL

.

.

.



GRPRT (0089H)

Function:	one character output to the graphic screen (active only in screen modes 5 to 8) Input:	A for the character code Output:	none

Registers:	none

NVBXLN (00C9H)

Function:	draws a box Input:	start point: BC for X-coordinate, DE for Y-coordinate end point: GXPOS (FCB3H) for X-coordinate GYPOS (FCB5H) for Y-coordinate colour: ATRBYT (F3F3H) for the attribute logical operation code: LOGOPR (FB02H) Output:	none

Registers:	all



NVBXFL (00CDH)

Function:	draws a painted box Input:	start point: BC for X-coordinate, DE for Y-coordinate end point: GXPOS (FCB3H) for X-coordinate GYPOS (FCB5H) for Y-coordinate colour: ATRBYT (F3F3H) for the attribute logical operation code: LOGOPR (FB02H) Output:	none

Registers:	all



CHGMOD (00D1H)

Function:	changes the screen mode Input:	A for the screen mode (0 to 8) Output:	none

Registers:	all



INITXT (00D5H)

Function:	initialises the screen to TEXT1 mode (40 x 24) Input:	TXTNAM (F3B3H) for the pattern name table TXTCGP (F3B7H) for the pattern generator table LINL40 (F3AEH) for the length of one line Output:	none

Registers:	all



INIT32 (00D9H)

Function:	initialises the screen to GRAPHIC1 mode (32x24) Input:	T32NAM (F3BDH) for the pattern name table T32COL (F3BFH) for the colour table T32CGP (F3C1H) for the pattern generator table T32ATR (F3C3H) for the sprite attribute table T32PAT (F3C5H) for the sprite generator table Output:	none

Registers:	all



INIGRP (00DDH)

Function:	initialises the screen to the high-resolution graphics mode Input:	GRPNAM (F3C7H) for the pattern name table GRPCOL (F3C9H) for the colour table GRPCGP (F3CBH) for the pattern generator table GRPATR (F3CDH) for the sprite attribute table GRPPAT (F3CFH) for the sprite generator table Output:	none

Registers:	all



INIMLT (00E1H)

Function:	initialises the screen to MULTI colour mode Input:	MLTNAM (F3D1H) for the pattern name table MLTCOL (F3D3H) for the colour table MLTCGP (F3D5H) for the pattern generator table MLTATR (F3D7H) for the sprite attribute table MLTPAT (F3D9H) for the sprite generator table Output:	none

Registers:	all



SETTXT (00E5H)

Function:	sets VDP in the text mode (40x24) Input:	same as INITXT

Output:	none

Registers:	all



SETT32 (00E9H)

Function:	ses VDP in the text mode (32x24) Input:	same as INIT32

Output:	none

Registers:	all



SETGRP (00EDH)

Function:	sets VDP in the high-resolution mode Input:	same as INIGRP

Output:	none

Registers:	all



SETMLT (00F1H)

Function:	sets VDP in MULTI COLOUR mode Input:	same as INIMLT

Output:	none

Registers:	all



CLRSPR (00F5H)

Function:	initialises all sprites. The sprite pattern is set to null, sprite number to sprite plane number, and sprite colour to the foregtound colour. The vertical location of the sprite is set to 217.

Input:	SCRMOD (FCAFH) for the screen mode Output:	none

Registers:	all



CALPAT (00F9H)

Funtion:	returns the address of the sprite generator table (this routine is the same as CALPAT in MAIN-ROM) Input:	A for the sprite number Output:	HL for the address Registers:	AF, DE, HL



CALATR (00FDH)

Function:	returns the address of the sprite attribute table (this routine is the same as CALATR in MAIN-ROM) Input:	A for the sprite number Output:	HL for the address Registers:	AF, DE, HL



GSPSIZ (0101H)

Function:	returns the current sprite size (this routine is the same as GSPSIZ in MAIN-ROM) Input:	none

Output:	A for the sprite size. The CY flag is set only for the size 16 x 16.

Registers:	AF



GETPAT (0105H)

Function:	returns the character pattern Input:	A for the character code Output:	PATWRK (FC40H) for the character pattern Registers:	all



WRTVRM (0109H)

Function:	writes data in VRAM

Input:	HL for VRAM address (0 TO FFFFH), A for data Output:	none

Registers:	AF



RDVRM (010DH)

Function:	reads the contents of VRAM

Input:	HL for VRAM address (0 TO FFFFH) to be read Output:	A for the value which was read Registers:	AF



CHGCLR (0111H)

Function:	changes the screen colour Input:	A for the mode FORCLR (F3E9H) for the foreground color BAKCLR (F3EAH) for the background color BDRCLR (F3EBH) for the border colour Output:	none

Registers:	all



CLSSUB (0115H)

Function:	clears the screen Input:	none

Output:	none

Registers:	all



DSPFNK (011DH)

Function:	displays the function keys Input:	none

Output:	none

Registers:	all



WRTVDP (012DH)

Function:	writes data in the VDP register Input:	C for the register number, B for data Output:	none

Registers:	AF, BC



VDPSTA (0131H)

Function:	reads the VDP register Input:	A for the register number (0 to 9) Output:	A for data Registers:	F



SETPAG (013DH)

Function:	switches the page Input:	DPPAGE (FAF5H) for the display page number ACPAGE (FAF6H) for the active page number Output:	none

Registers:	AF



INIPLT (0141H)

Function:	initialises the palette(the current palette is saved in VRAM) Input:	none

Output:	none

Registers:	AF, BC, DE



RSTPLT (0145H)

Function:	restores the palette from VRAM

Input:	none

Output:	none

Registers:	AF, BC, DE



GETPLT (0149H)

Function:	obtains the colour code from the palette Input:	D for the palette number (0 to 15) Output:	4 high order bits of B for red code 4 low order bits of B for blue code 4 low order bits of C for green code Registers:	AF, DE



SETPLT (014DH)

Function:	sets the colour code to the palette Input:	D for the palette number (0 to 15) 4 high order bits of A for red code 4 low order bits of A for blue code 4 low order bits of E for green code Output:	none

Registers:	AF



BEEP (017DH)

Function:	generates BEEP

Input:	none

Output:	none

Registers:	all



PROMPT (0181H)

Function:	displays the prompt Input:	none

Output:	none

Registers:	all



NEWPAD (01ADH)

Function:	reads the status of mouse or light pen Input:	call with setting the following data in A; descriptions in parenthesis are return values.

8 .......... light pen check (valid at 0FFH) 9 .......... returns X-coordinate 10 .......... returns Y-coordinate 11 .......... returns the light pen switch status (0FFH, when pressed) 12 .......... whether the mouse is connected to the port 1 (valid at 0FFH) 13 .......... returns the offset in X direction 14 .......... returns the offset in Y direction 15 .......... (always 0) 16 .......... whether the mouse is connected to the port 2 (valid at 0FFH) 17 .......... returns the offset in X direction 18 .......... returns the offset in Y direction 19 .......... (always 0) Output:	A

Registers:	all



CHGMDP (01B5H)

Function:	changes VDP mode. The palette is initialised.

Input:	A for the screen mode (0 to 8) Output:	none

Registers:	all



KNJPRT (01BDH)

Function:	sends a kanki to the graphic screen (modes 5 to 8) Input:	BC for JIS kanji code, A for the display mode. The display mode has the following meaning, similar to the PUT KANJI command of BASIC.

0 .......... display in 16 x 16 dot 1 .......... display even dots 2 .......... display odd dots

REDCLK (01F5H)

Function:	reads the clock data Input:	C for RAM address of the clock

00MMAAAA

------

||++++--- Address (0 to 15) ++------- Mode (0 to 3) Output:	A for the data which were read (only 4 low order bits are valid)

Registers:	F



WRTCLK (01F9H)

Function:	writes the clock data Input:	A for the data to be written, C for RAM address of the clock Output:	none

Registers:	F



=============================================================================

<i>

Changes from the original in APPENDIX 2:

- In the explanation before Figure A.3, the indication about the excess 64

method has been added.



- In Figure A.3, in the third byte, "63rd power of 10" has been corrected to "-63rd power of 10".



- In the explanation before Figure A.3, the indication about the excess 64

method has been added.



- In Figure A.3, in the third byte, "63rd power of 10" has been corrected to "-63rd power of 10".

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



APPENDIX 2 - MATH-PACK



The Math-Pack is the core for the mathematical routines of MSX-BASIC and, by calling these routines from an assembly language program, floating-point operations and trigonometrical functions are available.



Any operations involving real numbers in Math-Pack are done in BCD (Binary Coded Decimal). There are two ways of expressing a real number, "single precision" and "double precision"; a single precision real number (6 digits) is expressed by 4 bytes and a double precision real number (14 digits) by 8

bytes (see Figure A.1 and Figure A.2).



Figure A.1 BCD format for expressing real numbers

MSB 7	 6 5 4	 3	 2 1 0	 LSB

---	 ---	-------------------------------------------------

^		^	|sign | 	 exponent 		| 0

|		|	-------------------------------------------------

|		|	-------------------------------------------------

|		|	| mantissa 1st place	| mantissa 2nd place	| 1

|	 single	-------------------------------------------------

|	 precision	-------------------------------------------------

|		|	| mantissa 3rd place	| mantissa 4th place	| 2

|		|	-------------------------------------------------

|		|	-------------------------------------------------

|		V	| mantissa 5th place	| mantissa 6th place	| 3

double ---	-------------------------------------------------

precision		-------------------------------------------------

|			| mantissa 7th place	| mantissa 8th place	| 4

|			-------------------------------------------------

|			-------------------------------------------------

|			| mantissa 9th place	| mantissa 10th place	| 5

|			-------------------------------------------------

|			-------------------------------------------------

|			| mantissa 11th place	| mantissa 12th place	| 6

|			-------------------------------------------------

|			-------------------------------------------------

V			| mantissa 13th place	| mantissa 14th place	| 7

---			-------------------------------------------------



Figure A.2 Examples of expressions for real numbers

Example of the single precision expression

123456 --> 0.123456 E+6



1 2	 3	 4

-------------------------

DAC | 46 | 12 | 34 | 56 |

-------------------------



Example of the double precision expression

123456.78901234 --> 0.12345678901234 E+6



1 2	 3	 4 5 6	 7	 8

-------------------------------------------------

DAC | 46 | 12 | 34 | 56 | 78 | 90 | 12 | 34 |

-------------------------------------------------



A real number consists of a sign, an exponent, and a mantissa. The sign represents the sign of the mantissa; 0 for positive, 1 for negative. The exponent is a binary expression and can be expressed as a power from +63 to -63, with an excess of 64 (see Figure A.3). Figure A.4 shows the valid range of double precision real numbers.



Figure A.3 Exponent format

|sign |<--------------- exponent -------------->|	meaning -------------------------------------------------

| 0 | 0 0 0	 0	 0 0 0	| ..... 0

-------------------------------------------------

-------------------------------------------------

| 1 | 0 0 0	 0	 0 0 0	| ..... undefined (-0?) -------------------------------------------------

-------------------------------------------------

| x | 0 0 0	 0	 0 0 1	| ..... -63rd power of 10

-------------------------------------------------

-------------------------------------------------

| x | 1 0 0	 0	 0 0 0	| ..... 0th power of 10

-------------------------------------------------

-------------------------------------------------

| x | 1 1 1	 1	 1 1 1	| ..... +63rd power of 10

-------------------------------------------------



Note: "x" is 1 or 0, both of which are allowed.



Figure A.4 Valid range for double precision real numbers

7 6	 5	 4 3 2	 1	 0 (byte) -------------------------------------------------

DAC | FF | 99 | 99 | 99 | 99 | 99 | 99 | 99 | -0.99999999999999 E+63

-------------------------------------------------

.

.

.

-------------------------------------------------

| 81 | 10 | 00 | 00 | 00 | 00 | 00 | 00 | -0.10000000000000 E-63

-------------------------------------------------

-------------------------------------------------

| 00 | x	| x | x | x | x	| x | x |	0

-------------------------------------------------

-------------------------------------------------

| 01 | 10 | 00 | 00 | 00 | 00 | 00 | 00 | +0.10000000000000 E-63

-------------------------------------------------

.

.

.

-------------------------------------------------

| 7F | 99 | 99 | 99 | 99 | 99 | 99 | 99 | +0.99999999999999 E+63

-------------------------------------------------



In Math-Pack, the memory is predefined for operation. This memory area is called "DAC (Decimal ACumulator (F7F6H)" and the area which reserves the numerical value to be operated is called "ARG (F847H)". For example, in multiplication, the product of the numbers in DAC and ARG is calculated and the result is returned in the DAC.



In the DAC, single precision real numbers, double precision real numbers, and two-byte integers can be stored. In order to distinguish them, "VALTYP

(F663H)" is used and its value is 4 for single precision real numbers, 8 for double precision real numbers, and 2 for two-byte integers.



Single and double precision numbers must be stored from the top of the DAC.

For two-byte integers, the low and high bytes should be stored in DAC + 2 and DAC + 3.



Since Math-Pack is an internal routine of BASIC, when an error occurs (such as division by 0 or overflow), control automatically jumps to the corresponding error routine, then returns to BASIC command level. To prevent this, change H.ERRO (FFB1H).



* Math-Pack work area



-----------------------------------------------------------------------------

| Label | Address	| Size |		 Meaning		 |

|-----------+-----------+--------+------------------------------------------|

| VALTYP |	F663H	| 1	 | format of the number in DAC		 |

| DAC	 |	F7F6H	| 16	 | floating point accumulator in BCD format |

| ARG	 |	F847H	| 16	 | argument of DAC			 |

-----------------------------------------------------------------------------



* Math-Pack entry



Basic operation



-------------------------------------------------

| Label | Address	|	Function	|

|-----------+-----------+-----------------------|

| DECSUB |	268CH	| DAC <-- DAC - ARG	|

| DECADD |	269AH	| DAC <-- DAC + ARG	|

| DECNRM |	26FAH	| normalises DAC (*1) |

| DECROU |	273CH	| rounds DAC		|

| DECMUL |	27E6H	| DAC <-- DAC * ARG	|

| DECDIV |	289FH	| DAC <-- DAC / ARG	|

-------------------------------------------------



Note: These operations treat numbers in DAC and ARG as the double precision number. Registers are not preserved.

*1 Excessive zeros in mantissa are removed. (0.00123 --> 0.123 E-2)

Function 1



----------------------------------------------------------------------

| Label | Address	|	Function | Register modified |

|-----------+-----------+----------------------+---------------------|

| COS |	2993H	| DAC <-- COS(DAC) |	 all	 |

| SIN |	29ACH	| DAC <-- SIN(DAC) |	 all	 |

| TAN |	29FBH	| DAC <-- TAN(DAC) |	 all	 |

| ATN |	2A14H	| DAC <-- ATN(DAC) |	 all	 |

| LOG |	2A72H	| DAC <-- LOG(DAC) |	 all	 |

| SQR |	2AFFH	| DAC <-- SQR(DAC) |	 all	 |

| EXP |	2B4AH	| DAC <-- EXP(DAC) |	 all	 |

| RND |	2BDFH	| DAC <-- RND(DAC) |	 all	 |

----------------------------------------------------------------------



Note: These processing routines all have the same function names as those in BASIC. "All" registers are A, B, C, D, E, H, and L.



Function 2



----------------------------------------------------------------------

| Label | Address	|	Function | Register modified |

|-----------+-----------+----------------------+---------------------|

| SIGN |	2E71H	| A <-- sign of DAC |	 A	 |

| ABSFN |	2E82H	| DAC <-- ABS(DAC) |	 all	 |

| NEG |	2E8DH	| DAC <-- NEG(DAC) |	 A,HL	 |

| SGN |	2E97H	| DAC <-- SGN(DAC) |	 A,HL	 |

----------------------------------------------------------------------



Note: Except for SIGN, these processing routines all have the same function names as those in BASIC. Registers are A, B, C, D, E, H, and L.

Note that for SGN, the result is represented as a 2-byte integer.



Movement



----------------------------------------------------------------------------

| Label | Address	| Function | Object |	Reg. mod. |

|-----------+-----------+---------------------+--------------+-------------|

| MAF |	2C4DH	| ARG <-- DAC | double prec. | A,B,D,E,H,L |

| MAM |	2C50H	| ARG <-- (HL) | double prec. | A,B,D,E,H,L |

| MOV8DH |	2C53H	| (DE) <-- (HL) | double prec. | A,B,D,E,H,L |

| MFA |	2C59H	| DAC <-- ARG | double prec. | A,B,D,E,H,L |

| MFM |	2C5CH	| DAC <-- (HL) | double prec. | A,B,D,E,H,L |

| MMF |	2C67H	| (HL) <-- DAC | double prec. | A,B,D,E,H,L |

| MOV8HD |	2C6AH	| (HL) <-- (DE) | double prec. | A,B,D,E,H,L |

| XTF |	2C6FH	| (SP) <--> DAC | double prec. | A,B,D,E,H,L |

| PHA |	2CC7H	| ARG <-- (SP) | double prec. | A,B,D,E,H,L |

| PHF |	2CCCH	| DAC <-- (SP) | double prec. | A,B,D,E,H,L |

| PPA |	2CDCH	| (SP) <-- ARG | double prec. | A,B,D,E,H,L |

| PPF |	2CE1H	| (SP) <-- DAC | double prec. | A,B,D,E,H,L |

| PUSHF |	2EB1H	| DAC <-- (SP) | single prec. | D,E	 |

| MOVFM |	2EBEH	| DAC <-- (HL) | single prec. | B,C,D,E,H,L |

| MOVFR |	2EC1H	| DAC <-- (CBED) | single prec. | D,E	 |

| MOVRF |	2ECCH	| (CBED) <-- DAC | single prec. | B,C,D,E,H,L |

| MOVRMI |	2ED6H	| (CBED) <-- (HL) | single prec. | B,C,D,E,H,L |

| MOVRM |	2EDFH	| (BCDE) <-- (HL) | single prec. | B,C,D,E,H,L |

| MOVMF |	2EE8H	| (HL) <-- DAC | single prec. | A,B,D,E,H,L |

| MOVE |	2EEBH	| (HL) <-- (DE) | single prec. | B,C,D,E,H,L |

| VMOVAM |	2EEFH	| ARG <-- (HL) | VALTYP	 | B,C,D,E,H,L |

| MOVVFM |	2EF2H	| (DE) <-- (HL) | VALTYP	 | B,C,D,E,H,L |

| VMOVE |	2EF3H	| (HL) <-- (DE) | VALTYP	 | B,C,D,E,H,L |

| VMOVFA |	2F05H	| DAC <-- ARG | VALTYP	 | B,C,D,E,H,L |

| VMOVFM |	2F08H	| DAC <-- (HL) | VALTYP	 | B,C,D,E,H,L |

| VMOVAF |	2F0DH	| ARG <-- DAC | VALTYP	 | B,C,D,E,H,L |

| VMOVMF |	2F10H	| (HL) <-- DAC | VALTYP	 | B,C,D,E,H,L |

----------------------------------------------------------------------------



Note: (HL), (DE) means the values in memory pointed to by HL or DE. Four register names in the parentheses are the single precision real numbers which indicate (sign + exponent), (mantissa 1st and 2nd places), (mantissa 3th and 4th places), (mantissa 5th and 6th places) from left to right. Where the object is VALTYP, the movement (2, 4, 8 bytes) is according to the type indicated in VALTYP (F663H).



Comparison



-----------------------------------------------------------------------------

| Label | Address	| Object		 | Left | Right |Reg. mod.|

|-----------+-----------+--------------------------+------+-------+---------|

| FCOMP |	2F21H	| single prec. real number | CBED | DAC | HL |

| ICOMP |	2F4DH	| 2-byte integer	 | DE | HL | HL |

| XDCOMP |	2F5CH	| double prec. real number | ARG | DAC | all |

-----------------------------------------------------------------------------



Note: Results will be in A register. Meanings of A register are:

A = 1	-->	left < right A = 0	-->	left = right A = -1	-->	left > right

In the comparison of single precision real numbers, CBED means that each register has single precision (sign + exponent), (mantissa 1st and 2nd places), (mantissa 3th and 4th places), and (mantissa 5th and 6th places).



Floating-point input/output



-----------------------------------------------------------------------------

| Label | Address	|		 Function			 |

|-----------+-----------+---------------------------------------------------|

| FIN |	3299H	| Stores a string representing the floating-point |

|	 |		| number in DAC, converting it in real.	 |

|---------------------------------------------------------------------------|

| Entry condition HL <-- Starting address of the string		 |

|		 A <-- First character of the string		 |

| Return condition DAC <-- Real number				 |

|		 C <-- FFH: without a decimal point		 |

|			 0: with a decimal point		 |

|		 B <-- Number of places after the decimal point |

|		 D <-- Number of digits 			 |

-----------------------------------------------------------------------------



-----------------------------------------------------------------------------

| Label | Address	|		 Function			 |

|-----------+-----------+---------------------------------------------------|

| FOUT |	3425H	| Converts the real number in DAC to the string |

|	 |		| (unformatted)				 |

| PUFOUT |	3426H	| Converts the real number in DAC to the string |

|	 |		| (formatted)				 |

|---------------------------------------------------------------------------|

| Entry condition A <-- format					 |

| bit 7 0: unformatted	 1: formatted				 |

| bit 6 0: without commas 1: with commas every three digits	 |

| bit 5 0: meaningless	 1: leading spaces are padded with "." |

| bit 4 0: meaningless	 1: "$" is added before the numerical value |

| bit 3 0: meaningless	 1: "+" is added even for positive values |

| bit 2 0: meaningless	 1: the sign comes after the value	 |

| bit 1 unused							 |

| bit 0: 0: fixed point	 1: floating-point			 |

|	B <-- number of digits before and not including the decimal point |

|	C <-- number of digits after and including the decimal point	 |

| Return condition HL <-- starting address of the string		 |

-----------------------------------------------------------------------------



-----------------------------------------------------------------------------

| Label | Address	|		 Function			 |

|-----------+-----------+---------------------------------------------------|

| FOUTB |	371AH	| Converts 2-byte integer in DAC+2, 3 to a	 |

|	 |		| binary expression string.			 |

| FOUTO |	371EH	| Converts 2-byte integer in DAC+2, 3 to an	 |

|	 |		| octal expression string.			 |

| FOUTH |	3722H	| Converts 2-byte integer in DAC+2, 3 to a	 |

|	 |		| hexadecimal expression string.		 |

|---------------------------------------------------------------------------|

| Entry condition DAC + 2	<-- 2-byte integer			 |

|		 VALTYP	<-- 2					 |

| Return condition HL	<-- starting address of the string	 |

-----------------------------------------------------------------------------



Note: no strings are reserved. The starting address of the string in the output routine is normally in FBUFFR (from F7C5H). In some cases it may differ slightly. For the integer in DAC + 2, VALTYP (F663H) must be 2, even in cases other than FOUTB, FOUTO and FOUTH.



Type conversion



-----------------------------------------------------------------------------

| Label | Address	|		 Function			 |

|-----------+-----------+---------------------------------------------------|

| FRCINT |	2F8AH	| Converts DAC to a 2-byte integer (DAC + 2, 3) |

| FRCSNG |	2FB2H	| Converts DAC to a single precision real number |

| FRCDBL |	303AH	| Converts DAC to a double precision real number |

| FIXER |	30BEH	| DAC <-- SGN(DAC) * INT(ABS(DAC))		 |

-----------------------------------------------------------------------------



Note: after execution, VALTYP (F663H) will contain the number (2, 4 or 8) representing DAC type. No registers are reserved.



Integer operation



-----------------------------------------------------------------------

| Label | Address	|	Function | Registers modified |

|-----------+-----------+----------------------+----------------------|

| UMULT |	314AH	| DE <-- BC * DE | A, B, C, D, E |

| ISUB |	3167H	| HL <-- DE - HL |	 all	 |

| IADD |	3172H	| HL <-- DE + HL |	 all	 |

| IMULT |	3193H	| HL <-- DE * HL |	 all	 |

| IDIV |	31E6H	| HL <-- DE / HL |	 all	 |

| IMOD |	323AH	| HL <-- DE mod HL |	 alle	 |

|	 |		| (DE <-- DE/HL) |		 |

-----------------------------------------------------------------------



Power



-----------------------------------------------------------------------------

| Label | Address	| Function		 | Base | Exp. | Result |

|-----------+-----------+----------------------------+------+------+--------|

| SGNEXP |	37C8H	| power of single-prec. real | DAC | ARG | DAC |

| DBLEXP |	37D7H	| power of double-prec. real | DAC | ARG | DAC |

| INTEXP |	383FH	| power of 2-byte integer | DE | HL | DAC |

-----------------------------------------------------------------------------



Note: No registers are reserved.



=============================================================================

<i>

Changes from the original in APPENDIX 3:

none

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



APPENDIX 3 - BIT BLOCK TRANSFER



The bit block transfer corresponds to the COPY command in BASIC and is used to transfer data from RAM, VRAM, and the disk. It is easily executed by the routine in expansion ROM and available from the assembly language program.

Since it is in expansion ROM, use SUBROM or EXTROM of BIOS for this routine.





1. Transferring in VRAM




* BLTVV (0191H/SUB)



Function:	transfers data in VRAM area

Input:	HL register <-- F562H

The following parameters should be set:

* SX (F562H, 2) 	X-coordinate of the source * SY (F564H, 2) 	Y-coordinate of the source * DX (F566H, 2) 	X-coordinate of the destination * DY (F568H, 2) 	Y-coordinate of the destination * NX (F56AH, 2) 	number of dots in the X direction * NY (F56CH, 2) 	number of dots in the Y direction * CDUMMY (F56EH, 1)	dummy (not required to be set) * ARG (F56FH, 1)	selects the direction and expansion RAM (same as VDP R#45) * LOGOP (F570H, 1)	logical operation code (same as the logical operation code of VDP)

Output:	the CY flag is reset

Registers:	all





2. Transferring data between RAM and VRAM




To use the routines below, the following memory space should be allocated as graphic area for screen modes.



* screen mode 6

number of dots in X direction times number of dots in Y direction/4 + 4



* screen mode 5 or 7

number of dots in X direction times number of dots in Y direction/2 + 4



* screen mode 8

number of dots in X direction times number of dots in Y direction/2 + 4



Note to raise fractions.



For disk or RAM, data to indicate the size is added as the array data. The first two bytes of data indicate the number of dots in X direction; the next two bytes indicate the number of dots in the Y direction.



* BLTVM (0195H/SUB)



Function:	transfers the array to VRAM



Input:	HL register <-- F562H

The following parameters should be set:

* DPTR (F562H, 2)	source address of memory * DUMMY (F564H, 2)	dummy (not required to be set) * DX (F566H, 2) 	X-coordinate of the destination * DY (F568H, 2) 	Y-coordinate of the destination * NX (F56AH, 2) 	number of dots in the X direction (not required to be set; this is already in the top of data to be transferred)

* NY (F56CH, 2) 	number of dots in the Y direction (not required to be set; this is already in the top of data to be transferred)

* CDUMMY (F56EH, 1)	dummy (not required to be set) * ARG (F56FH, 1)	selects the direction and expansion RAM (same as VDP R#45) * LOGOP (F570H, 1)	logical operation code (same as the logical operation code of VDP)

Output:	the CY flag is set when the number of data bytes to be transferred is incorrect

Registers:	all



* BLTMV (0199H/SUB)



Function:	transfers to the array from VRAM



Input:	HL register <-- F562H

The following parameters should be set:

* SX (F562H, 2) 	X-coordinate of the source * SY (F564H, 2) 	Y-coordinate of the source * DPTR (F566H, 2)	destination address of memory * DUMMY (F568H, 2)	dummy (not required to be set) * NX (F56AH, 2) 	number of dots in the X direction * NY (F56CH, 2) 	number of dots in the Y direction * CDUMMY (F56EH, 1)	dummy (not required to be set) * ARG (F56FH, 1)	selects the direction and expansion RAM (same as VDP R#45)

Output:	the CY flag is reset

Registers:	all



3. Transferring between the disk and RAM or VRAM



The filename should be set first to use the disk (specify the filename as BASIC). The following is an example:



.

.

.

LD	HL,FNAME		; Get pointer to file name LD	(FNPTR),HL		; Set it to parameter area .

.

.

FNAME:	DB 22H,"B:TEST.PIC",22H,0 ; "TEST.PIC", end mark

When an error occurs, control jumps to the error handler of the BASIC

interpreter. Set the hook to handle the error in the user program or to call this routine from MSX-DOS or a ROM cartridge. This hook is H.ERRO (FFB1H).



* BLTVD (019DH/SUB)



Function:	transfers from disk to VRAM



Input:	HL register <-- F562H

The following parameters should be set:

* FNPTR (F562H, 2)	address of the filename * DUMMY (F564H, 2)	dummy (not required to be set) * DX (F566H, 2) 	X-coordinate of the destination * DY (F568H, 2) 	Y-coordinate of the destination * NX (F56AH, 2) 	number of dots in the X direction (not required to be set; this is already in the top of data to be transferred)

* NY (F56CH, 2) 	number of dots in the Y direction (not required to be set; this is already in the top of data to be transferred)

* CDUMMY (F56EH, 1)	dummy (not required to be set) * ARG (F56FH, 1)	selects the direction and expansion RAM (same as VDP R#45) * LOGOP (F570H, 1)	logical operation code (same as the logical operation code of VDP)

Output:	the CY flag is set when there is an error in the parameter

Registers:	all



* BLTDV (01A1H/SUB)



Function:	transfers from VRAM to disk

Input:	HL register <-- F562H

The following parameters should be set:

* SX (F562H, 2) 	X-coordinate of the source * SY (F564H, 2) 	Y-coordinate of the source * FNPTR (F566H, 2)	address of the filename * DUMMY (F568H, 2)	dummy (not required to be set) * NX (F56AH, 2) 	number of dots in the X direction * NY (F56CH, 2) 	number of dots in the Y direction * CDUMMY (F56EH, 1)	dummy (not required to be set)

Output:	the CY flag is reset

Registers:	all



* BLTMD (01A5H/SUB)



Function:	loads array data from disk

Input:	HL register <-- F562H

The following parameters should be set:

* FNPTR (F562H, 2)	address of the filename * SY (F564H, 2) 	dummy (not required to be set) * SPTR (F566H, 2)	the starting address for loading * EPTR (F568H, 2)	the end address for loading

Output:	the CY flag is reset

Registers:	all



* BLTDM (01A9H/SUB)



Function:	saves array data to disk

Input:	HL register <-- F562H

The following parameters should be set:

* SPTR (F562H, 2)	the starting address for saving * EPTR (F564H, 2)	the end address for saving * FNPTR (F566H, 2)	address of the filename

Output:	the CY flag is reset

Registers:	all



=============================================================================

<i>

Changes from the original in APPENDIX 4:

- Address of FLAGS variable is corrected from FB1BH to FB1CH.



- Address of MCLLEN variable is corrected from FB39H to FB3BH.



- Address of H.FIEL hook is corrected from DE2BH to FE2BH.

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



APPENDIX 4 - WORK AREA LISTING



Figure A.5 shows the map of the MSX2 work area. In this section, the system work area and hook from F380H to FFCAH in the figure are described. The following notation is used. Length is in bytes.



Label name (address, length)

Initial value, contents, purpose

Figure A.5 Work area

FFFF	---------------------------

| slot selection register |

FFFC	|-------------------------|

|	 reserved	 |

FFF8	|-------------------------|

FFF7	| MAIN-ROM slot address |

|-------------------------|

| register reservation |

| area for new	 |

FFE7	|	VDP (9938)	 |

|-------------------------|

|	program for	 |

FFCA	| expansion BIOS calls |

|-------------------------|

|			 |

|	hook area	 |

FD9A	|			 |

|-------------------------|

|			 |

| system work area	 |

F380	|			 |

---------------------------



* Subroutines for read/write calls of the inter-slot

RDPRIM (F380H, 5)

contents:	read from basic slot

WRPRIM (F385H, 7)

contents:	write to basic slot

CLPRIM (F38CH, 14)

contents:	basic slot call

* Starting address of assembly language program of USR function, text screen

USRTAB (F39AH, 20)

initial value: FCERR

contents:	starting address of assembly language program of USR function (0 to 9); the value before defining assembly language program points to FCERR (475AH).



LINL40 (F3AEH, 1)

initial value: 39

contents:	screen width per line at SCREEN 0 (set by WIDTH statement at SCREEN 0)



LINL32 (F3AfH, 1)

initial value: 32

contents:	screen width per line at SCREEN 1 (set by WIDTH statement at SCREEN 1)



LINLEN (F3B0H, 1)

initial value: 29

contents:	current screen width per line

CRTCNT (F3B1H, 1)

initial value: 24

contents:	number of lines of current screen

CLMLST (F3B2H, 1)

initial value: 14

contents:	horizontal location in the case that items are divided by commas in PRINT statement

* Work for initialisation



- SCREEN 0



TXTNAM (F3B3H, 2)

initial value: 0000H

contents:	pattern name table

TXTCOL (F3B5H, 2)

contents:	unused

TXTCGP (F3B7H, 2)

initial value: 0800H

contents:	pattern generator table

TXTATR (F3B9H, 2)

contents:	unused

TXTPAT (F3BBH, 2)

contents:	unused

- SCREEN 1



T32NAM (F3BDH, 2)

initial value: 1800H

contents:	pattern name table

T32COL (F3BFH, 2)

initial value: 2000H

contents:	colour table

T32CGP (F3C1H, 2)

initial value: 0000H

contents:	pattern generator table

T32ATR (F3C3H, 2)

initial value: 1B00H

contents:	sprite attribute table

T32PAT (F3C5H, 2)

initial value: 3800H

contents:	sprite generator table

- SCREEN 2



GRPNAM (F3C7H, 2)

initial value: 1800H

contents:	pattern name table

GRPCOL (F3C9H, 2)

initial value: 2000H

contents:	colour table

GRPCGP (F3CBH, 2)

initial value: 0000H

contents:	pattern generator table

GRPATR (F3CDH, 2)

initial value: 1B00H

contents:	sprite attribute table

GRPPAT (F3CFH, 2)

initial value: 3800H

contents:	sprite generator table

- SCREEN 3



MLTNAM (F3D1H, 2)

initial value: 0800H

contents:	pattern name table

MLTCOL (F3D3H, 2)

contents:	unused

MLTCGP (F3D5H, 2)

initial value: 0000H

contents:	pattern generator table

MLTATR (F3D7H, 2)

initial value: 1B00H

contents:	sprite attribute table

MLTPAT (F3D9H, 2)

initial value: 3800H

contents:	sprite generator table

* Other screen settings



CLIKSW (F3DBH, 1)

initial value: 1

contents:	key click switch (0 = OFF, otherwise = ON), set by <key click switch> of SCREEN statement

CSRY (F3DCH, 1)

initial value: 1

contents:	Y-coordinate of cursor

CSRX (F3DDH, 1)

initial value: 1

contents:	X-coordinate of cursor

CNSDFG (F3DEH, 1)

initial value: 0

contents:	function key display switch (0 = display, otherwise = no display), set by KEY ON/OFF statement

* Area to save VDP registers



RG0SAV (F3DFH, 1)

initial value: 0



RG1SAV (F3E0H, 1)

initial value: E0H



RG2SAV (F3E1H, 1)

initial value: 0



RG3SAV (F3E2H, 1)

initial value: 0



RG4SAV (F3E3H, 1)

initial value: 0



RG5SAV (F3E4H, 1)

initial value: 0



RG6SAV (F3E5H, 1)

initial value: 0



RG7SAV (F3E6H, 1)

initial value: 0



STATFL (F3E7H, 1)

initial value: 0

contents:	stores VDP status (contents of status register 0, in MSX2)

TRGFLG (F3E8H, 1)

initial value: FFH

contents:	stores trigger button status of joystick

FORCLR (F3E9H, 1)

initial value: 15

contents:	foreground colour; set by colour statement

BAKCLR (F3EAH, 1)

initial value: 4

contents:	background colour; set by colour statement

BDRCLR (F3EBH, 1)

initial value: 7

contents:	border colour; set by colour statement

MAXUPD (F3ECH, 3)

initial value: JP 0000H (C3H, 00H, 00H) contents:	used by CIRCLE statement internally

MINUPD (F3EFH, 3)

initial value: JP 0000H (C3H, 00H, 00H) contents:	used by CIRCLE statement internally

ATRBYT (F3F2H, 1)

initial value: 15

contents:	colour code in using graphics

* Work area for PLAY statement



QUEUES (F3F3H, 2)

initial value: QUETAB (F959H) contents:	points to queue table at the execution of PLAY statement

FRCNEW (F3F5H), 1)

initial value: 255

contents:	used by BASIC interpreter internally

* Work area for key input



SCNCNT (F3F6H, 1)

initial value: 1

contents:	interval for the key scan

REPCNT (F3F7H, 1)

initial value: 50

contents:	delay until the auto-repeat of the key begins

PUTPNT (F3F8H, 2)

initial value: KEYBUF (FBF0H) contents:	points to address to write in the key buffer

GETPNT (F3FAH, 2)

initial value: KEYBUF (FBF0H) contents:	points to address to read from key buffer

* Parameters for Cassette



CS120 (F3FCH, 5*2)



- 1200 baud



contents:	83 (LOW01) ............ Low width representing bit 0

92 (HIGH01) ........... High width representing bit 0

38 (LOW11) ............ Low width representing bit 1

45 (HIGH11) ........... High width representing bit 1

HEADLEN * 2/256 ....... High bytes (HEDLEN = 2000) of header bits for short header



- 2400 baud



contents:	37 (LOW02) ............ Low width representing bit 0

45 (HIGH02) ........... High width representing bit 0

14 (LOW12) ............ Low width representing bit 1

22 (HIGH12) ........... High width representing bit 1

HEADLEN * 4/256 ....... High bytes (HEDLEN = 2000) of header bits for short header



LOW (F406H, 2)

initial value: LOW01, HIGH01 (by default, 1200 baud) contents:	width of LOW and HIGH which represents bit 0 of current baud rate; set by <cassette baud rate> of SCREEN statement

HIGH (F408H, 2)

initial value: LOW11, HIGH11 (by default, 1200 baud) contents:	width of LOW and HIGH which represents bit 1 of current baud rate; set by <cassette baud rate> of SCREEN statement

HEADER (F40AH, 1)

initial value: HEADLEN * 2/256 (by default, 1200 baud) contents:	header bit for the short header of current baud rate (HEADLEN = 2000); set by <cassette baud rate> of SCREEN

statement



ASPCT1 (F40BH, 1)

contents:	256/aspect ratio; set by SCREEN statement to use in CIRCLE

statement



ASPCT2 (F40DH, 1)

contents:	256 * aspect ratio; set by SCREEN statement to use in CIRCLE

statement



ENDPRG (F40FH, 5)

initial value: ":"

contents:	false end of program for RESUME NEXT statement

* Work used by BASIC internally



ERRFLG (F414H, 1)

contents:	area to store the error number

LPTPOS (F415H, 1)

initial value: 0

contents:	printer head location

PRTFLG (F416H, 1)

contents:	flag whether to send to printer

NTMSXP (F417H, 1)

contents:	printer (0 = printer for MSX, otherwise not)

RAWPRT (F418H, 1)

contents:	non-zero when printing in raw-mode

VLZADR (F419H, 2)

contents:	address of character to be replaced by VAL function

VLZDAT (F41BH, 1)

contents:	character to be replaced with 0 by VAL function

CURLIN (F41CH, 2)

contents:	currently executing line number of BASIC



KBUF (F41FH, 318)

contents:	crunch buffer; translated into intermediate language from BUF (F55EH)



BUFMIN (F55DH, 1)

initial value: ","

contents:	used in INPUT statement

BUF (F55EH, 258)

contents:	buffer to store characters typed; where direct statements are stored in ASCII code

ENDBUF (F660H, 1)

contents:	prevents overflow of BUF (F55EH)

TTYPOS (F661H, 1)

contents:	virtual cursor location internally retained by BASIC



DIMFLG (F662H, 1)

contents:	used by BASIC internally

VALTYP (F663H, 1)

contents:	used to identify the type of variable

DORES (F664H, 1)

contents:	indicates whether stored word can be crunched

DONUM (F665H, 1)

contents:	flag for crunch

CONTXT (F666H, 2)

contents:	stores text address used by CHRGET



CONSAV (F668H, 1)

contents:	stores token of constant after calling CHRGET



CONTYP (F669H, 1)

contents:	type of stored constant

CONLO (F66AH, 8)

contents:	value of stored constant

MEMSIZ (F672H, 2)

contents:	highest address of memory used by BASIC



STKTOP (F674H, 2)

contents:	address used as stack by BASIC; depending on CLEAR statement

TXTTAB (F676H, 2)

contents:	starting address of BASIC text area

TEMPPT (F768H, 2)

initial value: TEMPST (F67AH) contents:	starting address of unused area of temporary descriptor

TEMPST (F67AH, 3 * NUMTMP)

contents:	area for NUMTEMP



DSCTMP (F698H, 3)

contents:	string descriptor which is the result of string function

FRETOP (F69BH, 2)

contents:	starting address of unused area of string area

TEMP3 (F69DH, 2)

contents:	used for garbage collection or by USR function

TEMP8 (F69FH, 2)

contents:	for garbage collection

ENDFOR (F6A1H, 2)

contents:	stores next address of FOR statement (to begin execution from the next of FOR statement at loops)

DATLIN (F6A3H, 2)

contents:	line number of DATA statement read by READ statement

SUBFLG (F6A5H, 1)

contents:	flag for array for USR function

FLGINP (F6A6H, 1)

contents:	flag used in INPUT or READ



TEMP (F6A7H, 2)

contents:	location for temporary reservation for statement code; used for variable pointer, text address, and others

PTRFLG (F6A9H, 1)

contents:	0 if there is not a line number to be converted,otherwise not

AUTFLG (F6AAH, 1)

contents:	flag for AUTO command validity (non-zero = valid, otherwise invalid)



AUTLIN (F6ABH, 2)

contents:	last input line number

AUTINC (F6ADH, 2)

initial value: 10

contents:	increment value of line number of AUTO command

SAVTXT (F6AFH, 2)

contents:	area to store address of currently executing text; mainly used for error recovery by RESUME statement

ERRLIN (F6B3H, 2)

contents:	line number where an error occurred

DOT (F6B5H, 2)

contents:	last line number which was displayed in screen or entered

ERRTXT (F6B7H, 2)

contents:	text address which caused an error; mainly used for error recovery by RESUME statement

ONELIN (F6B9H, 2)

contents:	text address to which control jumps at error; set by ON

ERROR GOTO statement

ONEFLG (F6BBH, 1)

contents:	flag which indicates error routine execution (non-zero = in execution, otherwise not)

TEMP2 (F6BCH, 2)

contents:	for temporary storage

OLDLIN (F6BEH, 2)

contents:	line number which was terminated by Ctrl+STOP, STOP

instruction, END instruction, or was executed last

OLDTXT (F6C0H, 2)

contents:	address to be executed next

VARTAB (F6C2H, 2)

contents:	starting address of simple variable; executing NEW statement causes [contents of TXTTAB(F676H) + 2] to be set

ARYTAB (F6C4H, 2)

contents:	starting address of array table

STREND (F6C6H, 2)

contents:	last address of memory in use as text area or variable area

DATPTR (F6C8H, 2)

contents:	text address of data read by executing READ statement

DEFTBL (F6CAH, 26)

contents:	area to store type of variable for one alphabetical character; depends on type declaration such as CLEAR, DEFSTR, !, or #



* Work for user function parameter



PRMSTK (F6E4H, 2)

contents:	previous definition block on stack (for garbage collection)

PRMLEN (F6E6H, 2)

contents:	number of bytes of objective data

PARM1 (F6E8H, PRMSIZ)

contents:	objective parameter definition table; PRMSIZ is number of bytes of definition block, initial value is 100



PRMPRV (F74CH, 2)

initial value: PRMSTK

contents:	pointer to previous parameter block (for garbage collection)

PRMLN2 (F74EH, 2)

contents:	size of parameter block

PARM2 (F750H, 100)

contents:	for parameter storage

PRMFLG (F7B4H, 1)

contents:	flag to indicate whether PARM1 was searched

ARYTA2 (F7B5H, 2)

contents:	end point of search

NOFUNS (F7B7H, 1)

contents:	0 if there is not an objective function

TEMP9 (F7B8H, 2)

contents:	location of temporary storage for garbage collection

FUNACT (F7BAH, 2)

contents:	number of objective functions

SWPTMP (F7BCH, 8)

contents:	location of temporary storage of the value of the first variable of SWAP statement

TRCFLG (F7C4H, 1)

contents:	trace flag (non-zero = TRACE ON, 0 = TRACE OFF)

* Work for Math-Pack



FBUFFR (F7C5H, 43)

contents:	used internally by Math-Pack

DECTMP (F7F0H, 2)

contents:	used to transform decimal integer to floating-point number

DECTM2 (F7F2H, 2)

contents:	used at division routine execution

DECCNT (F7F4H, 2)

contents:	used at division routine execution

DAC (F7F6H, 16)

contents:	area to set the value to be calculated

HOLD8 (F806H, 48)

contents:	register storage area for decimal multiplication

HOLD2 (F836H, 8)

contents:	used internally by Math-Pack

HOLD (F83EH, 8)

contents:	used internally by Math-Pack

ARG (F847H, 16)

contents:	area to set the value to be calculated with DAC (F7F6H)

RNDX (F857H, 8)

contents:	stores last random number in double precision real number; set by RND function

* Data area used by BASIC interpreter



MAXFIL (F85FH, 1)

contents:	maximum file number; set by MAXFILES statement

FILTAB (F860H, 2)

contents:	starting address of file data area

NULBUF (F862H, 2)

contents:	points to buffer used in SAVE and LOAD by BASIC interpreter

PTRFIL (F864H, 2)

contents:	address of file data of currently accessing file

RUNFLG (F866H, 2)

contents:	non-zero value if program was loaded and executed; used by R option of LOAD statement

FILNAM (F866H, 11)

contents:	area to store filename

FILNM2 (F871H, 11)

contents:	area to store filename

NLONLY (F87CH, 1)

contents:	non-zero value if program is being loaded

SAVEND (F87DH, 2)

contents:	end address of assembly language program to be saved

FNKSTR (F87FH, 160)

contents:	area to store function key string (16 character x 10)

CGPNT (F91FH, 3)

contents:	address to store character font on ROM



NAMBAS (F922H, 2)

contents:	base address of current pattern name table

CGPBAS (F924H, 2)

contents:	base address of current pattern generator table

PATBAS (F926H, 2)

contents:	base address of current sprite generator table

ATRBAS (F928H, 2)

contents:	base address of current sprite attribute table

CLOC (F92AH, 2)

contents:	used internally by graphic routine

CMASK (F92CH, 1)

contents:	used internally by graphic routine

MINDEL (F92DH, 1)

contents:	used internally by graphic routine

MAXDEL (F92FH, 2)

contents:	used internally by graphic routine

* Data area used by CIRCLE statement



ASPECT (F931H, 2)

contents:	aspect ratio of the circle; set by <ratio> of CIRCLE

statement



CENCNT (F933H, 2)

contents:	used internally by CIRCLE statement

CLINEF (F935H, 1)

contents:	flag whether a line is drawn toward the center; specified by <angle> of CIRCLE statement

CNPNTS (F936H, 2)

contents:	point to be plotted

CPLOTF (F938H, 1)

contents:	used internally by CIRCLE statement

CPCNT (F939H, 2)

contents:	number of one eight of the circle

CPNCNT8 (F93BH, 2)

contents:	used internally by CIRCLE statement

CPCSUM (F93DH, 2)

contents:	used internally by CIRCLE statement

CSTCNT (F93FH, 2)

contents:	used internally by CIRCLE statement

CSCLXY (F941H, 1)

contents:	scale of x and y

CSAVEA (F942H, 2)

contents:	reservation area of ADVGRP



CSAVEM (F944H, 1)

contents:	reservation area of ADVGRP



CXOFF (F945H, 2)

contents:	x offset from the center

CYOFF (F947H, 2)

contents:	y offset from the center

* Data area used in PAINT statement



LOHMSK (F949H, 1)

contents:	used internally by PAINT statement

LOHDIR (F94AH, 1)

contents:	used internally by PAINT statement

LOHADR (F94BH, 2)

contents:	used internally by PAINT statement

LOHCNT (F94DH, 2)

contents:	used internally by PAINT statement

SKPCNT (F94FH, 2)

contents:	skip count

MIVCNT (F951H, 2)

contents:	movement count

PDIREC (F953H, 1)

contents:	direction of the paint

LFPROG (F954H, 1)

contents:	used internally by PAINT statement

RTPROG (F955H, 1)

contents:	used internally by PAINT statement

* Data area used in PLAY statement



MCLTAB (F956H, 2)

contents:	points to the top of the table of PLAY macro or DRAW macro

MCLFLG (F958H, 1)

contents:	assignment of PLAY/DRAW



QUETAB (F959H, 24)

contents:	queue table +0: PUT offset

+1: GET offset

+2: backup character +3: queue length +4: queue address





+5: queue address




QUEBAK (F971H, 4)

contents:	used in BCKQ



VOICAQ (F975H, 128)

contents:	queue of voice 1 (1 = a)

VOICBQ (F9F5H, 128)

contents:	queue of voice 2 (2 = b)

VOICCQ (FA75H, 128)

contents:	queue of voice 3 (3 = c)

* Work area added in MSX2



DPPAGE (FAF5H, 1)

contents:	display page number

ACPAGE (FAF6H, 1)

contents:	active page number

AVCSAV (FAF7H, 1)

contents:	reserves AV control port

EXBRSA (FAF8H, 1)

contents:	SUB-ROM slot address

CHRCNT (FAF9H, 1)

contents:	character counter in the buffer; used in Roman-kana translation (value is 0 <=n <=2)

ROMA (FAFAH, 2)

contents:	area to store character in the buffer; used in Roman-kana translation (Japan version only)

MODE (FAFCH, 1)

contents:	mode switch for VRAM size

(0000WVV0)

---

|||

|++--- 00 = 16K VRAM

|	 01 = 64K VRAM

|	 11 = 128K VRAM

|

+----- 1 = mask, 0 = no mask Flags whether to specify VRAM address ANDed with 3FFFH in SCREEN 0 to 3; in SCREEN 4 to 8, never masked

NORUSE (FAFDH, 1)

contents:	unused

XSAVE (FAFEH, 2)

contents:	[ I OOOOOOO XXXXXXXX ]



YSAVE (FB00H, 2)

contents:	[ x OOOOOOO YYYYYYYY ]



I = 1 lightpen interrupt request OOOOOOO = unsigned offset XXXXXXX = X-coordinate YYYYYYY = Y-coordinate

LOGOPR (FB02H, 1)

contents:	logical operation code

* Data area used by RS-232C



RSTMP (FB03H, 50)

contents:	work area for RS-232C or disk

TOCNT (FB03H, 1)

contents:	used internally by RS-232C routine

RSFCB (FB04H, 2)

contents:	FB04H + 0: LOW address of RS-232C

FB04H + 1: HIGH address of RS-232C



RSIQLN (FB06H, 5)

contents:	used internally by RS-232C routine

MEXBIH (FB07H, 5)

contents:	FB07H +0: RST 30H (0F7H) FB07H +1: byte data FB07H +2: (Low) FB07H +3: (High) FB07H +4: RET (0C9H)

OLDSTT (FB0CH, 5)

contents:	FB0CH +0: RST 30H (0F7H) FB0CH +1: byte data FB0CH +2: (Low) FB0CH +3: (High) FB0CH +4: RET (0C9H)

OLDINT (FB12H, 5)

contents:	FB12H +0: RST 30H (0F7H) FB12H +1: byte data FB12H +2: (Low) FB12H +3: (High) FB12H +4: RET (0C9H)

DEVNUM (FB17H, 1)

contents:	used internally by RS-232C routine

DATCNT (FB18H, 3)

contents:	FB18H +0: byte data FB18H +1: byte pointer FB12H +2: byte pointer

ERRORS (FB1BH, 1)

contents:	used internally by RS-232C routine

FLAGS (FB1CH, 1)

contents:	used internally by RS-232C routine

ESTBLS (FB1DH, 1)

contents:	used internally by RS-232C routine

COMMSK (FB1EH, 1)

contents:	used internally by RS-232C routine

LSTCOM (FB1FH, 1)

contents:	used internally by RS-232C routine

LSTMOD (FB20H, 1)

contents:	used internally by RS-232C routine

* Data area used by DOS



reserved (FB21H to FB34H)

contents:	used by DOS



* Data area used by PLAY statement

(the following is the same as with MSX1)

PRSCNT (FB35H, 1)

contents:	D1 to D0	string parse D7 = 0		1 pass



SAVSP (FB36H, 2)

contents:	reserves stack pointer in play

VOICEN (FB38H, 1)

contents:	current interpreted voice

SAVVOL (FB39H, 2)

contents:	reserves volume for the pause

MCLLEN (FB3BH, 1)

contents:	used internally by PLAY statement

MCLPTR (FB3CH, 1)

contents:	used internally by PLAY statement

QUEUEN (FB3EH, 1)

contents:	used internally by PLAY statement

MUSICF (FC3FH, 1)

contents:	interrupt flag for playing music

PLYCNT (FB40H, 1)

contents:	number of PLAY statements stored in the queue

* Offset from voice static data area

(offset is in decimal)

METREX (+0, 2)

contents:	timer count down

VCXLEN (+2, 1)

contents:	MCLLEN for this voice

VCXPTR (+3, 2)

contents:	MCLPTR for this voice

VCXSTP (+5, 2)

contents:	reserves the top of the stack pointer

QLENGX (+7, 1)

contents:	number of bytes stored in the queue

NTICSX (+8, 2)

contents:	new count down

TONPRX (+10, 2)

contents:	area to set tone period

AMPPRX (+12, 1)

contents:	discrimination of volume and enveloppe

ENVPRX (+13, 2)

contents:	area to set enveloppe period

OCTAVX (+15, 1)

contents:	area to set octave

NOTELX (+16, 1)

contents:	area to set tone length

TEMPOX (+17, 1)

contents:	area to set tempo

VOLUMX (+18, 1)

contents:	area to set volume

ENVLPX (+19, 14)

contents:	area to set enveloppe wave form

MCLSTX (+33, 3)

contents:	reservation area of stack

MCLSEX (+36, 1)

contents:	initialisation stack

VCBSIZ (+37, 1)

contents:	static buffer size

* Voice static data area



VCBA (FB41H, 37)

contents:	static data for voice 0



VCBB (FB66H, 37)

contents:	static data for voice 1



VCBC (FB8BH, 37)

contents:	static data for voice 2



* Data area



ENSTOP (FBB0H, 1)

contents:	flag to enable warm start by [SHIFT+Ctrl+Kana key]

(0 = disable, otherwise enable)

BASROM (FBB1H, 1)

contents:	indicates BASIC text location (0 = on RAM, otherwise in ROM)

LINTTB (FBB2H, 24)

contents:	line terminal table; area to keep information about each line of text screen

FSTPOS (FBCAH, 2)

contents:	first character location of line from INLIN (00B1H) of BIOS



CODSAV (FBCCH, 1)

contents:	area to reserve the character where the cursor is stacked

FNKSW1 (FBCDH, 1)

contents:	indicates which function key is displayed at KEY ON

(1 = F1 to F5 is displayed, 0 = F6 to F10 is displayed)

FNKFLG (FBCEH, 10)

contents:	area to allow, inhibit, or stop the execution of the line defined in ON KEY GOSUB statement, or to reserve it for each function key; set by KEY(n)ON/OFF/STOP statement (0 = KEY(n)OFF/STOP, 1= KEY(n)ON)

ONGSBF (FBD8H, 1)

contents:	flag to indicate whether event waiting in TRPTBL (FC4CH) occurred



CLIKFL (FBD9H, 1)

contents:	key click flag

OLDKEY (FBDAH, 11)

contents:	key matrix status (old)

NEWKEY (FBE5H, 11)

contents:	key matrix status (new)

KEYBUF (FBF0H, 40)

contents:	key code buffer

LINWRK (FC18H, 40)

contents:	temporary reservation location used by screen handler

PATWRK (FC40H, 8)

contents:	temporary reservation location used by pattern converter

BOTTOM (FC48H, 2)

contents:	installed RAM starting (low) address; ordinarily 8000H

in MSX2



HIMEM (FC4AH, 2)

contents:	highest address of available memory; set by <memory upper limit> of CLEAR statement

TRAPTBL (FC4CH, 78)

contents:	trap table used to handle interrupt; one table consists of three bytes, where first byte indicates ON/OFF/STOP status and the rest indicate the text address to be jumped to

FC4CH to FC69H (3 * 10 bytes)	used in ON KEY GOSUB

FC6AH to FC6CH (3 * 1 byte)	used in ON STOP GOSUB

FC6DH to FC6FH (3 * 1 byte)	used in ON SPRITE GOSUB

FC70H to FC7EH (3 * 5 bytes)	used in ON STRIG GOSUB

FC7FH to FC81H (3 * 1 byte)	used in ON INTERVAL GOSUB

FC82H to FC99H			for expansion

RTYCNT (FC9AH, 1)

contents:	used internally by BASIC



INTFLG (FC9BH, 1)

contents:	if Ctrl+STOP is pressed, setting 03H here causes a stop

PADY (FC9CH, 1)

contents:	Y-coordinate of the paddle)

PADX (FC9DH, 1)

contents:	X-coordinate of the paddle)

JIFFY (FC9EH, 2)

contents:	used internally by PLAY statement

INTVAL (FCA0H, 2)

contents:	interval period; set by ON INTERVAL GOSUB statement

INTCNT (FCA2H, 2)

contents:	counter for interval

LOWLIM (FCA4H, 1)

contents:	used during reading from cassette tape

WINWID (FCA5H, 1)

contents:	used during reading from cassette tape

GRPHED (FCA6H, 1)

contents:	flag to send graphic character (1 = graphic character, 0 = normal character)

ESCCNT (FCA7H, 1)

contents:	area to count from escape code

INSFLG (FCA8H, 1)

contents:	flag to indicate insert mode (0 = normal mode, otherwise = insert mode)

CSRSW (FCA9H, 1)

contents:	whether cursor is displayed (0 = no, otherwise = yes); set by <cursor swicth> of LOCATE statement

CSTYLE (FCAAH, 1)

contents:	cursor shape (0 = block, otherwise = underline)

CAPST (FCABH, 1)

contents:	CAPS key status (0 = CAP OFF, otherwise = CAP ON)

KANAST (FCACH, 1)

contents:	kana key status (0 = kaka OFF, otherwise = kana ON)

KANAMD (FCADH, 1)

contents:	kana key arrangement status (0 = 50-sound arrangement, otherwise = JIS arrangement)

FLBMEM (FCAEH, 1)

contents:	0 when loading BASIC program

SCRMOD (FCAFH, 1)

contents:	current screen mode number

OLDSCR (FCB0H, 1)

contents:	screen mode reservation area

CASPRV (FCB1H, 1)

contents:	character reservation area used by CAS:

BRDATR (FCB2H, 1)

contents:	border colour code used by PAINT; set by <border colour> in PAINT statement

GXPOS (FCB3H, 2)

contents:	X-coordinate

GYPOS (FCB5H, 2)

contents:	Y-coordinate

GRPACX (FCB7H, 2)

contents:	graphic accumulator (X-coordinate)

GRPACY (FCB9H, 2)

contents:	graphic accumulator (Y-coordinate)

DRWFLG (FCBBH, 1)

contents:	flag used in DRAW statement

DRWSCL (FCBCH, 1)

contents:	DRAW scaling factor (0 = no scaling, otherwise = scaling)

DRWANG (FCBDH, 1)

contents:	angle at DRAW



RUNBNF (FCBEH, 1)

contents:	flag to indicate BLOAD in progress, BSAVE in progress, or neither



SAVENT (FCBFH, 2)

contents:	starting address of BSAVE



EXPTBL (FCC1H, 4)

contents:	flag table for expansion slot; whether the slot is expanded

SLTTBL (FCC5H, 4)

contents:	current slot selection status for each expansion slot register



SLTATR (FCC9H, 64)

contents:	reserves attribute for each slot

SLTWRK (FD09H, 128)

contents:	allocates specific work area for each slot

PROCNM (FD89H, 16)

contents:	stores name of expanded statement (after CALL statement) or expansion device (after OPEN); 0 indicates the end

DEVICE (FD99H, 1)

contents:	used to identify cartridge device

* Hooks



H.KEYI (FD9AH)

meaning:	beginning of MSXIO interrupt handling purpose:	adds the interrupt operation such as RS-232C



H.TIMI (FD9FH)

meaning:	MSXIO timer interrupt handling purpose:	adds the timer interrupt handling

H.CHPH (FDA4H)

meaning:	beginning of MSXIO CHPUT (one character output) purpose:	connects other console device

H.DSPC (FDA9H)

meaning:	beginning of MSXIO DSPCSR (cursor display) purpose:	connects other console device

H.ERAC (FDAEH)

meaning:	beginning of MSXIO ERACSR (erase cursor) purpose:	connects other console device

H.DSPF (FDB3H)

meaning:	beginning of MSXIO DSPFNK (function key display) purpose:	connects other console device

H.ERAF (FDB8H)

meaning:	beginning of MSXIO ERAFNK (erase function key) purpose:	connects other console device

H.TOTE (FDBDH)

meaning:	beginning of MSXIO TOTEXT (set screen in text mode) purpose:	connects other console device

H.CHGE (FDC2H)

meaning:	beginning of MSXIO CHGET (get one character) purpose:	connects other console device

H.INIP (FDC7H)

meaning:	beginning of MSXIO INIPAT (character pattern initialisation) purpose:	uses other character set

H.KEYC (FDCCH)

meaning:	beginning of MSXIO KEYCOD (key code translation) purpose:	uses other key arrangement

H.KYEA (FDD1H)

meaning:	beginning of MSXIO NMI routine (Key Easy) purpose:	uses other key arrangement

H.NMI (FDD6H)

meaning:	beginning of MSXIO NMI (non-maskable interrupt) purpose:	handles NMI

H.PINL (FDDBH)

meaning:	beginning of MSXIO PINLIN (one line input) purpose:	uses other console input device or other input method

H.QINL (FDE0H)

meaning:	beginning of MSXINL QINLIN (one line input displaying "?") purpose:	uses other console input device or other input method

H.INLI (FDE5H)

meaning:	beginning of MSXINL INLIN (one line input) purpose:	uses other console input device or other input method

H.ONGO (FDEAH)

meaning:	beginning of MSXSTS INGOTP (ON GOTO) purpose:	uses other interrupt handling device

H.DSKO (FDEFH)

meaning:	beginning of MSXSTS DSKO$ (disk output) purpose:	connects disk device

H.SETS (FDF4H)

meaning:	beginning of MSXSTS SETS (set attribute) purpose:	connects disk device

H.NAME (FDF9H)

meaning:	beginning of MSXSTS NAME (rename) purpose:	connects disk device

H.KILL (FDFEH)

meaning:	beginning of MSXSTS KILL (delete file) purpose:	connects disk device

H.IPL (FE03H)

meaning:	beginning of MSXSTS IPL (initial program loading) purpose:	connects disk device

H.COPY (FE08H)

meaning:	beginning of MSXSTS COPY (file copy) purpose:	connects disk device

H.CMD (FE0DH)

meaning:	beginning of MSXSTS CMD (expanded command) purpose:	connects disk device

H.DSKF (FE12H)

meaning:	beginning of MSXSTS DSKF (unusde disk space) purpose:	connects disk device

H.DSKI (FE17H)

meaning:	beginning of MSXSTS DSKI (disk input) purpose:	connects disk device

H.ATTR (FE1CH)

meaning:	beginning of MSXSTS ATTR$ (attribute) purpose:	connects disk device

H.LSET (FE21H)

meaning:	beginning of MSXSTS LSET (left-padded assignment) purpose:	connects disk device

H.RSET (FE26H)

meaning:	beginning of MSXSTS RSET (right-padded assignment) purpose:	connects disk device

H.FIEL (FE2BH)

meaning:	beginning of MSXSTS FIELD (field) purpose:	connects disk device

H.MKI$ (FE30H)

meaning:	beginning of MSXSTS MKI$ (create integer) purpose:	connects disk device

H.MKS$ (FE35H)

meaning:	beginning of MSXSTS MKS$ (create single precision real) purpose:	connects disk device

H.MKD$ (FE3AH)

meaning:	beginning of MSXSTS MKD$ (create double precision real) purpose:	connects disk device

H.CVI (FE3FH)

meaning:	beginning of MSXSTS CVI (convert integer) purpose:	connects disk device

H.CVS (FE44H)

meaning:	beginning of MSXSTS CVS (convert single precision real) purpose:	connects disk device

H.CVD (FE49H)

meaning:	beginning of MSXSTS CVS (convert double precision real) purpose:	connects disk device

H.GETP (FE4EH)

meaning:	SPDSK GETPTR (get file pointer) purpose:	connects disk device

H.SETF (FE53H)

meaning:	SPCDSK SETFIL (set file pointer) purpose:	connects disk device

H.NOFO (FE58H)

meaning:	SPDSK NOFOR (OPEN statement without FOR) purpose:	connects disk device

H.NULO (FE5DH)

meaning:	SPCDSK NULOPN (open unused file) purpose:	connects disk device

H.NTFL (FE62H)

meaning:	SPCDSK NTFLO (file number is not 0) purpose:	connects disk device

H.MERG (FE67H)

meaning:	SPCDSK MERGE (program file merge) purpose:	connects disk device

H.SAVE (FE6CH)

meaning:	SPCDSK SAVE (save) purpose:	connects disk device

H.BINS (FE71H)

meaning:	SPCDSK BINSAV (save in binary) purpose:	connects disk device

H.BINL (FE76H)

meaning:	SPCDSK BINLOD (load in binary) purpose:	connects disk device

H.FILE (FD7BH)

meaning:	SPCDSK FILES (displey filename) purpose:	connects disk device

H.DGET (FE80H)

meaning:	SPCDSK DGET (disk GET) purpose:	connects disk device

H.FILO (FE85H)

meaning:	SPCDSK FILOU1 (file output) purpose:	connects disk device

H.INDS (FE8AH)

meaning:	SPCDSK INDSKC (disk attribute input) purpose:	connects disk device

H.RSLF (FE8FH)

meaning:	SPCDSK; re-select previous drive purpose:	connects disk device

H.SAVD (FE94H)

meaning:	SPCDSK; reserve current disk purpose:	connects disk device

H.LOC (FE99H)

meaning:	SPCDSK LOC function (indicate location) purpose:	connects disk device

H.LOF (FE9EH)

meaning:	SPCDSK LOC function (file length) purpose:	connects disk device

H.EOF (FEA3H)

meaning:	SPCDSK EOF function (end of file) purpose:	connects disk device

H.FPOS (FEA8H)

meaning:	SPCDSK FPOS function (file location) purpose:	connects disk device

H.BAKU (FEADH)

meaning:	SPCDSK BAKUPT (backup) purpose:	connects disk device

H.PARD (FEB2H)

meaning:	SPCDEV PARDEV (get peripheral name) purpose:	expands logical device name

H.NODE (FEB7H)

meaning:	SPCDEV NODEVN (no device name) purpose:	sets default device name to other device

H.POSD (FEBCH)

meaning:	SPCDEV POSDSK

purpose:	connects disk device

H.DEVN (FEC1H)

meaning:	SPCDEV DEVNAM (process device name) purpose:	expands logical device name

H.GEND (FEC6H)

meaning:	SPCDEV GENDSP (FEC6H) purpose:	expands logical device name

H.RUNC (FECBH)

meaning:	BIMISC RUNC (clear for RUN)

H.CLEAR (FED0H)

meaning:	BIMISC CLEARC (clear for CLEAR statement)

H.LOPD (FED5H)

meaning:	BIMISC LOPDFT (set loop and default value) purpose:	uses other default value for variable

H.STKE (FEDAH)

meaning:	BIMISC STKERR (stack error)

H.ISFL (FEDFH)

meaning:	BIMISC ISFLIO (file input-output or not)

H.OUTD (FEE4H)

meaning:	BIO OUTDO (execute OUT)

H.CRDO (FEE9H)

meaning:	BIO CRDO (execute CRLF)

H.DSKC (FEEEH)

meaning:	BIO DSKCHI (input disk attribute)

H.DOGR (FEF3H)

meaning:	GENGRP DOGRPH (execute graphic operation)

H.PRGE (FEF8H)

meaning:	BINTRP PRGEND (program end)

H.ERRP (FEFDH)

meaning:	BINTRP ERRPTR (error display)

H.ERRF (FF02H)

meaning:	BINTRP



H.READ (FF07H)

meaning:	BINTRP READY



H.MAIN (FF0CH)

meaning:	BINTRP MAIN



H.DIRD (FF11H)

meaning:	BINTRP DIRDO (execute direct statement)

H.FINI (FF16H)

meaning:	BINTRP



H.FINE (FF1BH)

meaning:	BINTRP



H.CRUN (FF20H)

meaning:	BINTRP



H.CRUN (FF20H)

meaning:	BINTRP



H.CRUS (FF25H)

meaning:	BINTRP



H.ISRE (FF2AH)

meaning:	BINTRP



H.NTFN (FF2FH)

meaning:	BINTRP



H.NOTR (FF34H)

meaning:	BINTRP



H.SNGF (FF39H)

meaning:	BINTRP



H.NEWS (FF3EH)

meaning:	BINTRP



H.GONE (FF43H)

meaning:	BINTRP



H.CHRG (FF48H)

meaning:	BINTRP



H.RETU (FF4DH)

meaning:	BINTRP



H.PRTF (FF52H)

meaning:	BINTRP



H.COMP (FF57H)

meaning:	BINTRP



H.FINP (FF5CH)

meaning:	BINTRP



H.TRMN (FF61H)

meaning:	BINTRP



H.FRME (FF66H)

meaning:	BINTRP



H.NTPL (FF6BH)

meaning:	BINTRP



H.EVAL (FF70H)

meaning:	BINTRP



H.OKNO (FF75H)

meaning:	BINTRP



H.FING (FF7AH)

meaning:	BINTRP



H.ISMI (FF7FH)

meaning:	BINTRP ISMID$ (MID$ or not)

H.WIDT (FF84H)

meaning:	BINTRP WIDTHS (WIDTH)

H.LIST (FF89H)

meaning:	BINTRP LIST



H.BUFL (FF8EH)

meaning:	BINTRP BUFLIN (buffer line)

H.FRQI (FF93H)

meaning:	BINTRP FRQINT



H.SCNE (FF98H)

meaning:	BINTRP



H.FRET (FF9DH)

meaning:	BINTRP FRETMP



H.PTRG (FFA2H)

meaning:	BIPTRG PTRGET (get pointer) purpose:	uses variable other than default value

H.PHYD (FFA7H)

meaning:	MSXIO PHYDIO (physical disk input-output) purpose:	connects disk device

H.FORM (FFACH)

meaning:	MSXIO FORMAT (format disk) purpose:	connects disk device

H.ERRO (FFB1H)

meaning:	BINTRP ERROR

purpose:	error handling for application program

H.LPTO (FFB6H)

meaning:	MSXIO LPTOUT (printer output) purpose:	uses printer other than default value

H.LPTS (FFBBH)

meaning:	MSXIO LPTSTT (printer status) purpose:	uses printer other than default value

H.SCRE (FFC0H)

meaning:	MSXSTS SCREEN statement entry purpose:	expands SCREEN statement

H.PLAY (FFC5H)

meaning:	MSXSTS PLAY statement entry purpose:	expands PLAY statement

* For expanded BIOS



FCALL (FFCAH)

contents:	hook used by expanded BIOS



DISINT (FFCFH)

contents:	used by DOS



ENAINT (FFD4H)

contents:	used by DOS



=============================================================================

<i>

Changes from the original in APPENDIX 5:

- The original VRAM mapping figures have been converted to simple text tables.



- In SCREEN 0 (WIDTH 80) map, different end addresses for the blink table are indicated for 24 lines mode and 26.5 lines mode.

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



APPENDIX 5 - VRAM MAP



* SCREEN 0 (WIDTH 40) / TEXT 1



0000H - 03BFH	-->	Pattern name table 0400H - 042FH	-->	Palette table

0800H - 0FFFH	-->	Pattern generator table

* SCREEN 0 (WIDTH 80) / TEXT 2



0000H - 077FH	-->	Pattern name table 0800H - 08EFH	-->	Blink table (24 lines mode) 090DH			 (26.5 lines mode) 0F00H - 0F2FH	-->	Palette table

1000H - 17FFH	-->	Pattern generator table

* SCREEN 1 / GRAPHIC 1



0000H - 07FFH	-->	Pattern generator table 1800H - 1AFFH	-->	Pattern name table 1B00H - 1B7FH	-->	Sprite attribute table 2000H - 201FH	-->	Colour table

2020H - 204FH	-->	Palette table

3800H - 3FFFH	-->	Sprite generator table

* SCREEN 2 / GRAPHIC 2



0000H - 07FFH	-->	Pattern generator table 1

0800H - 0FFFH	-->	Pattern generator table 2

1000H - 17FFH	-->	Pattern generator table 3

1800H - 18FFH	-->	Pattern name table 1

1900H - 19FFH	-->	Pattern name table 2

1A00H - 1AFFH	-->	Pattern name table 3

1B00H - 1B7FH	-->	Sprite attribute table 1B80H - 1BAFH	-->	Palette table

2000H - 27FFH	-->	Colour table 1

2800H - 2FFFH	-->	Colour table 2

3000H - 37FFH	-->	Colour table 3

3800H - 3FFFH	-->	Sprite generator table

* SCREEN 3 / MULTI COLOUR



0000H - 07FFH	-->	Pattern generator table 0800H - 0AFFH	-->	Pattern name table 1B00H - 1B7FH	-->	Sprite attribute table 2020H - 204FH	-->	Palette table

3800H - 3FFFH	-->	Sprite generator table

* SCREEN 4 / GRAPHIC 3



0000H - 07FFH	-->	Pattern generator table 1

0800H - 0FFFH	-->	Pattern generator table 2

1000H - 17FFH	-->	Pattern generator table 3

1800H - 18FFH	-->	Pattern name table 1

1900H - 19FFH	-->	Pattern name table 2

1A00H - 1AFFH	-->	Pattern name table 3

1B80H - 1BAFH	-->	Palette table

1C00H - 1DFFH	-->	Sprite colour table 1E00H - 1E7FH	-->	Sprite attribute table 2000H - 27FFH	-->	Colour table 1

2800H - 2FFFH	-->	Colour table 2

3000H - 37FFH	-->	Colour table 3

3800H - 3FFFH	-->	Sprite generator table

* SCREEN 5, 6 / GRAPHIC 4, 5



0000H - 5FFFH	-->	Pattern name table (192 lines) 69FFH				 (212 lines) 7400H - 75FFH	-->	Sprite colour table 7600H - 767FH	-->	Sprite attribute table 7680H - 76AFH	-->	Palette table

7A00H - 7FFFH	-->	Sprite generator table

* SCREEN 7, 8 / GRAPHIC 6, 7



0000H - BFFFH	-->	Pattern name table (192 lines) D3FFH				 (212 lines) F000H - F7FFH	-->	Sprite generator table F800H - F9FFH	-->	Sprite colour table FA00H - FA7FH	-->	Sprite attribute table FA80H - FAAFH	-->	Palette table



=============================================================================

<i>

Changes from the original in APPENDIX 6:

none

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



APPENDIX 6 - I/O MAP



00H to 3FH	user defined



40H to 7FH	reserved



80H to 87H	for RS-232C

80H	8251 data

81H	8251 status/command 82H	status read/interrupt mask 83H	unused

84H	8253

85H	8253

86H	8253

87H	8253



88H to 8BH	VDP (9938) I/O port for MSX1 adaptor This is V9938 I/O for MSX1. To access VDP directly, examine 06H and 07H of MAIN-ROM to confirm the port address



8CH to 8DH	for the modem



8EH to 8FH	reserved



90H to 91H	printer port

90H	bit 0: strobe output (write) bit 1: status input (read) 91H	data to be printed

92H to 97H	reserved



98H to 9BH	for MSX2 VDP (V9938)

98H	VRAM access 99H	command register access 9AH	palette register access (write only) 9BH	register pointer (write only)

9CH to 9FH	reserved



A0H to A3H	sound generator (AY-3-8910) A0H	address latch A1H	data read

A2H	data write



A4H to A7H	reserved



A8H to ABH	parallel port (8255)

A8H	port A

A9H	port B

AAH	port C

ABH	mode set



ACH to AFH	MSX engine (one chip MSX I/O)

B0H to B3H	expansion memory (SONY specification) (8255) A8H	port A, address (A0 to A7) A9H	port B, address (A8 to A10, A13 to A15), control R/"

AAH	port C, address (A11 to A12), data (D0 - D7) ABH	mode set



B4H to B5H	CLOCK-IC (RP-5C01)

B4H	address latch B5H	data



B6H to B7H	reserved



B8H to BBH	lightpen control (SANYO specification) B8H	read/write

B9H	read/write

BAH	read/write

BBH	write only



BCH to BFH	VHD control (JVC) (8255)

BCH	port A

BDH	port B

BEH	port C



C0H to C1H	MSX-Audio



C2H to C7H	reserved



C8H to CFH	MSX interface



D0H to D7H	floppy disk controller (FDC) The floppy disk controller can be interrupted by an external signal. Interrupt is possible only when the FDC is accessed. Thus, the system can treat different FDC interfaces.



D8 to D9H	kanji ROM (TOSHIBA specification) D8H	b5-b0		lower address (write only) D9H	b5-b0		upper address (write) b7-b0		data (read)

DAH to DBH	for future kanji expansion



DCH to F4H	reserved



F5H		system control (write only)

setting bit to 1 enables available I/O devices b0	kanji ROM

b1	reserved for kanji b2	MSX-AUDIO

b3	superimpose

b4	MSX interface b5	RS-232C

b6	lightpen

b7	CLOCK-IC (only on MSX2) Bits to void the conflict between internal I/O

devices or those connected by cartridge. The bits can disable the internal devices. When BIOS is initialised, internal devices are valid if no external devices are connected. Applications may not write to or read from here.



F8H		colour bus I/O



F7H		A/V control

b0	audio R 		mixing ON (write) b1	audio L 		mixing OFF (write) b2	select video input	21p RGB (write) b3	detect video input	no input (read) b4	AV control		TV (write) b5	Ym control		TV (write) b6	inverse of bit 4 of VDP register 9 (write) b7	inverse of bit 5 of VDP register 9 (write)

F8H to FBH	reserved



FCH to FFH	memory mapper



=============================================================================

<i>

Changes from the original in APPENDIX 8:

none

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



APPENDIX 8 - CONTROL CODES



-------------------------------------------------------------------------

| Code | Code | 				 | Corresponding	|

| (dec)| (hex)| 	 Function		 |	 key(s)	|

|------+------+-----------------------------------+---------------------|

| 0 | 00H | 				 | CTRL + @		|

| | | 				 |			|

| 1 | 01H | header at input/output of graphic | CTRL + A		|

| | | characters			 |			|

| | | 				 |			|

| 2 | 02H | move cursor to the top of the	 | CTRL + B		|

| | | previous word			 |			|

| | | 				 |			|

| 3 | 03H | end the input-waiting state	 | CTRL + C		|

| | | 				 |			|

| 4 | 04H | 				 | CTRL + D		|

| | | 				 |			|

| 5 | 05H | delete below cursor		 | CTRL + E		|

| | | 				 |			|

| 6 | 06H | move cursor to the top of the	 | CTRL + F		|

| | | next word			 |			|

| | | 				 |			|

| 7 | 07H | speaker output			 | CTRL + G		|

| | | (same as the BEEP statement)	 |			|

| | | 				 |			|

| 8 | 08H | delete a character before cursor | CTRL + H or BS	|

| | | 				 |			|

| 9 | 09H | move to next horizontal tab stop | CTRL + I or TAB	|

| | | 				 |			|

| 10 | 0AH | line feed			 | CTRL + J		|

| | | 				 |			|

| 11 | 0BH | home cursor			 | CTRL + K or HOME	|

| | | 				 |			|

| 12 | 0CH | clear screen and home cursor	 | CTRL + L or CLS	|

| | | 				 |			|

| 13 | 0DH | carriage return 		 | CTRL + M or RETURN	|

| | | 				 |			|

| 14 | 0EH | move cursor to the end of line	 | CTRL + N		|

| | | 				 |			|

| 15 | 0FH | 				 | CTRL + O		|

| | | 				 |			|

| 16 | 10H | 				 | CTRL + P		|

| | | 				 |			|

| 17 | 11H | 				 | CTRL + Q		|

| | | 				 |			|

| 18 | 12H | insert mode ON/OFF		 | CTRL + R or INS	|

| | | 				 |			|

| 19 | 13H | 				 | CTRL + S		|

| | | 				 |			|

| 20 | 14H | 				 | CTRL + T		|

| | | 				 |			|

| 21 | 15H | delete one line from screen	 | CTRL + U		|

| | | 				 |			|

| 22 | 16H | 				 | CTRL + V		|

| | | 				 |			|

| 23 | 17H | 				 | CTRL + W		|

| | | 				 |			|

| 24 | 18H | 				 | CTRL + X or SELECT	|

| | | 				 |			|

| 25 | 19H | 				 | CTRL + Y		|

| | | 				 |			|

| 26 | 1AH | 				 | CTRL + Z		|

| | | 				 |			|

| 27 | 1BH | 				 | CTRL + [ or ESC	|

| | | 				 |			|

| 28 | 1CH | move cursor right		 | CTRL + \ or RIGHT	|

| | | 				 |			|

| 29 | 1DH | move cursor left		 | CTRL + ] or LEFT	|

| | | 				 |			|

| 30 | 1EH | move cursor up			 | CTRL + ^ or UP	|

| | | 				 |			|

| 31 | 1FH | move cursor down		 | CTRL + _ or DOWN	|

| | | 				 |			|

| 127 | 7FH | delete character under cursor	 |		DEL	|

| | | 				 |			|

-------------------------------------------------------------------------



=============================================================================

<i>

Changes from the original in APPENDIX 10:

none

</i>

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-



APPENDIX 10 - ESCAPE SEQUENCES



* Cursor movement



<ESC> A 	move cursor up

<ESC> B 	move cursor down

<ESC> C 	move cursor right

<ESC> D 	move cursor left

<ESC> H 	move cursor home

<ESC> Y <Y-coordinate+20H> <X-coordinate+20H> move cursor to (X, Y)

* Edit, delete



<ESC> j 	clear screen

<ESC> E 	clear screen

<ESC> K 	delete to end of line

<ESC> J 	delete to end of screen <ESC> L 	insert one line

<ESC> M 	delete one line



* Miscellaneous



<ESC> x4	set block cursor

<ESC> x5	hide cursor

<ESC> y4	set underline cursor

<ESC> y5	display cursor



============================================================================



APPENDIX 7 - CARTRIDGE HARDWARE



and



APPENDIX 9 - CHARACTER SET



are not available here





<code>+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 0A | 0B | 0C | 0D | 0E | 0F |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 00 | NOP | LD | LD | INC | INC | DEC | LD | RLCA | EX | ADD | LD | DEC | INC | DEC | LD | RRCA |

| | |bc,nn |(bc),a| bc | b | b | b,n | |af,af'| hl,bc|a,(bc)| bc | c | c | c,n | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 10 | DJNZ | LD | LD | INC | INC | DEC | LD | RLA | JR | ADD | LD | DEC | INC | DEC | LD | RRA |

| | dis | de,nn|(de),a| de | d | d | d,n | | dis | hl,de|a,(de)| de | e | e | e,n | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 20 | JR | LD | LD | INC | INC | DEC | LD | DAA | JR | ADD | LD | DEC | INC | DEC | LD | CPL |

| |nz,dis| hl,nn|(nn)hl| hl | h | h | h,n | | z,dis| hl,hl|hl(nn)| hl | l | l | l,n | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 30 | JR | LD | LD | INC | INC | DEC | LD | SCF | JR | ADD | LD | DEC | INC | DEC | LD | CCF |

| |nc,dis| sp,nn|(nn),a| sp | (hl) | (hl) |(hl),n| | c,dis| hl,sp|a,(nn)| sp | a | a | a,n | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 40 | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD |

| | b,b | b,c | b,d | b,e | b,h | b,l |b,(hl)| b,a | c,b | c,c | c,d | c,e | c,h | c,l |c,(hl)| c,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 50 | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD |

| | d,b | d,c | d,d | d,e | d,h | d,l |d,(hl)| d,a | e,b | e,c | e,d | e,e | e,h | e,l |e,(hl)| e,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 60 | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD | LD |

| | h,b | h,c | h,d | h,e | h,h | h,l |h,(hl)| h,a | l,b | l,c | l,d | l,e | l,h | l,l |l,(hl)| l,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 70 | LD | LD | LD | LD | LD | LD | HALT | LD | LD | LD | LD | LD | LD | LD | LD | LD |

| |(hl),b|(hl),c|(hl),d|(hl),e|(hl),h|(hl),l| |(hl),a| a,b | a,c | a,d | a,e | a,h | a,l |a,(hl)| a,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 80 | ADD | ADD | ADD | ADD | ADD | ADD | ADD | ADD | ADC | ADC | ADC | ADC | ADC | ADC | ADC | ADC |

| | a,b | a,c | a,d | a,e | a,h | a,l |a,(hl)| a,a | a,b | a,c | a,d | a,e | a,h | a,l |a,(hl)| a,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 90 | SUB | SUB | SUB | SUB | SUB | SUB | SUB | SUB | SBC | SBC | SBC | SBC | SBC | SBC | SBC | SBC |

| | b | c | d | e | h | l | (hl) | a | a,b | a,c | a,d | a,e | a,h | a,l |a,(hl)| a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| A0 | AND | AND | AND | AND | AND | AND | AND | AND | XOR | XOR | XOR | XOR | XOR | XOR | XOR | XOR |

| | b | c | d | e | h | l | (hl) | a | b | c | d | e | h | l | (hl) | a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| B0 | OR | OR | OR | OR | OR | OR | OR | OR | CP | CP | CP | CP | CP | CP | CP | CP |

| | b | c | d | e | h | l | (hl) | a | b | c | d | e | h | l | (hl) | a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| C0 | RET | POP | JP | JP | CALL | PUSH | ADD | RST | RET | RET | JP | **** | CALL | CALL | ADC | RST |

| | nz | bc | nz,nn| nn | nz,nn| bc | a,n | 0h | z | | z,nn | | z,nn | nn | a,n | 8h |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| D0 | RET | POP | JP | OUT | CALL | PUSH | SUB | RST | RET | EXX | JP | IN | CALL | **** | SBC | RST |

| | nc | de | nc,nn| (n),a| nc,nn| de | n | 10h | c | | c,nn | a,(n)| c,nn | | a,n | 18h |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| E0 | RET | POP | JP | EX | CALL | PUSH | AND | RST | RET | JP | JP | EX | CALL | **** | XOR | RST |

| | po | hl | po,nn|(sp)hl| po,nn| hl | n | 20h | pe | (hl) | pe,nn| de,hl| pe,nn| | n | 28h |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| F0 | RET | POP | JP | DI | CALL | PUSH | OR | RST | RET | LD | JP | EI | CALL | **** | CP | RST |

| | p | af | p,nn | | p,nn | af | n | 30h | m |sp,hl | m,nn | | m,nn | | n | 38h |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+



+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| CB | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 0A | 0B | 0C | 0D | 0E | 0F |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 00 | RLC | RLC | RLC | RLC | RLC | RLC | RLC | RLC | RRC | RRC | RRC | RRC | RRC | RRC | RRC | RRC |

| | b | c | d | e | h | l | (hl) | a | b | c | d | e | h | l | (hl) | a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 10 | RL | RL | RL | RL | RL | RL | RL | RL | RR | RR | RR | RR | RR | RR | RR | RR |

| | b | c | d | e | h | l | (hl) | a | b | c | d | e | h | l | (hl) | a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 20 | SLA | SLA | SLA | SLA | SLA | SLA | SLA | SLA | SRA | SRA | SRA | SRA | SRA | SRA | SRA | SRA |

| | b | c | d | e | h | l | (hl) | a | b | c | d | e | h | l | (hl) | a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 30 | | | | | | | | | SRL | SRL | SRL | SRL | SRL | SRL | SRL | SRL |

| | | | | | | | | | b | c | d | e | h | l | (hl) | a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 40 | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT |

| | 0,b | 0,c | 0,d | 0,e | 0,h | 0,l |0,(hl)| 0,a | 1,b | 1,c | 1,d | 1,e | 1,h | 1,l |1,(hl)| 1,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 50 | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT |

| | 2,b | 2,c | 2,d | 2,e | 2,h | 2,l |2,(hl)| 2,a | 3,b | 3,c | 3,d | 3,e | 3,h | 3,l |3,(hl)| 3,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 60 | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT |

| | 4,b | 4,c | 4,d | 4,e | 4,h | 4,l |4,(hl)| 4,a | 5,b | 5,c | 5,d | 5,e | 5,h | 5,l |5,(hl)| 5,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 70 | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT | BIT |

| | 6,b | 6,c | 6,d | 6,e | 6,h | 6,l |6,(hl)| 6,a | 7,b | 7,c | 7,d | 7,e | 7,h | 7,l |7,(hl)| 7,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 80 | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES |

| | 0,b | 0,c | 0,d | 0,e | 0,h | 0,l |0,(hl)| 0,a | 1,b | 1,c | 1,d | 1,e | 1,h | 1,l |1,(hl)| 1,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 90 | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES |

| | 2,b | 2,c | 2,d | 2,e | 2,h | 2,l |2,(hl)| 2,a | 3,b | 3,c | 3,d | 3,e | 3,h | 3,l |3,(hl)| 3,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| A0 | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES |

| | 4,b | 4,c | 4,d | 4,e | 4,h | 4,l |4,(hl)| 4,a | 5,b | 5,c | 5,d | 5,e | 5,h | 5,l |5,(hl)| 5,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| B0 | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES | RES |

| | 6,b | 6,c | 6,d | 6,e | 6,h | 6,l |6,(hl)| 6,a | 7,b | 7,c | 7,d | 7,e | 7,h | 7,l |7,(hl)| 7,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| C0 | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET |

| | 0,b | 0,c | 0,d | 0,e | 0,h | 0,l |0,(hl)| 0,a | 1,b | 1,c | 1,d | 1,e | 1,h | 1,l |1,(hl)| 1,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| D0 | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET |

| | 2,b | 2,c | 2,d | 2,e | 2,h | 2,l |2,(hl)| 2,a | 3,b | 3,c | 3,d | 3,e | 3,h | 3,l |3,(hl)| 3,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| E0 | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET |

| | 4,b | 4,c | 4,d | 4,e | 4,h | 4,l |4,(hl)| 4,a | 5,b | 5,c | 5,d | 5,e | 5,h | 5,l |5,(hl)| 5,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| F0 | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET | SET |

| | 6,b | 6,c | 6,d | 6,e | 6,h | 6,l |6,(hl)| 6,a | 7,b | 7,c | 7,d | 7,e | 7,h | 7,l |7,(hl)| 7,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+



+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| ED | 00 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 0A | 0B | 0C | 0D | 0E | 0F |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 00 | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 10 | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 20 | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 30 | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 40 | IN | OUT | SBC | LD | NEG | RETN | IM | LD | IN | OUT | ADC | LD | | RETI | | LD |

| | b,(c)| (c),b| hl,bc|(nn)bc| | | 0 | i,a | c,(c)|(c),c | hl,bc|bc(nn)| | | | r,a |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 50 | IN | OUT | SBC | LD | | | IM | LD | IN | OUT | ADC | LD | | | IM | LD |

| | d,(c)| (c),d| hl,de|(nn)de| | | 1 | a,i | e,(c)|(c),e | hl,de|de(nn)| | | 2 | a,r |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 60 | IN | OUT | SBC | LD | | | | RRD | IN | OUT | ADC | LD | | | | RLD |

| | h,(c)| (c),h| hl,hl|(nn)hl| | | | | l,(c)|(c),l | hl,hl|hl(nn)| | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 70 | | | SBC | LD | | | | | IN | OUT | ADC | LD | | | | |

| | | | hl,sp|(nn)sp| | | | | a,(c)|(c),a | hl,sp|sp(nn)| | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 80 | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| 90 | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| A0 | LDI | CPI | INI | OUTI | | | | | LDD | CPD | IND | OUTD | | | | |

| | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| B0 | LDIR | CPIR | INIR | OTIR | | | | | LDDR | CPDR | INDR | OUTR | | | | |

| | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| C0 | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| D0 | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| E0 | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+

| F0 | | | | | | | | | | | | | | | | |

+----+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+------+



DD -- HL is replaced by IX

FD -- HL is replaced by IY c1</code>





<code><a name="z80_instructionset"></a><b>Z80 Instruction set summary</b>

Table A-3. Z80 Mnemonics and Operations in Alphabetical Order +------------+--------------------+------+---+---+----------------------+

|Mnemonic |Operation |CZPSNH|Len|Tim|Comments |

+------------+--------------------+------+---+---+----------------------+

|ADC A,r |A:=A+r+CY |**V*0*| 1 | 4 | r - A,B,C,D,E,H,L |

|ADC A,(HL) |A:=A+(HL)+CY | | 1 | 7 | |

|ADC A,n |A:=A+n+CY | | 2 | 7 | n - byte (0..FF) |

|ADC A,(ii+n)|A:=A+(ii+n)+CY | | 3 |19 |ii - IX,IY |

|ADC HL,rr |HL:=HL+rr+CY |**V*0x| 2 |15 |rr - BC,DE,HL,SP |

+------------+--------------------+------+---+---+----------------------+

|ADD A,r |A:=A+r |**V*0*| 1 | 4 | |

|ADD A,(HL) |A:=A+(HL) | | 1 | 7 | |

|ADD A,n |A:=A+n | | 2 | 7 | |

|ADD A,(ii+n)|A:=A+(ii+n) | | 3 |19 | |

|ADD HL,rr |HL:=HL+rr |*...0x| 1 |11 | |

|ADD IX,ry |IX:=IX+px | | 2 |15 |ry - BC,DE,SP,IY |

|ADD IY,rx |IY:=IY+py | | 2 |15 |rx - BC,DE,SP,IX |

+------------+--------------------+------+---+---+----------------------+

|AND r |A:=A and r |0*P*01| 1 | 4 | |

|AND (HL) |A:=A and (HL) | | 1 | 7 | |

|AND n |A:=A and n | | 2 | 7 | |

|AND (ii+n) |A:=A and (ii+n) | | 3 |19 | |

+------------+--------------------+------+---+---+----------------------+

|BIT b,r |Z:=not rb |.*xx01| 2 | 8 | b - bit number (0..7)|

|BIT b,(HL) |Z:=not (HL)b | | 2 |12 |xb - bit b of |

|BIT b,(ii+n)|Z:=not (ii+n)b | | 4 |20 | location x |

+------------+--------------------+------+---+---+----------------------+

|CALL nn |PUSH PC;PC:=nn |......| 3 |17 |nn - word (0..FFFF) |

|CALL cc,nn |If cc then CALL nn | | 3 |17 |cc - C,NC,Z,NZ,M,P,PE,|

| | else continue | | |10 | PO |

+------------+--------------------+------+---+---+----------------------+

|CCF |CY:=not CY |*...0x| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|CP r |A-r |**V*1*| 1 | 4 | |

|CP (HL) |A-(HL) | | 1 | 7 | |

|CP n |A-n | | 2 | 7 | |

|CP (ii+n) |A-(ii+n) | | 3 |19 | |

+------------+--------------------+------+---+---+----------------------+

|CPD |A-(HL);dec HL;dec BC|.***1*| 2 |16 |PV=0 if BC=0,else PV=1|

+------------+--------------------+------+---+---+----------------------+

|CPDR |Repeat CPD |.***1*| 2 |21 | |

| | until Z=1 or BC=0 | | |16 | |

+------------+--------------------+------+---+---+----------------------+

|CPI |A-(HL);inc HL;dec BC|.***1*| 2 |16 |PV=0 if BC=0,else PV=1|

+------------+--------------------+------+---+---+----------------------+

|CPIR |Repeat CPI |.***1*| 2 |21 | |

| | until Z=1 or BC=0 | | |16 | |

+------------+--------------------+------+---+---+----------------------+

|CPL |A:=A xor 255 |....11| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|DAA |Decimal adjust Acc. |**P*.*| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|DEC r |r:=r-1 |.*V*1*| 1 | 4 | |

|DEC (HL) |(HL):=(HL)-1 | | 1 |11 | |

|DEC (ii+n) |(ii+n):=(ii+n)-1 | | 3 |23 | |

|DEC rr |rr:=rr-1 |......| 1 | 6 | |

|DEC ii |ii:=ii-1 | | 2 |10 | |

+------------+--------------------+------+---+---+----------------------+

|DI |IFF:=0 |......| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|DJNZ e |dec B;if B 0 JR e |......| 2 |13 | e - relative address |

| | if B=0 continue| | | 8 | |

+------------+--------------------+------+---+---+----------------------+

|EI |IFF:=1 |......| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|EX AF,AF' |AF<->AF' |......| 1 | 4 | |

|EX DE,HL |DE<->HL | | 1 | 4 | |

|EX (SP),HL |(SP)<->HL | | 1 | 4 | |

|EX (SP),ii |(SP)<->ii | | 2 |23 | |

+------------+--------------------+------+---+---+----------------------+

|EXX |BC<->BC';DE<->DE'; |......| 1 | 4 | |

| |HL<->HL' | | | | |

+------------+--------------------+------+---+---+----------------------+

|HALT |Halt CPU |......| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|IM 1 |Interrupt mode 1 |......| 2 | 8 | |

|IM 2 |Interrupt mode 2 | | | | |

|IM 3 |Interrupt mode 3 | | | | |

+------------+--------------------+------+---+---+----------------------+

|IN A,(n) |A:=port(n) |......| 2 |11 | |

|IN r,(C) |r:=port(C) |.*P*0*| 2 |12 | |

|IN ?,(C) |only set flags as |.*P*0*| 2 |12 |can't be entered as a |

| | as IN r,(C) does | | | |command;code is ED 70 |

+------------+--------------------+------+---+---+----------------------+

|INC r |r:=r+1 |.*V*0*| 1 | 4 | |

|INC (HL) |(HL):=(HL)+1 | | 1 |11 | |

|INC (ii+n) |(ii+n):=(ii+n)+1 | | 3 |23 | |

|INC rr |rr:=rr+1 |......| 1 | 6 | |

|INC ii |ii:=ii+1 | | 2 |10 | |

+------------+--------------------+------+---+---+----------------------+

|IND |(HL):=port(C); |x*xx1x| 2 |16 |Z=1 if B=0,else Z=0 |

| |dec HL;dec B | | | | |

+------------+--------------------+------+---+---+----------------------+

|INDR |Repeat IND |x1xx1x| 2 |21 | |

| | until B=0 | | |16 | |

+------------+--------------------+------+---+---+----------------------+

|INI |(HL):=port(C); |x*xx1x| 2 |16 |Z=1 if B=0,else Z=0 |

| |inc HL;dec B | | | | |

+------------+--------------------+------+---+---+----------------------+

|INIR |Repeat INI |x1xx1x| 2 |21 | |

| | until B=0 | | |16 | |

+------------+--------------------+------+---+---+----------------------+

|JP nn |PC:=nn |......| 3 |10 | |

|JP cc,nn |If cc then JP nn |......| 3 |10 | |

|JP (HL) |PC:=HL | | 1 | 4 | |

|JP (ii) |PC:=ii | | 2 | 8 | |

+------------+--------------------+------+---+---+----------------------+

|JR e |PC:=PC+e |......| 2 |12 | |

|JR cond,e |If cond then JR e | | 2 |12 |cond - C,NC,Z,NZ |

| | else NOP | | | 7 | |

+------------+--------------------+------+---+---+----------------------+

|LD r,r |r:=r |......| 1 | 4 | |

|LD r,(HL) |r:=(HL) | | 1 | 7 | |

|LD r,n |r:=n | | 2 | 7 | |

|LD r,(ii+n) |r:=(ii+n) | | 3 |19 | |

|LD (HL),r |(HL):=r | | 1 | 7 | |

|LD (ii+n),r |(ii+n):=r | | 3 |19 | |

|LD (HL),n |(HL):=n | | 2 |10 | |

|LD (ii+n),n |(ii+n):=n | | 4 |19 | |

|LD A,(BC) |A:=(BC) | | 1 | 7 | |

|LD A,(DE) |A:=(DE) | | 1 | 7 | |

|LD A,(nn) |A:=(nn) | | 3 |13 | |

|LD (BC),A |(BC):=A | | 1 | 7 | |

|LD (DE),A |(DE):=A | | 1 | 7 | |

|LD (nn),A |(nn):=A | | 3 |13 | |

|LD A,I |A:=I |.***00| 2 | 9 |PV=IFF |

|LD A,R |A:=R | | 2 | 9 |PV=IFF |

|LD I,A |I:=A |......| 2 | 9 | |

|LD R,A |R:=A | | 2 | 9 | |

|LD rr,nn |rr:=nn | | 3 |10 | |

|LD ii,nn |ii:=nn | | 4 |14 | |

|LD HL,(nn) |HL:=(nn) | | 3 |16 | |

|LD rr,(nn) |rr:=(nn) | | 4 |20 | |

|LD ii,(nn) |ii:=(nn) | | 4 |20 | |

|LD (nn),HL |(nn):=HL | | 3 |16 | |

|LD (nn),rr |(nn):=rr | | 4 |20 | |

|LD (nn),ii |(nn):=ii | | 4 |20 | |

|LD SP,HL |SP:=HL | | 1 | 6 | |

|LD SP,ii |SP:=ii | | 1 |10 | |

+------------+--------------------+------+---+---+----------------------+

|LDD |(DE):=(HL); |..*.00| 2 |16 |PV=0 if BC=0,else PV=1|

| |dec DE,HL,BC | | | | |

+------------+--------------------+------+---+---+----------------------+

|LDDR |Repeat LDD |..0.00| 2 |21 | |

| | until Z=1 or BC=0 | | |16 | |

+------------+--------------------+------+---+---+----------------------+

|LDI |(DE):=(HL); |..*.00| 2 |16 |PV=0 if BC=0,else PV=1|

| |inc DE,HL;dec BC | | | | |

+------------+--------------------+------+---+---+----------------------+

|LDIR |Repeat LDI |..0.00| 2 |21 | |

| | until Z=1 or BC=0 | | |16 | |

+------------+--------------------+------+---+---+----------------------+

|NEG |A:=0-A |**V*1*| 2 | 8 | |

+------------+--------------------+------+---+---+----------------------+

|NOP |No operation |......| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|OR r |A:=A or r |0*P*00| 1 | 4 | |

|OR (HL) |A:=A or (HL) | | 1 | 7 | |

|OR n |A:=A or n | | 2 | 7 | |

|OR (ii+n) |A:=A or (ii+n) | | 3 |19 | |

+------------+--------------------+------+---+---+----------------------+

|OTDR |Repeat OUTD |x1xx1x| 2 |21 | |

| | until B=0 | | |16 | |

+------------+--------------------+------+---+---+----------------------+

|OTIR |Repeat OUTI |x1xx1x| 2 |21 | |

| | until B=0 | | |16 | |

+------------+--------------------+------+---+---+----------------------+

|OUT (n),A |port(n):=A |......| 2 |11 | |

|OUT (C),r |port(C):=r | | 2 |12 | |

+------------+--------------------+------+---+---+----------------------+

|OUTD |port(C):=(HL); |x*xx1x| 2 |16 |Z=1 if B=0,else Z=0 |

| |dec HL;dec B | | | | |

+------------+--------------------+------+---+---+----------------------+

|OUTI |port(C):=(HL); |x*xx1x| 2 |16 |Z=1 if B=0,else Z=0 |

| |inc HL;dec B | | | | |

+------------+--------------------+------+---+---+----------------------+

|POP qq |qq:=(SP);SP:=SP+2 |......| 1 |10 |qq - AF,BC,DE,HL |

|POP ii |ii:=(SP);SP:=SP+2 | | 2 |14 | |

+------------+--------------------+------+---+---+----------------------+

|PUSH qq |SP:=SP-2;(SP):=qq |......| 1 |11 | |

|PUSH ii |SP:=SP-2;(SP):=ii | | 2 |15 | |

+------------+--------------------+------+---+---+----------------------+

|RES b,r |rb:=0 |......| 2 | 8 | |

|RES b,(HL) |(HL)b:=0 | | 2 |15 | |

|RES b,(ii+n)|(ii+n)b:=0 | | 4 |23 | |

+------------+--------------------+------+---+---+----------------------+

|RET |POP PC |......| 1 |10 | |

|RET cc |If cc then RET |......| 1 |11 | |

| | else NOP | | | 5 | |

+------------+--------------------+------+---+---+----------------------+

|RETI |Return from interr. |......| 2 |14 | |

+------------+--------------------+------+---+---+----------------------+

|RETN |Return from NMI |......| 2 |14 | |

+------------+--------------------+------+---+---+----------------------+

|RL r |+------->------+ |**P*00| 2 | 8 | |

|RL (HL) ||+--+ +-------+| | | 2 |15 | |

|RL (ii+n) |++CY+<+7 <-- 0++ | | 4 |23 | |

+------------+ +--+ +-------+ +------+---+---+----------------------+

|RLA | |*...00| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|RLC r | +---->----+ |**P*00| 2 | 8 | |

|RLC (HL) |+--+ |+-------+| | | 2 |15 | |

|RLC (ii+n) ||CY+<++7 <-- 0++ | | 4 |23 | |

+------------++--+ +-------+ +------+---+---+----------------------+

|RLCA | |*...00| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|RLD | A +---->---+(HL)|.*P*00| 2 |18 | |

| |+---+-+-++---+-+-+ | | | | |

| ||7 4|3 0||7 4|3 0| | | | | |

| |+---+-+-++++-+-+-+ | | | | |

| | +-<-++-<-+ | | | | |

+------------+--------------------+------+---+---+----------------------+

|RR r |+------<-------+ |**P*00| 2 | 8 | |

|RR (HL) ||+-------+ +--+| | | 2 |15 | |

|RR (ii+n) |++7 --> 0+>+CY++ | | 4 |23 | |

+------------+ +-------+ +--+ +------+---+---+----------------------+

|RRA | |*...00| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|RRC r |+---<-----+ |**P*00| 2 | 8 | |

|RRC (HL) ||+-------+| +--+ | | 2 |15 | |

|RRC (ii+n) |++7 --> 0++>+CY| | | 4 |23 | |

+------------+ +-------+ +--+ +------+---+---+----------------------+

|RRCA | |*...00| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|RRD | A +---<----+(HL)|.*P*00| 2 |18 | |

| |+---+-+-++---+-+-+ | | | | |

| ||7 4|3 0||7 4|3 0| | | | | |

| |+---+-+-++++-+-+-+ | | | | |

| | +->-++->-+ | | | | |

+------------+--------------------+------+---+---+----------------------+

|RST adr |CALL adr |......| 1 |11 |adr - byte (000xxx00b)|

+------------+--------------------+------+---+---+----------------------+

|SBC A,r |A:=A-r-CY |**V*1*| 1 | 4 | |

|SBC A,(HL) |A:=A-(HL)-CY | | 1 | 7 | |

|SBC A,n |A:=A-n-CY | | 2 | 7 | |

|SBC A,(ii+n)|A:=A-(ii+n)-CY | | 3 |19 | |

|SBC HL,rr |HL:=HL-rr-CY |**V*1x| 2 |15 | |

+------------+--------------------+------+---+---+----------------------+

|SCF |CY:=1 |1...00| 1 | 4 | |

+------------+--------------------+------+---+---+----------------------+

|SET b,r |rb:=1 |......| 2 | 8 | |

|SET b,(HL) |(HL)b:=1 | | 2 |15 | |

|SET b,(ii+n)|(ii+n)b:=1 | | 4 |23 | |

+------------+--------------------+------+---+---+----------------------+

|SLA r |+--+ +-------+ |**P*00| 2 | 8 | |

|SLA (HL) ||CY+<+7 <-- 0+<0 | | 2 |15 | |

|SLA (ii+n) |+--+ +-------+ | | 4 |23 | |

+------------+--------------------+------+---+---+----------------------+

|SRA r | +-------+ +--+ |**P*00| 2 | 8 | |

|SRA (HL) |+>+7 --> 0+>+CY| | | 2 |15 | |

|SRA (ii+n) |+-+-------+ +--+ | | 4 |23 | |

+------------+--------------------+------+---+---+----------------------+

|SRL r | +-------+ +--+ |**P*00| 2 | 8 | |

|SRL (HL) | 0>+7 --> 0+>+CY| | | 2 |15 | |

|SRL (ii+n) | +-------+ +--+ | | 4 |23 | |

+------------+--------------------+------+---+---+----------------------+

|SUB r |A:=A-r |**V*0*| 1 | 4 | |

|SUB (HL) |A:=A-(HL) | | 1 | 7 | |

|SUB n |A:=A-n | | 2 | 7 | |

|SUB (ii+n) |A:=A-(ii+n) | | 3 |19 | |

+------------+--------------------+------+---+---+----------------------+

|XOR r |A:=A xor r |0*P*00| 1 | 4 | |

|XOR (HL) |A:=A xor (HL) | | 1 | 7 | |

|XOR n |A:=A xor n | | 2 | 7 | |

|XOR (ii+n) |A:=A xor (ii+n) | | 3 |19 | |

+------------+--------------------+------+---+---+----------------------+



</code>





R800 (MSX specific)


FEATURES OF THE R800

The R800, develloped for the Turbo R, has the features shown below.

1.80 and object-compatible

With the software written for the Z80 note that the parts dependent on the tming of the CPU are removed and not-changed can be used.

2.The CPU clock frequency is 7.15909 Mhz

Because compared with the number of clockpulses per instruction in the Z80 sharply lower , the z80 conversion is in fact at the speed on 28.63636Mhz (If there are no waitstates).

3.multiplication commands

the multiply command that is supported has an accuracy of

8bit x 8bit -> 16 bit and also 16bit x 16bit -> 32 bit

Depending on this, big mathematical procedure with higher speed is possible.

4.LSB/MSB defenition instructions

With the Z80 , the access of the higher and the lower 8 bit of register IX/IY with the LSB/MSB defenition is properly secured.

In figure 1.2 the handling speeds of the most important instructions is shown. (When the Turbo R has no waitstates. Please take notice of the fact that on the MSX 2+ 1 waitstate occurs on the M1 cycle.)

WAIT

In the MSX Turbo R normally no waitstates are generated. In the conditions

below a waitstate is generated.

1.If an external slot is accessed (3 waitstates)

When an external slot is accessed, to support the externale hardware up to now developed, the Turbo R is designed in the same way the MSX2+, it has the same access time while accessing.

2.If an internal rom is accessed (2 waitstates)

Internal ROMS are ROMS like BIOS, BASIC and as well as the internal DISKROM etc. But in the first stage in the Turbo R because BIOS, BASIC, SUB ROM and the 16KB of the first part of the KANJI driver (64KB in total) are being copied to the main RAM, it will become the same as described at point 3.

picture 1.2 execution-comparison of the MSX Turbo R and MSX2+ ----------------------------------------------------------------------------- INSTRUCTION MSX2+(in u.sec) MSX Turbo R(in u.sec) FACTOR ----------------------------------------------------------------------------- LD r,s 1.40 0.14 x 10.0 LD r,(HL) 2.23 0.42 x 5.3 LD r,(IX+n) 5.87 0.70 x 8.4 PUSH qq 3.35 0.56 x 6.0 LDIR (BC<>0) 6.43 0.98 x 6.6 ADD A,r 1.40 0.14 x 10.0 INC r 1.40 0.14 x 10.0 ADD HL,ss 3.35 0.14 x 24.0 INC ss 1.96 0.14 x 14.0 JP 3.07 0.42 x 7.3 JR 3.63 0.42 x 8.7 DJNZ (B<>0) 3.91 0.42 x 9.3 CALL 5.03 0.84 x 6.0 RET 3.07 0.56 x 5.5 MULTU A,r 160 1.96 x 82 MULTUW HL,rr 361 5.03 x 71 -----------------------------------------------------------------------------

3.When the internal DRAM is being addressed (1 waitstate)

The page access-mode is supported what means that the R800 uses its own bus to the DRAM. Therefore it is possible to get the best performance of the DRAM. In differences with the memory access the lower 8bit of the adress is just changed, in the page-address-mode highspeed access is possible. Except the lower 8 bit that are changed, the rest presents the pagebreak that is produced. Because when using the page-break accessing twice is done in one step approximately 0.5 waitstate is generated. With the pagebreak also a DRAM refresh is generated. With the R800, different from the Z80, the DRAM refesh is not unsynchonized to the commands. In the MSX Turdo R the refresh is done every time 31 u.sec For refreshing once takes 280 n.sec. Furthermore with jump instructions (relative jumps and absolute jumps) a pagebreak is absolutly generated.

According to this it is better with highspeed access to pay attention to the things below with important programs.

1.Transmission of programs in RAM

With a program in a ROM cartridge, highspeed can be used if a important part is moved by highspeed into ram. A program provided from diskette will inevitable put into RAM for using it so that will be no problem.

2.Coding where no pagebreak takes place.

In the case of using RAM, within a necessary highspeed loop try to uses as much CPU registers as possible, when coded with a few times accessing the data memory (this also contains stack) the advantage of the pageacces mode. will be most effective. Furthermore, a loop is most effective when it is programmed between xx00H and xxFFH.

3.Using the system-timer

In the Turbo R because of the above mentioned pagebreak and refreshcycle, it is not necessary to mind facts like eg in the MSX 2+ understanding exactly the timing of the instructions. In accordance with that, even on the MSX Turbo R to make programs like making on the MSX 2+, timing with software loops are not recommended. In the MSX Turbo R, because the systemclock is increased every 3.91 u.sec, it is recommended to use that for timing.





0

<b>MSXtra Monitor / debugger voor MSX



MSXtra Version - 2.0 Dec. 1986.Copyright (C) A.A.M. Staring</b>

Een uitgave van de PTC Technische Bibliotheek, augustus 1987



Inhoud opgave:



1. Inleiding blz. 1



2. Eerste kennismaking blz. 2



3. TRACE en DUMP blz. 5



4. Disassembleren blz. 5



5. FIND en KILL blz. 7



6. Assembleren blz. 8



7. GO, QUIT en de Video-modes blz.10



8. Breakpoints, Execute blz.12



9. Subroutine blz.15



10. De praktijk blz.16



11. Een grafische exercitie blz.18



12. Eigen utillities blz.19



13. MSXtra enBASIC blz.21



14. MSXtra en andere cartridges blz.22



15. Overzicht van opdrachten blz.24



16. Literatuur blz.31



17. Schema van de cartridge blz.32



-------------------------------------- 0 -------------------------------------





1. Inleiding




MSXtra is een universeel en compact software gereedschap voor gebruik op MSX1 en MSX2. Het bevat zowel een assembler als een disassembler die de gehele Z80 instructieset afdekken en bovendien alle gereedschappen voor het debuggen van in machinetaal geschreven programma's en de in BASIC-programma's opgenome userroutines.



Door zijn gebruiksvriendelijke "user interface" - zoals het toepassen van "split-screen" - is MSXtra ook uitstekend te gebruiken voor het onmiddellijk ontwik-kelen en testen van niet al te grote routines. Ook als hulpmiddel bij het bestuderen en oefenen van de Z80 assembleertaal zal MSXtra zijn diensten bewijzen.



Om MSXtra direct bruikbaar te doen zijn voor praktische oefeningen, treft U

in de voorbeelden zowel een invoer- als een uitvoerroutine aan.



Het verdient aanbeveling om bij het doornemen van deze gebruiksaanwijzing regelmatig het onder 15 opgenomen OVERZICHT van OPDRACHTEN te raad-plegen.



Alle in de volgende voorbeelden aangegeven getallen zijn, voor zover niet uitdrukkelijk anders is aangegeven, te lezen als hexadecimaal.



Deze handleiding is zorgvuldig gecontroleerd op fouten en onduidelijkheden.

Mocht U desondanks toch onregelmatigheden ontdekken dan wil de schrijver dit graag van U weten.



A.A.M. Staring

-------------------------------------- 1 -------------------------------------





2. Eerste kennismaking




Alvorens de MSX-insteekmodule in een slot van Uw machine te plaatsen schakelt U, zoals U dat natuurlijk gewend bent, eerst de machine uit. Na correct inschakelen meld de machine zich zoals U dat gewend bent. U kunt MSXtra nu oproepen door intoetsen van 'CALL MSXTRA' of korter '_MSXTRA'

gevolgd door het indrukken van de RETURN toets.



N.B. In het vervolg wordt het indrukken van de RETURN toets aangegeven door het symbool <CR>



Het scherm van de MSX vertoont nu het volgende beeld:

Main: A=00 Flags= PC=0000

BC=0000 DE=0000 HL=0000 DI IX=0000 IY=0000 SP=0000 JP 02D7

CP A

Alt: A=00 Flags= DEC DE

BC=0000 DE=0000 HL=0000 SBC A,B



Command: #



MSXtra - Version 2.0 Aug 1986



Copyright (C) A.A.M. Staring

Voor het display is gekozen voor een donkere letter op een lichte achtergrond.

Dit is op den duur, ook bij gebruik van zwart-wit monitor, het minst vermoeiend voor de ogen.



In de linkerbovenhoek herkennen we de register-namen van de Z80 zoals algemeen gebruikelijk

Van beide registerbanken (Main en Alt) zijn alle registers op de waarde 0

gezet. Ook in de beide Flag-registers zijn geen bits gezet. Rechtsboven zien we de programmateller PC met de waarde nul. Daaronder de vijf gedisassem-bleerde instructies (uit de MSX-ROM) op de eerste geheugenplaatsen vanaf het door de PC aangegeven adres 0000.



De cursor achter het woordje "Command" nodigt uit tot een opdracht. MSXtra kent twee "modes": de Commando-mode en de executie-mode. Het zojuist gestarte MSXtra staat - zoals aangegeven - in de commando-mode. We kunnen MSXtra in de executie-mode brengen door intoetsen van

X<CR>



We zien nu het display uitgebreid met nogmaals de registers van de 'Main'-

bank. Bovendien de door deze registers geadresseerde en de zeven daarop-volgende geheugenplaatsen Dit alles in een hexadecimale representatie van het door de MSX intern gehanteerde binaire formaat.

In de laatste kolom vinden we tenslotte de z.g. 'printable ASCII-equivalents'

van deze geheugen plaatsen. Indien er geen overeenkomend "printbaar" ASCII teken is, staat hier een punt.



-------------------------------------- 2 -------------------------------------



Main: A=00 Flags= PC=0000

BC=0000 DE=0000 HL=0000 DI IX=0000 IY=0000 SP=0000 JP 02D7

CP A

Alt: A=00 Flags= DEC DE

BC=0000 DE=0000 HL=0000 SBC A,B



Execute: #



BC=0000 F3 C3 D7 02 BF 1B 98 98 ........



DE=0000 F3 C3 D7 02 BF 1B 98 98 ........



HL=0000 F3 C3 D7 02 BF 1B 98 98 ........



IX=0000 F3 C3 D7 02 BF 1B 98 98 ........



IY=0000 F3 C3 D7 02 BF 1B 98 98 ........



SP=0000 F3 C3 D7 02 BF 1B 98 98 ........



PC=0000 F3 C3 D7 02 BF 1B 98 98 ........



Alleen het Interrupt Vector register wordt niet getoond. De inhoud van dit register kan slechts onder speciale omstandigheden worden gewijzigd.



We keren voorlopig terug naar de commando-mode door alleen het indrukken van de toets:



C



We gaan van start met het veranderen van register inhouden, te beginnen met de PC



Toets in:



RPC=A000<CR>

De programma-teller PC wijst nu naar adres A000 van de vrije RAM en afhankelijk van de daar bevindende code vinden we deze in de rechter-bovenhoek gedisassembleerd.



We beginnen nu met het veranderen van de geheugenplaatsen op het door de PC aangegeven adres en doen dit door het intoetsen van het commando:

SA000<CR> (Set A000)

Het woord "Command" is nu overschreven met het gevraagde adres A000 met daar achter de inhoud. We toetsen nu de volgende cijfers in, gescheiden door een spatie en afgesloten met een punt:

1 2 3 4 5 6 7 8 9.<CR>

We zien nu op de onderste schermhelft nogmaals het adres A000 aangegeven dat we zojuist hebben aangepast. We gaan nu weer naar de executie-mode met:



X<CR>



-------------------------------------- 3 -------------------------------------



De volledige scherminhoud keert nu weer terug. Ook op de onderste regel (PC=A000) kunnen we zien dat de inhoud van de adressen A000 tot en met A007 overeenkomstig het ingevoerde is gewijzigd. Deze instructies kunnen nu worden uitgevoerd door een aantal malen indrukken van de spatiebalk:

<SPACE>

We zien dat na een eerste SPACE de instructie LD BC 0302 - d.i. registerpaar BC laden met de waarde 0302 - is uitgevoerd, dat BC een andere geheugenplaats aanwijst en de PC naar het volgende adres A003 met de instructie INC

B wijst. Ook deze en volgende instructies voeren we uit.



De instructie DEC B heeft, geheel conform de specificatie van deze instructie, in het Flag register het bit N gezet.



Uitvoering van de instructie EX AF,AF' geeft inderdaad een uitwisseling van de waarde van de Flag registers, terwijl de wisseling van de A-registers niet vast te stellen is doordat beide dezelfde waarde bevatten.



Aangekomen op adres A009 vinden we een instructie die we niet meer uitvoeren.



We kunnen nu het doorstappen van deze instructies nog eens overdoen, maar dan met de verschillende registers weer op hun oorspronkelijke waarde teruggezet. We keren daarvoor terug naar commando-mode:

C



En herstellen allereerst de programma-teller:

RPC=A000<CR>

We zetten alle andere registers terug met:

RBC=0<CR> RHL=0<CR> RF'=N<CR> X<CR>



Waarmee we weer in de oorspronkelijke situatie zijn teruggekeerd.

De registers kunnen ook ieder afzonderlijk op een bepaalde waarde worden gezet; b.v. RB=2, RC=3, enz.



Registers van de tweede bank worden aangegeven door toevoeging van een "quote", b.v. RH'=5, RL'=6.



Bij het maken van een typefout waardoor er een niet bestaand register wordt aangewezen, geeft MSXtra de foutmelding "Error". Deze foutmelding blijft tot aan een volgende invoer staan. Ook bij fouten in de andere commando's wordt deze foutmelding gegeven.



Nu we het dan toch over foutief invoeren hebben; we kunnen de commando-regel verbeteren met de horizontale cursor- insert- en delete-toetsen zoals we dat voor Basic invoer gewend waren.



Het veranderen van de afzonderlijke vlaggen in de "Flag-registers" kunt U

vergelijken met het bedienen van een schakelaar. Is bijvoorbeeld de Z-vlag gezet, dan wordt deze met RF=Z weggehaald; nogmaals RF=Z zet dan de Z=vlag weer.



-------------------------------------- 4 -------------------------------------





3. TRACE en DUMP




In de executie-mode zijn nog andere manieren om een aantal programma-stappen te doorlopen: de "trace".

We proberen na de voorgaande herstelling eens:

T 8<CR> ( Trace 8 )

Ook hier zien we dat acht opeenvolgende instructies worden uitgevoerd.

(N.B. Trace-mode genereert een automatische spatie achter T.)

We herstellen opnieuw in commando-mode de oorspronkelijke situatie en proberen dan:



T -A005<CR> ( Trace until A005 )

En zien dat alleen de instructies tot aan adres A005 worden uitgevoerd.



We zullen nu nog een aantal opdrachten bekijken en keren daarvoor terug naar de commando-mode:



C



DA000<CR> ( Dump A000)

Het resultaat is een z.g. "Dump" waarin we zojuist ingevoerde bytes herkennen. Een volgend blok dumpen we met:

+



Willen we nog even naar het voorgaande blok terug dan:

-



We beindigen deze dump met:



<CR>



Ook is het mogelijk een groter blok in een keer te dumpen met de opdracht:

DA000-A300<CR>





4. Disassembleren




We roepen de disassembler vanuit commando-mode aan met:

LA000<CR> ( List A000 )

Het resultaat is een terugvertaling van de vanaf adres A000 ingevoerde bytes. Ook hier kunnen we een volgend blok bekijken met:

+



En we eindigen het disassembleren met:

<CR>



-------------------------------------- 5 -------------------------------------



Indien de disassembler een opeenvolging van bytes tegenkomt die geen instructie kan vormen, dan wordt dit gemeld met een: "No code".



We hebben nu de mogelijkheid om in het "operating system" van de MSX te "bladeren" met:



D0<CR>



+



of terug met:



-



Ook rechtstreeks disassembleren met:

L0<CR>



En hier alleen vooruit met:



+



Het is echter wel zo dat de disassembler geen verschil kan maken tussen instructies en data, daarom zullen data als instructies worden vertaald.

Ook verstaat de disassembler het om een groter geheugenblok te disassembleren met:



LA000-A300<CR>

Uitvoer van een dump of disassembly naar een op de MSX aangesloten printer kan ook. Daarvoor schakelen we de uitvoer naar printer met het commando:

V+



En eindigen de uitvoer naar de printer met:

V-



Vooral bij disassembleren is deze voorziening goed bruikbaar. U kunt vooraf op het scherm nagaan welke delen van de te disassembleren software "code" en welke delen "data" bevatten. Door regelmatig "schakelen" tussen "L","D" en "V+/-" kunt U een nette lay-out op papier krijgen.



We keren nog even terug naar het veranderen van geheugen-plaatsen. Hierbij is het mogelijk zowel hexadecimale bytes als alpha-numerieke data gemengd in te geven, waarbij dan de laatste met enkele aanhalingstekens moeten zijn omgeven.



We proberen eens met:



<CR>



SA500<CR>

'ABC' 2F 3D '3' AA '789'.<CR>

En gaan dit na met:



DA500<CR>

-------------------------------------- 6 -------------------------------------



MSXtra start automatisch op in de stand "CAPS LOCK"; we kunnen natuurlijk ook klein letters invoeren door gebruikte maken van de toets "CAPS" verder aan te geven als <CL>.



SA500<CR>

<CL> 'abc' <CL> 'ABC'.<CR>

DA500<CR>

<CR>



We vergeten in geen geval om terug te keren naar "CAPS LOCK" omdat allen dan MSXtra opdrachten accepteert!



N.B. Een enkele "quote" in een string wordt aangegeven door hem te verdub-belen, als in '''s morgens'.





5. FIND en KILL




Een volgende optie is het zoeken naar een "string", ofwel het nagaan of een bepaalde opeenvolging van bytes of alpha-numerieke tekens een of meerdere malen in het geheugen voorkomt. We toetsen het volgende in en letten daarbij vooral op de kleine letters:



F'MSXtra'<CR> ( Find 'MSXtra' )

Het programma meld zich met:



Found at: 4098



We zoeken herhaald verder met:



+



Met uiteindelijk resultaat:



Found at: 409F

Found at: 6108

Found at: 6908

Found at: 7108

Found at: 7908

Found at: FC01 ( afhankelijk van het systeem )

Not found



We vergetende "CAPS LOCK" niet en verifiren nu e.e.a. met:

D409F<CR>

D6108<CR>

D6908<CR>

etc.



-------------------------------------- 7 -------------------------------------



Alleen in het laatste geval vinden we slechts de karakters "tra"; het begin is overschreven met "06.". Hier hebben we dus een instructie buffer ontdekt!



Zoeken naar hexa-bytes gaat uiteraard ook; We proberen eens:

F1 2 3 4 5 6 7 8 9<CR>

+



en:



F1 2 3 4 5 6 7 9 8<CR>

Met in beide gevallen een te verwachten resultaat. Een volgende optie bied de mogelijkheid een geheugen blok te vullen met een bepaalde opeenvolging van bytes:



K9000-9050,FF<CR> ( Kill 9000-9050 with FF )

Hierbij wordt de geheugenruimte, te beginnen vanaf adres 9000 tot aan adres 9050, gevuld met het byte FF. (Kill) We gaan dit na met:



D9000<CR>

We proberen ook:



K9000-9100,1 2 3 'ABC'<CR>

En controleren dit met:



D9000<CR>

Of ook:



K9100-9200,'DEF' 7 8 9<CR>





6. Assembleren




Met MSXtra beschikken we ook over een eenvoudige assembler, een assembler die, evenals de disassembler, de volledige Z80 instructieset afdekt, maar niet, zoals een echte assembler, in een tweede doorgang (pass) de adressen van labels berekent en invult. Deze - bij kleine programma's betrekkelijk eenvoudige - taak moeten we achteraf zelf uitvoeren, en daarvoor is in MSXtra het noodzakelijke gereedschap ingebouwd.



We starten de assembler vanuit de commando-mode met invoer vanaf adres A000 door middel van het commando:



AA000<CR> ( Assemble at 9000 )

MSXtra meld zich met adres A000 en daarachter de inhoud van dit adres. We toetsen in:



LD A,20<CR>

Op de onderste schermhelft bouwt zich een lijst op bestaande uit het adres, de hexa-code en de zojuist ingevoerde instructie. Voor de cursor meld MSXtra

-------------------------------------- 8 -------------------------------------



zich met het eerstvolgende vrije adres A002. Bij het onverhoopt maken van een fout tijdens het intikken zal dit na de afsluitende <CR> worden gemeld door een melding "Error", gevolgd door een terugspringen in commando-mode. We kunnen nu de assembler weer opnieuw starten vanaf dit laatste, en nog steeds vrije, adres.



we vervolgen het invoeren waarbij elke regel wordt afgesloten met een <CR>:

LD B,60

PUSH BC

PUSH AF

RST 18

LD HL, 0

DEC HL

LD A,L

OR H

JR NZ,0FB

POP AF

INC A

POP BC

DJNZ 0F0

.<CR>



Met de laatste .<CR>, een "lege" regel, beindigen we het assembleren. Bij het invoeren van instructies moeten de hexadecimaal getallen die beginnen met een "letter", worden voorafgegaan door een nul.

Zie de zojuist ingevoerde instructies JR NZ,0FA en DJNZ 0F0. Dat het voorvoegen van een nul noodzakelijk is kan duidelijk gemaakt worden aan de hand van het volgende voorbeeld. De instructies LD A,B en LD A,0B zijn duidelijk verschillend. De eerste laad het register A met de inhoud van het register B, de tweede laad het register A met het byte 0B.

Het programma kunnen we weer bekijken met:

LA000<CR>

Resultaat:



A000 3E 20 LD A,20

A002 06 60 LD B,60

A004 C5 PUSH BC

A005 F5 PUSH AF

A006 DF RST 18

A007 21 00 00 LD HL,0000

A00A 2B DEC HL

A00B 7D LD A,L

A00C B4 OR H

A00D 20 FB JR NZ,FB A00A A00F F1 POP AF

A010 3C INC A A011 C1 POP BC

A012 10 DJNZ F0 A004



We zien bij de adressen AOOD en A012 de sprongadressen naar A00A respectievelijk A004 aangegeven.



Wat doet dit korte programma? Het laad register A met 20, het ASCII equivalent voor een spatie. Vervolgens wordt register B geladen met 60, een teller voor het aantal af te drukken karakters.



De instructie RST 18 zorgt dat met behulp van routines uit de ROM Basic-interpreter het karakter wordt afgedrukt. Na een wachtlus, adres A006 t/m

-------------------------------------- 9 -------------------------------------



A012, wordt de inhoud van register A met 1 opgehoogd. Zolang de inhoud van register B nog niet 0 is wordt teruggesprongen en een volgend karakter afgedrukt.



Nog enige opmerkingen over het invoeren van bepaalde instructies. De RST

instructies moeten met twee cijfers worden ingegeven en correct v.w.b. de reeks 00, 08, 10, 18,....etc.

Dit heeft echter alleen consequenties voor RST (0)8 !

Niet correcte invoer wordt vertaald als RST 00.



In instructies waarbij gebruik gemaakt wordt van de index registers, moet een relatieve verplaatsing altijd worden aangegeven. Ook in geval 0; dus niet LD (IY),n maar LD (IY+0),n.



In indirecte sprongen die de index-registers gebruiken wordt de verplaatsing daarentegen niet aangegeven, dus b.v. JP(IX) en JP(IY).





7. GO, QUIT en de Video-modes




het zojuist ingevoerde programma kunnen we nu op verschillende manieren laten lopen. We beginnen op de meest eenvoudige manier. we zetten de PC op het start adres A000 en de Stack-Pointer op B000 en gaan daarna naar de executie-mode:

RPC=A000<CR>

RSP=B000<CR>

X<CR>



We kunnen nu het programma laten lopen met:

G -A014 ( Go until A014 )

Het programma wordt nu vanaf het door de PC aangewezen adres uitgevoerd.

Echter met het bezwaar dat de uitvoer onmiddellijk achter de laatste cursor-positie begint. Zoals U ziet stopt het programma netjes op adres A014. We hebben hier te doen met een primitief "breakpoint". Verderop zullen we nog kennis maken met geavanceerdere methoden om een programma op een willekeurig adres - zonder afhankelijk van bepaalde condities - te laten stoppen. Vervelend bij de uitvoering van het programma is dat de uitvoer door de bestaande tekst wordt geschreven. We kunnen hierin verbetering brengen door kiezen van video-mode 1 i.p.v. de video-mode 2 waarin MSXtra opstart.

We kiezen deze video-mode vanuit commando-mode:

C

V1<CR> ( Video-mode 1 )

Zetten vervolgens de program-counter en de stackpointer goed en laten het programma lopen:



RPC=A000<CR>

RSP=B000<CR>

X<CR>



G -A014<CR>

Ook is er nog de video-mode 0 welke met een geheel schoon scherm begint.

We demonstreren dit als volgt:



-------------------------------------- 10 -------------------------------------



C



V0<CR>



RPC=A000<CR>

RSP=B000<CR>

X<CR>



G -A014<CR>

Doordat we gebruik maken van het "primitieve" breakpoint G -A014 komt deze video-mode niet geheel tot zijn recht. De echte breakpoints brengen hierin verbetering.

Ook is het mogelijk dit korte programma als USR functie te laten lopen onder besturing van het MSX Basic. Hiervoor moet onze routine in ieder geval eindigen met een RET instructie, dus:

C



AA014<CR>

RET<CR>

.<CR>



We gaan nu tijdelijk MSXtra verlaten met:

Q<CR> ( Quit )

Hier bevinden we ons op vertrouwd terrein! We starten het programma met:

DEFUSR=&HA000:A=USR(0)

We keren na afloop van dit uitstapje naar BASIC weer terug met:

_MSXtra



Hoewel dit ook vanuit Basic kan is er de mogelijkheid om rechtstreeks dit stukje machinetaal - vanuit commando-mode - naar een cassette weg te schrijven met:



WA000-A014,<naam> ( Write A000-A014,'naam' )

Waarin <naam> door U mag worden ingevuld. Ook is er de mogelijkheid om een machine-programma te laten laden en vervolgens met MSXtra te onderzoeken, b.v.



G,<naam><CR>

Tijdens het laden worden - beginnend op de onderste regel - de naam van de programma's aangegeven die van de tape worden gelezen maar niet overeenstemmen met de gewenste naam of een Basic programma zijn. Is het gewenste programma gevonden dan wordt dit gemeld met 'loading -'. Is het programma foutloos geladen dan wordt het beginadres meegedeeld.



Bovendien biedt MSXtra nog de mogelijkheid om een machinetaal programma te laden met een offset t.o.v. het van de tape gelezen beginadres, b.v.



G1000,<naam><CR>

De offset wordt met het begin-adres verrekend. We moeten er wel om denken dat het beginadres niet het startadres hoeft te zijn.



-------------------------------------- 11 -------------------------------------





8. Breakpoints, Execute




MSXtra geeft de mogelijkheid tot het zetten van maximaal 8 breakpoints. Dit is het aanwijzen van adressen in het programma, waar U een "run" wilt onderbreken om bijvoorbeeld tussenresultaten te bestuderen, of om tijdig een mogelijk te verwachten "crash" van het programma te voorkomen.



We zullen dit nagaan aan de hand van het voorgaande programma dat eindigde op adres A014. We zetten het "breakpoint" met :

B0:A014<CR>

MSXtra meld zich nu met een adres, en op dezelfde manier als we bij de assembler zagen, kunnen we nu een stukje programma of liever een voorwaarde invoeren waarop ons programma straks zal stoppen. We kiezen voor de mogelijkheid "unconditional":



.U<CR>



En zien dat hiermee de instructie XOR A en RET worden aangemaakt. Zoals we dat ook bij de assembler hebben gedaan keren we terug naar commando-mode met:

.<CR>



We hebben nu het eerste "breakpoint" gezet, maar nog niet geactiveerd. We doen dit met:



B0+<CR>

We kunnen altijd nagaan welke van de breakpoints geactiveerd zijn. We doen dit met:



B<CR>



En zien dan op de onderste schermhelft:

0 A014 + 0000

1 0000 - 0000

2 0000 - 0000

3 0000 - 0000

4 0000 - 0000

5 0000 - 0000

6 0000 - 0000

7 0000 - 0000



De betekenis van de vier kolommen is als volgt: De eerste kolom geeft het nummer van het breakpoint terwijl de tweede kolom aangeeft op welk adres het is gezet. De derde kolom geeft aan of het breakpoint is geactiveerd, de laatste kolom vormt een teller welke het aantal evaluaties van het breakpoint bijhoud.



Ook kunnen we nagaan voor welke conditie een breakpoint is ingesteld. We doen dit voor het eerste breakpoint met:

B0<CR>



En zien dan alle informatie betreffende dat breakpoint:

-------------------------------------- 12 -------------------------------------



0 A014 + 0000



7998 AF XOR A 7999 C9 RET

799A 00 NOP

799B 00 NOP

etc.



We laten nu ons programma weer lopen in de video-mode 0:

V0<CR>

RPC=A000<CR> RSP=B000<CR> X<CR> ( eXecute until Breakpoint. )

En zien nu de uitvoer netjes bovenaan het scherm beginnen. Dat het programma correct gestopt is op adres A014 vinden we door terug te keren naar commando-mode:



C



Voordat we nu verder gaan met breakpoints gaan we eerst kennis maken met video-mode 3, de laatste uit de serie. Deze video-mode geeft alleen de status van de registers en is vooral van nut indien de afloop van een programma wordt gelogd op een printer.



We schakelen de printer in en voeren de volgende commando's in:

C

V3<CR>

V+<CR>

RPC=A000<CR> RSP=B000<CR> X<CR>



We kiezen voor stap voor stap uitvoeren waarbij de RST 18 met de S-toets wordt doorlopen (zie 9). De video-mode 3 plaatst een enkele kopregel waarin de registers worden benoemd. Vervolgens steeds bij iedere stap het adres, de instructie en de inhoud van de registers. Wordt hierbij op de printer steeds een regel geproduceerd, het beperkte aantal karakters op b.v. een MSX-1 staat dit niet toe.



We gaan nu in ons programma een tweede breakpoint plaatsen waarbij steeds de status wordt getoond zonder te stoppen:

B1:A010<CR> .S<CR>

.N<CR>

.<CR>



En activeren dit met:



B1+



We kiezen video-mode 3, zetten de registers goed en starten:

-------------------------------------- 13 -------------------------------------



V3<CR>

RPC=A000<CR> RSP=B000<CR> X<CR>

E



We zien nu steeds op adres A010 de status van de registers waarbij, geheel overeenkomstig met ons korte programma, alleen de registers A, B, en F zich wijzigen.



Bekijken we dan nu eens een conditioneel breakpoint. Hierbij wordt in tegenstelling met wat we tot nu toe gezien hebben het breakpoint gevalueerd d.m.v. een kort programma:



B2:A004<CR> LD A,B<CR> CP 20<CR> RET<CR> .<CR>



We activeren dit break point maar willen even geen hinder van breakpoint 1:

B1-<CR> B2+<CR> RPC=A000<CR> RPS=B000<CR> V1<CR>

X<CR>

E



We zien nu het programma weer aflopen zoals we al eerder zagen echter bij het bereiken van het character '_' wordt het programma gestopt op adres A004

met in register B de waarde 20. Bij een nader bekijken van de instructies die het breakpoint evalueren zien we dat een "break" optreedt wanneer de Z-flag wordt gezet.

Dat dit evalueren wel eens lang kan duren zullen we aan de hand van een tweede voorbeeld nog eens bekijken. We schakelen ook breakpoint 2 uit en zetten breakpoint 3:



B2-<CR> B3:A00D<CR> LD A,H<CR> CP 12<CR> RET NZ<CR> LD A,L<CR> CP 34<CR> RET<CR> .<CR>



Vervolgens initiren we de PC en SP, kiezen video-mode 2, activeren het breakpoint en starten:



RPC=A000<CR> RSP=B000<CR> B3+<CR> X<CR>

E



We kunnen nu een paar minuten besteden aan het drinken van een kopje koffie! Als dan tenslotte gestopt wordt op het breakpoint zien we dat het

-------------------------------------- 14 -------------------------------------



register HL inderdaad de waarde 1234 bevat. We kijken ook nog in de breakpoint-tellers met:

B<CR>



en zien dat de teller van B2 bevat 41; hier was inderdaad gestopt bij het afdrukken van het 41-ste karakter.





9. Subroutine




Voor het in een keer doorlopen van een subroutine (CALL) en routines ingeleid door de instructie RST is onder execute-mode een speciaal commando "S" (subroutine). Dit commando werkt een subroutine in zijn geheel af. We zullen dit bekijken door de wachtlus in het programma te gaan opnemen in een subroutine. We gebruiken daarvoor de in commando-mode aanwezige "copy"

opdracht. Dit commando geeft de mogelijkheid om geheugenblokken, of anders gezegd, programmadelen te verplaatsen. Breng MSXtra hiervoor in de commando-mode en toets het volgende in:

CA007-A00E,A020<CR>

Waarmee het programmastuk van adres A00C tot A00E is gekopieerd naar het geheugenstuk beginnend bij adres A020. We moeten dit gekopieerde stuk nog tot een subroutine maken. We sluiten het daarom af met een RET, dus:

AA028<CR> RET<CR> .<CR>



We completeren het oorspronkelijke programma waarbij weer iedere regel wordt afgesloten met een <CR>:

AA007

CALL 0A020

POP AF

INC A

POP BC

DJNZ 0F5



Opnieuw initiren we de PC en SP en zetten bovendien voor alle zekerheid een breakpoint op A00F:



RPC=A000<CR> RSP=B000<CR> B0:A00F<CR> .U<CR>

,<CR>

B0+<CR> X<CR>

E



We zetten de PC op A000 en kunnen dan met de spatiebalk het programma doorstappen. Daar waar de PC een CALL of RST aanwijst maken we consequent gebruik van de toets S.



-------------------------------------- 15 -------------------------------------





10. De praktijk




In een studieboek over de Z80 vinden we het onderstaande eenvoudige programma, dat de inhoud van registers C en E vermenigvuldigt en het resultaat in het registerpaar HL zet.



LD B,8

LD C,9

LD D,0

LD E,5

LD HL,0

MUL SRL C

JR NC,EVEN

ADD HL,DE

EVEN SLA E

RL D

DEC B

JR NZ,MUL

HALT



We voeren dit programma als volgt in; elke regel afgesloten met een <CR>.



A9000

LD B,8

LD C,9

LD D,0

LD E,5

LD HL,0

SRL C

JR NC,7F

ADD HL,DE

SLA E

RL D

DEC B

JR NZ,0FF

<CR>



We hebben voor de relatieve sprongen naar de labels EVEN en MUL voorlopig de waarde 7F (vooruit) en 0FF (achteruit) ingevuld. We bekijken nog eens de "list":



L9000<CR>

met resultaat:



9000 06 08 LD B,8

9002 0E 09 LD C,9

9004 16 00 LD D,0

9006 1E 05 LD E,5

9008 21 00 00 LD HL,0

900B CB 39 SRL C

900D 30 7F JR NC,7F 908E

900F 19 ADD HL,DE

9010 CB 23 SLA E

9012 CB 12 RL D

9014 05 DEC B

9015 20 FF JR NZ,FF 9016



-------------------------------------- 16 -------------------------------------



De relatieve sprongen op adressen 900D en 9015 verwijzen echter nog naar de aangegeven (foutieve) adressen. Als de instructie op adres 900D (JR

NC,EVEN) wordt uitgevoerd, zal de PC tijdelijk naar de eerstvolgende, nog uit-tevoeren, instructie wijzen. In dit geval dus naar 900F. De relatieve sprong moet echter zijn naar adres 9010. We kunnen nu deze sprong uitrekenen met het commando H. Toets het volgende in:

<CX>

H900F,9010<CR>

Waarop MSXtra antwoordt met:



Sum: 201F Diff: FFFF 0001



De sprong is dus 01; we vullen deze sprong dus correct in met:

A900D<CR> JR NC,1<CR>

Op dezelfde manier berekenen we de relatieve sprong voor adres 9015 (JR

NZ,MUL) met:



H9017,900B<CR>

Met resultaat:



Sum: 2022 Diff: 000C, FFF4



Hier dus een - in twee complements voorstelling - relatieve sprong ter grootte van F4, zodat nu:



A9015<CR> JR NZ,0F4<CR> .<CR>



We controleren nu met:



L9000<CR>

met nu het juiste resultaat:



9000 06 08 LD B,8

9002 0E 09 LD C,9

9004 16 00 LD D,0

9006 1E 05 LD E,5

9008 21 00 00 LD HL,0

900B CB 39 SRL C

900D 30 01 JR NC,01 9010

900F 19 ADD HL,DE

9010 CB 23 SLA E

9012 CB 12 RL D

9014 05 DEC B

9015 20 F4 JR NZ,F4 900B



We kunnen dit programma laten lopen op de verschillende in 7 genoemde manieren.



-------------------------------------- 17 -------------------------------------





11. Een grafische exercitie




Met behulp van de assembler voeren we het volgende programma in waarbij iedere regel - uiteraard zonder het commentaar - wordt afgesloten met een return.



A9000

LD A,2

CALL 5F ; select screen 2

LD A,(0F3E9) ; forground LD (0F3F2),A ; to ATRBYT

XOR A

LD B,A

LD C,A

LD D,A

LD E,A

PUSH AF

PUSH BC

PUSH DE

CALL 111 ; maps coord. to physical address CALL 120 ; set pixel to forground color POP DE

POP BC

POP AF

INC BC

INC DE

DEC A

JR NZ,0EF



XOR A

CALL 5F ; back to screen 0

.



We zetten een breakpoint na de laatste instructie en activeren dit:





B0:9025


.U

.

B0+



Daarna zetten we de PC en SP en starten:

RPC=9000

RSP=B000

X

E



We zien kortstondig de plot van een diagonale lijn waarna een terugkeer naar MSXtra. Als we de plot wat beter willen bekijken moeten we trachten het programma even op te houden. We doen dit met een speciaal breakpoint dat we 'B7' zullen noemen en wat we gaan plaatsen juist voor terugkeer naar screen





0.




We keren eerst weer terug naar commando-mode:

C





B7:9021


CALL 0B7


LD A,0



-------------------------------------- 18 -------------------------------------



ADC A,0FF

JR NZ,0F7

.N

.



We herstellen de verschillende registers, activeren ook dit B7 breakpoint en starten opnieuw:



RPC=9000

RSP=B000

B7+

X

E



Het programma blijft nu wachten op het adres waar het B7 breakpoint is gezet en zal pas doorgaan als de toetsen CTRL en STOP tegelijk worden gedrukt. Dit B7 breakpoint is ook in vele andere situaties beslist een erg handig hulpmiddel! De naam B7 heeft natuurlijk niets te maken met de instructie CALL 0B7 maar vormt wel een leuk ezelsbruggetje.



Tot slot een eenvoudige invoer-routine waarbij nogmaals het gebruik van het conditionele breakpoint wordt gedemonstreerd.



AA00

CALL 9F

CALL 0A2

JR 0F8

.

RPC=A000

RSP=C000





B0:A003


CP 1B


RET

.

B0+

V0

X

E



We kunnen nu onze gang gaan met invoeren vanaf het keyboard en ontsnappen uit dit kleine programma met een <ESC>





12. Eigen utillities




MSXtra heeft voor zijn variabele een locale RAM. In deze RAM is nog een flink stuk bruikbaar voor het onderbrengen van eigen utilities. Dit vrije stuk loopt van 7C00 tot 7FFF. Om nu dit stuk RAM bruikbaar te maken is het vraagteken nog als extra commando beschikbaar. Bij opstarten wordt voor dit commando een 'hook' geplaatst op adres 7FFD. Willen we gebruik maken van deze uitbreiding dan moet adres 7FFD worden overschreven met een sprong naar b.v. adres 7C00 waar we onze utility plaatsen.



In de voorafgaande paragrafen hebben we regelmatig registers zoals de PC en SP moeten herstellen. Het zou handig zijn als we dit met een enkel commando kunnen uitvoeren. De inhoud van deze registers SP en PC worden in MSXtra-RAM opgeborgen en wel op adressen 7AB1 en 7AB3. Onze utility moet er

-------------------------------------- 19 -------------------------------------



dus voor zorgen dat op deze adressen de door ons gewenste waarden worden geplaatst. We handelen daarvoor als volgt:

A7FFD

JP 7C00 ; overschrijf de hook .

A7C00

LD BC,4

LD DE,7AB1

LD HL,7E00

LDIR

RET

.



Dit stukje programma kopieert vier bytes vanaf adres 7E00 naar het geheugenblok beginnende bij adres 7AB1. We moeten dus nu nog de gewenste waarden 7E00 plaatsen:



S7E00

00 B0 00 A0.



We zetten nu om het geheel te controleren PC en SP op nul en gaan na wat er gebeurt bij invoeren van het vraagteken:

RPC=0

RSP=0

?



Het is ook goed mogelijk om meer dan een utility onder het vraagteken te plaatsen. We demonstreren dit aan de hand van het volgende voorbeeld er vanuit gaande dat de hook reeds is overschreven. Voor een betere leesbaarheid van dit voorbeeld is naast de met behulp van het toetsenbord in te voeren linkerkolom rechts nog een verklarende versie geplaatst.



A7C00

LD A,(DE) LD A,(DE) CP 53 CP 'S'

JR Z,09 JR Z,SAVE

CP 52 CP 'R'

JR Z,11 JR Z,RESTORE

CP 43 CP 'C'

JR Z,19 JR Z,CLEAR

RET RET

LD BC,18 SAVE: LD BC,18H

LD DE,7C32 LD DE,SAVREG

LD HL,7AB7 LD HL,RSA LDIR LDIR

RET RET

LD BC,18 RESTORE: LD BC,18H

LD DE,7AB7 LD DE,RSA LD HL,7C32 LD HL,SAVREG

LDIR LDIR

RET RET

LD BC,18 CLEAR: LD BC,18H

LD DE,7AB7 LD DE,SRA LD HL,7C56 LD HL,ZEROBLOCK

LDIR LDIR

RET RET

.



-------------------------------------- 20 -------------------------------------



En we zetten nog 24 bytes op nul



K7C56-7C7A,00



We hebben nu de beschikking over 3 commando's: '?S' redt alle registers in de geheugenruimte vanaf 7C32; '?R' herstelt alle registers weer met die waarden die met '?S' veilig zijn gesteld. Tenslotte kunnen met '?C' alle registers op nul worden gezet. Deze eenvoudige routine laat zich nog redelijk snel met het toetsenbord inbrengen, wordt er echter aanzienlijk uitgebreid dan kan deze beter worden weggeschreven naar cassette met:

W7C00-8000,UTIL



Bij het leggen van de laatste hand aan MSXtra kon boven staande utility nog worden kwijtgeraakt in de resterende bytes van de ROM. We kunnen nu e.e.a.

bereiken met:



PS ( Processor Save ) PR ( Processor Restore ) PC ( Processor Clear )

N.B. Het BASIC programma opgenomen in de appendix is een voorbeeld van een automatisch startend programma om een utility te installeren (AUTOEXEC.BAS).

In dit voorbeeld is gebruik gemaakt van bovenstaande register-manipulaties maar dit kan natuurlijk worden omgewerkt voor b.v. disk-routines.





13. MSXtra en BASIC




We resetten onze MSX en gaan het volgende Basic-programma invoeren:

10 RESTORE

20 DEFUSR=&HA000

30 READ N

40 FOR I=0 TO N

50 READ D$: D=VAL("&H"+D$) 60 POKE &HA000+I,D

80 CLS: INPUT"Geef getal";X%

90 R=USR(X%)

100 PRINT "+1 wordt: ";R

110 END



120 DATA 14,3A,63,F6,FE,02,20,07

130 DATA 2A,F8,F7,23,22,F8,F7,C9



We zien al snel dat in het Basic een user-functie zit. Laten we het programma lopen dan vinden we dat het in te voeren getal met n wordt opgehoogd. Wat er precies in de user-functie gebeurt is echter niet zo eenvoudig te achter-halen.

Maar MSXtra brengt ook hier uitkomst! We voegen een extra regel toe juist voordat de machinetaalroutine wordt aangeroepen:

85 CALL MSXTRA (of korter: 85 _MSXTRA)

Als we nu het programma weer laten lopen dan komen we natuurlijk in MSXtra terecht en kunnen dan gaan zien wat er precies staat op het door DEFUSR gespecificeerde adres A000 met:

-------------------------------------- 21 -------------------------------------



LA000



Met als resultaat:



A000 3A 63 F6 LD A,(F663) A003 FE 02 CP 02

A005 20 07 JR NZ,07

A007 2A F8 F7 LD HL,(F7F8) A00A 23 INC HL

A00B 22 F8 F7 LD (F7F8),HL

A00E C9 RET



Adressen boven F000 zijn systeem variabelen van het MSX-Basic en in een handboek kunnen we opzoeken wat de adressen F663 en F7F8 precies voorstel-len. Voor F7F8 vinden we dat dat adres ligt in het gebied waar de parameter van een USR-functie wordt geplaatst, terwijl F663 het type van deze parameter kan worden gevonden.

Bekijken we in het handboek de basic instructie USR wat nauwkeuriger dan blijkt het hier te gaan om een parameter van het type integer.



Blijkt deze USR-functie dan toch nog simpel, MSXtra kan ons in moeilijkere gevallen helpen met het USR-breakpoint.

We kunnen dit USR-breakpoint demonstreren aan de hand van het nog voor-handen zijnde Basic programma inclusief de toegevoegde regel 85. We laten het programma weer lopen en zodra we in MSXtra zijn beland geven we het comando:



UA000<CR> ( User-breakpoint op A000 )

We keren vervolgens terug naar Basic met:

Q<CR>



De eerst volgende Basic regel - de USR functie - wordt nu uitgevoerd en deze doet ons opnieuw in MSXtra belanden en wel met de PC gezet op adres A000.

We kunnen nu overgaan naar executie-mode en de machinetaal doorstappen met de hiervoor beschikbare commando's. We mogen echter niet de standaard breakpoints gebruiken en ook moeten we tijdig d.w.z. voor de laatste machinetaal instructie RET. Terugkeren naar Basic moet dan voor deze RET

met:



UQ<CR> ( User-Quit )

Als we in regel 80 en 90 het % teken weglaten gaat er met de werking van de subroutine natuurlijk iets mis. We zouden met behulp van het USR-breakpoint eens precies kunnen nagaan wat. Tenslotte nog dit: er is slechts een USR-breakpoint, maar voor het uitplussen van Basic opgenomen machinetaalroutines is dit voldoende.





14. MSXtra en andere cartridges




MSXtra geeft de gereedschappen om van andere cartridges de software te bekijken. Voor dat we hier op ingaan zullen we eerst globaal bekijken hoe een MSX-1 met cartridges omgaat. Als de machine wordt opgestart worden eerst zoveel mogelijk pagina's RAM - zonodig uit verschillende slots - bijeen gezocht, en wel zodanig dat een aaneensluitend blok ontstaat. Vervolgens

-------------------------------------- 22 -------------------------------------



bekijkt MSX-Basic alle slots - te beginnen bij slot0 - of er in het adresgebied 4000 tot BFFF een cartridge aanwezig is. Voor dit doel zijn in een cartridge de eerste 8 x 2 bytes gereserveerd. Het eerste paar vormt de feitelijke identificatie en bevat daarvoor de code 'AB' (in ASCII). Het tweede paar kan het adres van een initialisatie-procedure bevatten maar veelal staat hier '00

00' zoals voor de meeste 'game-cartridges'. Het derde paar vormt een startadres waarop de Basic instructie CALL aanspreekt. Deze laatste twee adressen geven ook uitsluitsel voor welk adresgebied de cartridge is bestemd.



Het vierde paar bevat het adres van de z.g."device handler"; dit als de cartridge niet alleen bedoeld is voor software. Als het vijfde paar geen nullen zijn dan is in de cartridge een basic programma geplaatst. Het aanwezig zijn van dat adres betekent dat zo'n cartridge bij het inschakelen van de machine meteen opstart. De overige bytes zijn bedoeld als reserve. Diegene die aangaande het voorgaande wat meer willen weten, vinden aan het eind van deze handleiding een literatuurlijstje.



Om een zelf-opstartende cartridge met een Basic-programma te kunnen binnendringen gaan we als volgt te werk. We plaatsen MSXtra en de door ons te onderzoeken cartridge ieder in een slot. Vervolgens schakelen we de machine in en houden gelijktijdig de toetsen CTRL en STOP ingedrukt waardoor we de auto-start van MSXtra nemen. We voeren het volgende in:

AD000<CR> LD A,1 ; selecteer slotnummer 1

LD H,80 ; selecteer pagina 2

CALL 24



We zetten e.e.a. gereed en executeren met stappen:

RPC=D000<CR> RSP=F000<CR> X<CR>

<spatie> <spatie> S

C



Met LD A,1 trachten we het slot te selecteren waarin de te onderzoeken cartridge zit. We moeten dus nagaan of we wel het juiste slot hebben geselec-teerd en doen dat met:

D000<CR>

Vinden we onzin, b.v. alleen maar FF of 1A, dan is de keuze van het slot niet correct geweest en doen we alles nog eens over met LD A,2 i.p.v. LD

A,1. Dit laatste is eenvoudig uit te voeren met:

SD001<CR> 02.<CR>

Pas als we bij een dump vanaf adres 8000 als eerste de bytes 41 en 42 vinden zijn we in onze opzet geslaagd en kunnen met alle beschikbare gereedschappen de cartridge verder exploreren.



Cartridges welke bedoeld zijn voor adresbereik vanaf 4000 vragen wat meer moeite. Hier moet na het selecteren van het juiste slot de inhoud daarvan ook nog worden verplaatst. Dit kan dan als volgt:

-------------------------------------- 23 -------------------------------------



LD A,2

LD H,40

CALL 24

LD HL,4000

LD DE,8000

LD BC,4000

LDIR

LD A,1

LD H,40

CALL 24



Bij het teruggaan naar MSXtra is aangenomen dat dit in slot 1 is geplaatst.

Als e.e.a. dus niet naar verwachting werkt moet dus ook hier een ander slotnummer worden gekozen.





15. Overzicht van opdrachten




Notatie:



addr: hexadecimaal adres bv. AB25, E46, 12345 (=2345)

data: hexadecimaal of alphanumeriek data bv. 12 ED 34 0 12

'string'

1 2 3 'ABC' 4 5 6

'"s morgens'



n: hexadecimale waarde bv. 55, 0,AE4E, EEDC2 (=edc2)

[..] het gedeelte tussen de haken is optioneel

|: scheiding tussen verschillende mogelijkheden

Edit mogelijkheden van de commando- of executie-regel

INS schakelen tussen: invoegen -aan en -uit DEL karakter onder de cursor verwijderen <- cursor naar links -> cursor naar rechts BS backspace

CLR/HOME gehele lijn wissen

-------------------------------------- 24 -------------------------------------



Commando mode:

A Assemble: Starten van de invoer van een programma.



Formaat: Aaddr

Beschrijving: de invoer kan bestaan uit instructies in het door ZILOG

aangegeven formaat. Hexadecimale waarden die met een letter beginnen moeten door een nul worden voorafgegaan.

Met een punt, '.', kan de invoer worden beindigd.



Voorbeeld: A9000

LD HL,0

DEC HL

LD A,H

OR L

JR NZ,0FB



B Breakpoints: Zetten, tonen en aan- of uitschakelen van de voorwaardelijke breakpoints.



Formaat: B[|+|-|n]

Bn[+|-]

Bn:addr



Beschrijving: Er zijn in totaal 8 voorwaardelijke breakpoints aanwezig.

De voorwaarde (conditie) wordt gevormd door een klein stukje programma dat evalueert tot een Z toestand of een NZ toestand; de Z toestand leid tot beindiging van het lopende programma. De conditie wordt afgesloten met een RET instructie.



B Toon de status van alle 8 breakpoints: nummer,adres, aan (+) of uit (-) en het aantal maal dat het breakpoint bereikt is.



B+ Zet alle breakpoints aan; B- Zet alle breakpoints uit;

Bn+ Zet breakpoint n aan; Bn- Zet breakpoint n uit (n=0-7).



Bn Toon de status en conditie van breakpoint n.



-------------------------------------- 25 -------------------------------------



Bn:addr Zet breakpoint n op adres addr en vul de conditie in. De conditie wordt op dezelfde manier ingevoerd als een programma (zie het A commando). Er zijn 32 geheugen plaatsen gereserveerd voor de conditie; dit komt overeen met ongeveer 14 regels programmatekst. In het programma wat de conditie bepaald (Z of NZ) mogen alle registers van waarde worden veranderd.

Er zijn 3 extra 'instructies' aanwezig: .U retourneert een Z conditie (unconditional break); .N retourneert een NZ conditie (no break); .S toont de status van het programma (de registers en de vlaggen).



Voorbeelden: (van condities) stop altijd:

.U



toon de status zonder te stoppen: .S

.N



stop als B=20; LD A,B

CP 20

RET



stop als HL=1234

LD A,H

CP 12

RET NZ

LD A,L

CP 34

RET



stop als (562A)>80

LD A,(562A)

CP 81

JR NC,3 ;spring naar .U

.N

.U



C Copy: Kopiren en verschuiven van een stuk geheugen.



Formaat: Caddr1-addr2,addr3



Beschrijving: Het stuk geheugen van addr1 tot en met addr2 wordt naar addr3 verplaatst; met mogelijke overlap wordt rekening gehouden.



Voorbeeld: C1000-2000,1001



D Dump: Tonen van een stuk geheugen.

Formaat: Daddr[-addr1]

Beschrijving: Het stuk geheugen vanaf addr tot aan addr1 (of addr+64

als addr1 niet is opgegeven) wordt getoond. Met een

-------------------------------------- 26 -------------------------------------



plus, '+', kan het volgende blok van dezelfde grootte worden bekeken, met een min, '-' het voorgaande blok.

Het commando wordt beindigd met een <CR>.



Voorbeeld: D100



F Find: Zoeken naar een string.



Formaat: Fdata

Beschrijving: Het zoeken naar de opgegeven string gebeurt vanaf adres 0. Met een plus, '+', kan naar het volgende voorkomen van de string worden gezocht. Voortijdig afbreken kan met <CR>.



Voorbeelden: F'MSXtra'



F4D 53 58 74 72 61



G Get: Inlezen machinetaal van cassette.



Formaat: G[addr],<naam>

Beschrijving: Inlezen van op cassette-tape opgeslagen data volgens het voor de MSX gespecificeerde "Machine language file format" Met addr kan een offset worden ingesteld. Niet met <naam> overeenstemmende files worden gemeld. Na laden wordt het beginadres gemeld.



H Hexadecimaal: Hexadecimaal rekenen.



Formaat: Hn1[,n2]



Beschrijving: De som n1+n2 en de verschillen n1-n2 en n2-n1 worden getoond. Als n2 niet wordt opgegeven wordt n2=0 ver-ondersteld.



Voorbeeld: H23EF,8E79



K Kill: Vullen van het geheugen met een herhaling van een string.



Formaat: Kaddr1-addr2,data

Beschrijving: Het geheugen van addr1 tot addr2 wordt gevuld met zoveel herhalingen van de string als nodig zijn.



Voorbeeld: KA100-A200,'Hallo' 3E 2E 23



L List: Disassembleren van een programma.



Formaat: Laddr[-addr2]



Beschrijving: Disassembleren vanaf addr1 tot addr2, of 14 regels als addr2 niet is opgegeven. Met,'+', kan een volgende blok worden gedisassembleerd; afbreken met <CR>.



-------------------------------------- 27 -------------------------------------



Voorbeeld: L100



M Move: Verplaatsen van de stack van MSXtra.



Formaat: Maddr

Beschrijving: De stack van MSXtra begint normaal gesproken 64 bytes onder de BASIC stack. In voorkomende gevallen kan het gewenst zijn om de stack naar een ander geheugendeel te verplaatsen. Dit gebeurt dan met dit commando, waarbij de nieuwe stack begint op het aangegeven adres addr.

N.B. vanaf adres 7904 is in de RAM van MSXtra ruimte voor de stack gemaakt. Deze plaats is echter alleen bruikbaar als er geen gebruik wordt gemaakt van een disk!



Voorbeeld: M7904



P Processor: Simultaan behandelen van processor registers.



Formaat: Px

met x : S, R, C



Beschrijving: S: alle registers tijdelijk bewaren; R: alle met S bewaarde registers weer herstellen; C: alle registers op nul zetten.

De informatie blijft behouden na een reset van de machine.



Q Quit: Verlaten van MSXtra.



Formaat: Q



R Registers: Veranderen van registers.



Formaat: Rreg=n met reg : A , B , C , D , E , H , L , A', B', C', D', E', H', L', BC, DE, HL, BC', DE', HL', IX, IY, SP, PC .

R[F|F']=flag

met flag: M, Z, H, P, N, C



Beschrijving: alle registers, behalve het interrupt register IV en het refresh register R, kunnen worden gewijzigd. De vlaggen kunnen ieder afzonderlijk gewijzigd worden, dit werkt als een aan- uit- schakelaar.



Voorbeelden: RD=34

RBC'=4321

RF=Z

RF=Z



S Set: Veranderen en inspecteren van het geheugen.



Formaat: Saddr

-------------------------------------- 28 -------------------------------------



Beschrijving: Het geheugen kan met hexadecimale waarden of met Strings worden gevuld. De invoer wordt afgesloten met een punt,'.'. Indien een lege regel wordt gegeven (met een <CR> wordt de betreffende locatie niet veranderd.



Voorbeeld: SA139

1 2 3 'ABC'.24 4.



U User: Zetten van een breakpoint in een BASIC USR() functie.



Formaat: Uaddr UQ



Beschrijving: Zet een (usr) breakpoint op het adres addr. Bij uitvoering van het BASIC programma met daarin de USR() functie, zal bij het bereiken van het adres addr automatisch naar MSXtra worden gesprongen. De PC en SP zijn van te voren geinitialiseerd; alle andere registers hebben de waarde nul. Er is slechts 1 USR() breakpoint! Nadat de USR() functie is uitgevoerd moet MSXtra vanwege de speciale start worden beindigd met UQ (User Quit) i.p.v.

Q. Het BASIC programma loopt dan weer verder.



V Video: Veranderen van de lay-out in executie mode; aan- en uitzetten van de printer.



Formaat: V+|-

Vn



Beschrijving: Er zijn verschillende formaten uitvoer in executie mode beschikbaar

mode 0: geen uitvoer; mode 1: alleen register blok; mode 2: pointer registers met geheugeninhoud; mode 3: scrollend formaat.

Met V+ gaat alle uitvoer ook naar de printer, zowel voor commando- als executie-mode. Met V- wordt de uitvoer naar de printer weer uitgeschakeld. Standaardmatig wordt V- en V2 aangenomen

Voorbeeld: V+

V3



W Write: Schrijven van machine-taal naar cassette.



Formaat: Waddr1-addr2,<naam>

Beschrijving: Het geheugenstuk van addr1 tot en met addr2 wordt volgens het voor MSX gespecificeerde "Machine language file format" weggeschreven naar cassette-tape.



X eXit: Verlaten van de commando-mode, starten van de executie-mode.



Formaat: X



-------------------------------------- 29 -------------------------------------



Executie mode:



C Command: Terugkeren naar de command mode.



Formaat: C



E Execute: Starten van een programma.



Formaat: E



Beschrijving: De uitvoering van het programma start vanaf de huidige programmateller. De uitvoering stopt pas na het bereiken van een ingevoerd conditioneel breakpoint (indien aan de voorwaarde is voldaan).



G Go: Starten van een programma vanaf, respectievelijk tot het bereiken van een bepaald adres.



Formaat: G [-]addr

Beschrijving: Gaddr heeft de zelfde werking als E (zie boven) maar de uitvoering start nu vanaf addr i.p.v. de huidige programmateller. G-addr heeft dezelfde als E, maar er wordt nu een extra (onvoorwaardelijk) breakpoint gezet op addr.



Voorbeelden: G

G -3454



S Single step: Uitvoeren van een instructie.



Formaat: S

(spatiebalk!)

Beschrijving: De instructie waarnaar de programmateller wijst wordt uitgevoerd. Als de instructie een CALL of RST instructie is, dan wordt met S de subroutine in zijn geheel uitgevoerd, met (spatie) wordt alleen de CALL of RST

instructie uitgevoerd.



T Trace: Stap voor stap uitvoeren van een reeks instructies.



Formaat: T [S]n T [S]-addr



Beschrijving: Met Tn worden n (n hexadecimaal) instructies vanaf de programmateller uitgevoerd. Na iedere instructie wordt de status getoond. Met T -addr worden de instructies vanaf de programmateller tot aan addr uitgevoerd. Indien de optie S wordt opgegeven worden alle subroutines als geheel uitgevoerd.



Voorbeelden: T 10

T S-96AF



-------------------------------------- 30 -------------------------------------



N.B. Met uitzondering van de assembler, zijn alle in te voeren data in hexadecimaal (byte) of alfanumeriek omgeven door enkele aanhalingstekens. Ook is bij de assembler alfanumerieke invoer niet toegestaan.



Het InterruptVector register mag alleen onder het gebruik van de opdrachten E of G <addr> tijdelijk worden gewijzigd. D.w.z. dat voor het bereiken van enig "breakpoint" de oorspronkelijke waarde van dit register moet zijn hersteld.

Ook mag dit register worden gewijzigd in een subroutine, mits deze wordt doorlopen met de opdracht S en de oorspronkelijke waarde voor het bereiken van de bijbehorende RET weer is hersteld.



Literatuur:



MSX Technical Data Book. - Hardware/Software Specifications -

Uitgave: SONY



The complete MSX Programmers Guide.

Auteurs: Toshuyuki Sato / Paul Mapstone / Isabella Muriel Uitgever: Melbourne House.



MSX Rom-BIOS hand boek.

Uitgever: Terminal Software Publications.



-------------------------------------- 31 -------------------------------------





17. Schema van de MSXtra cartridge




De cartridge bevat 5 onderdelen: 1) 2764 = 8K x 8 EPROM (of 27C64) 2) 81C28 = 2K x 8 SRAM

3) 74LS138 = 3 naar 8 adres selector 4) + 5) = keramische condensators van 47nF



2764 81C28

MSX-SLOT 8K x 8 EPROM 2K x 8 SRAM

| | |

D0-----------------D0--------------D0

D1-----------------D1--------------D1

D2-----------------D2--------------D2

D3-----------------D3--------------D3

D4-----------------D4--------------D4

D5-----------------D5--------------D5

D6-----------------D6--------------D6

D7-----------------D7--------------D7

| | |

A0-----------------A0--------------A0

A1-----------------A1--------------A1

A2-----------------A2--------------A2

A3-----------------A3--------------A3

A4-----------------A4--------------A4

A5-----------------A5--------------A5

A6-----------------A6--------------A6

A7-----------------A7--------------A7

A8-----------------A8--------------A8

A9-----------------A9--------------A9

A10----------------A10-------------A10

A11----------------A11- - - - - - (A11) *)zie noot A12----------------A12- - - - - - (A12) *)zie noot | | |

| 74LS138 | |

| +-------+ | |

A14---|A Y0| | |

A13---|B Y1| | |

| |C Y2| | |

SLTSL---|G2A Y3| | |

A15---|G2B Y4| | |

+5V---|G1 Y5|-----CE |

| | Y6| | |

+5V---|VCC Y7|-----------------ALE/CS

GND---|GND | | |

| +-------+ | |

| | |

RD-----------------OE--------------OE

WR---------------------------------WE

| | |

| +---Vpp |

| +---PGM |

+5V------------+---VCC-------------VCC

-GND----------------GND-------------GND



In de nabijheid van de EPROM en de SRAM een keramische condensator van 47nF tussen +5V en GND.



Memorymap van de MSXtra cartridge.



4000 - 5FFF EPROM

6000 - 67FF SRAM

6800 - 6FFF schaduw van SRAM

7000 - 77FF schaduw van SRAM

7800 - 7FFF schaduw van SRAM



Door de ingebouwde SRAM, is deze cartridge volledig transparant voor het systeem, d.w.z. er wordt geen geheugen van de MSX-computer gebruikt voor de werking van het programma.



Noot) i.p.v. 2K-SRAM kan ook 8K-SRAM worden gebruikt.

uiteraard moet dan A11 en A12 worden aangesloten.

De 3 schaduwen in de memorymap vervallen dan, en de memorymap veranderd in:

4000 - 5FFF EPROM

6000 - 7FFF SRAM



-------------------------------------- 32 -------------------------------------</addr></naam></CR></CR></naam></naam></CR></CR></CR></CR></CR></spatie></spatie></CR></CR></CR></CR></CR></CR></CR></ESC></CR></CR></CR></CR></CR></CR></CR></CR></CX></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></naam></CR></naam></naam></naam></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CL></CL></CR></CL></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></CR></SPACE></CR></CR></CR></CR></CR></CR>





0

<b>MSXtra Monitor / debugger for MSX



MSXtra Version - 2.0 Dec. 1986.Copyright (C) A.A.M. Staring</b>

A publication of the PTC Technical Library, August 1987



Table of contents:



1. Introduction p. 2



2. First introduction p. 3



3. TRACE and DUMP p. 6



4. Disassembling p. 6



5. FIND and KILL p. 8



6. Assemble p. 9



7. GO QUIT and Video modes p.11



8. Break Points, Execute p.13



9. Subroutine p.16



10. Practice p.17



11. A graphical exercise p.19



12. Own utillities p.20



13. MSXtra enBASIC p.22



14. MSXtra and other cartridges p.23



15. Command Summary p.25



16. Literature p.32



17. Schedule of the cartridge p.33



-------------------------------------- 0 -------------------------------------





1. Introduction




MSXtra is a universal and compact software tools for use on MSX1 and MSX2. It includes both an assembler and a disassembler that covers the entire Z80 instruction set and moreover all the tools for debugging of programs written in machine language and in the BASIC program programs including user routines.



Through its user-friendly "user interface" - such as the use of "split screen "- MSXtra is also suitable for immediate development and testing of not too large subroutines. Also, MSXtra will prove to be an aid in studying and practicing the Z80 assembly language.



To make MSXtra directly usable for practical exercises, you will find in the examples, both an input and an output routine.



It is recommended that when going through this manual you regularly consult the OVERVIEW of COMMANDS in chapter 15.



All numbers shown in the following examples, if not expressly stated otherwise, read as hexadecimal.



This manual has been carefully checked for errors and ambiguities.

Should you nevertheless detect irregularities, please notify the author.



A.A.M. Staring



-------------------------------------- 1 -------------------------------------





2. First Step




Before placing the cartridge in slot of your MSX, you first turn it off, as you are obviously used to. After turning it on properly, the machine will boot as you would expect. You can now call MSXtra by typing in "CALL MSXTRA 'or the shorter '_MSXTRA' followed by pressing the RETURN key.



Note: From now on, pressing the RETURN key is indicated with the symbol <CR>



The screen of the MSX now displays the following image:

Main: A=00 Flags= PC=0000

BC=0000 DE=0000 HL=0000 DI IX=0000 IY=0000 SP=0000 JP 02D7

CP A

Alt: A=00 Flags= DEC DE

BC=0000 DE=0000 HL=0000 SBC A,B



Command: #



MSXtra - Version 2.0 Aug 1986



Copyright (C) A.A.M. Staring

The display is chosen for a dark font on a light background.

This is in the long run, even when using monochrome monitor, the least tiring for the eyes.



In the upper left we recognize the Z80 Registry names, in the wat that is generally common.

For both register banks (Main and Alt) all registers are set to the value 0. Also in the two flag registers all bits are reset. At the top right we see the program counter PC with the value zero. Underneath the five disassembled instructions (from the MSX-ROM) on the first memory locations from address 0000 as indicated by the PC.



The cursor behind the word "Command" invites to give a command. MSXtra has two "modes": the Command mode and the Execution mode. The just started MSXtra is - as indicated - in the command mode. We can bring MSXtra in the execution mode by typing

X<CR>



We now see the display being expanded with the registers of the 'Main'-

bank. But also the memory locations addressed by these registers and the seven folowing memory locations

All of this in a hexadecimal representation of the binary format used internally by the MSX.

Finally, in the last column, we find the so-called "printable ASCII equivalents'

of these memory locations. If there is no corresponding "printable" ASCII charcter, there is a dot here.



-------------------------------------- 2 -------------------------------------



Main: A=00 Flags= PC=0000

BC=0000 DE=0000 HL=0000 DI IX=0000 IY=0000 SP=0000 JP 02D7

CP A

Alt: A=00 Flags= DEC DE

BC=0000 DE=0000 HL=0000 SBC A,B



Execute: #



BC=0000 F3 C3 D7 02 BF 1B 98 98 ........



DE=0000 F3 C3 D7 02 BF 1B 98 98 ........



HL=0000 F3 C3 D7 02 BF 1B 98 98 ........



IX=0000 F3 C3 D7 02 BF 1B 98 98 ........



IY=0000 F3 C3 D7 02 BF 1B 98 98 ........



SP=0000 F3 C3 D7 02 BF 1B 98 98 ........



PC=0000 F3 C3 D7 02 BF 1B 98 98 ........



Only the Interrupt Vector Register is not shown. The content of this register can be changed only under special circumstances.



We go temporarily back to the command mode by just pressing the button:



C



We start with editing register contents, starting with PC



Enter:



RPC=A000<CR>

The program counter PC now points to address A000 of free RAM and the code that is present there is shown disassembled in the top right corner.



We now start changing the memory on the address specified by the PC by entering the command:



SA000<CR> (Set A000)

The word "Command" is overwritten with the requested address of A000

and behind it its content. We now type the following numbers, separated by a space, and ending with a dot:



1 2 3 4 5 6 7 8 9.<CR>

We now see on the lower half of the screen again displayed the address A000

that we have just modified. We now go back to the execution mode with:



X<CR>



-------------------------------------- 3 -------------------------------------



The entire screen contents will return again. Also on the bottom line (PC = A000), we can see that the contents of the addresses A000 up to and including A007 is changed in accordance with the input. These instructions can now be executed by pressing the space bar a number of times:

<SPACE>



We see that after an initial SPACE key press, instruction LD 0302 BC - i.e. load register pair BC with the value 0302 - is executed, that BC points to another memory location and that the PC points to the address A003 which contains the instruction INC

B. We also execute this and the following instructions.



The instruction DEC B, in conformity with the specification of this instruction, has set bit N in the Flag register.



Execution of the instruction EX AF, AF' indeed gives an exchange of the value of the flag registers, but we cannot observe a change of the A-registers because both contain the same value.



Arriving at address A009 we find an instruction that we no longer execute.



We can now step through these instructions again, but then with the different registers set back to their original value.

For that, we return to command mode:



C



And first of all restore the program counter:

RPC=A000<CR>

We put all other registers back with:



RBC=0<CR> RHL=0<CR> RF'=N<CR> X<CR>



Herewith we have returned to the original situation.

The registers can also be set individually to a certain value ; for example RB = 2, RC = 3, etc.



Registers of the second bank are indicated by the addition of a "quote", e.g. RH'= 5, RL' = 6.



When making a typo by which you indicate a non existent register MSXtra gives the error message "Error". This error continues to display until a next input. Also for errors in the other commands this error is displayed.



Now that we are discussing erroneous input: we can edit the command line with the horizontal cursor, insert and delete keys as we were used to for input in MSX-Basic.



You can compare changing the individual flags in the "Flag-registers"

with the operation of a switch. When, for example, the Z-flag is set, it will be reset with RF = Z; another RF = Z command will set the Z-flag again.



-------------------------------------- 4 -------------------------------------





3. TRACE and DUMP




In the execution mode are other ways to step through a program: the "trace".

We try the following after the previous recovery to the original situation:

T 8<CR> ( Trace 8 )

Again we see eight consecutive instructions being executed.

(Note Trace mode generates a space after T automatically.)

We again restore to the initial situation in command mode and then try:



T -A005<CR> ( Trace until A005 )

And then we see that only the instructions up to address A005 are executed.



We will now look at a number of commands and thus return to the command mode:



C



DA000<CR> ( Dump A000)

The result is a so called "Dump" in which we will recognize the just entered bytes.

The next block we dump with:



+



If we want to return to the previous block then use:

-



We end this dump with:



<CR>



It is also possible to dump a larger block at once with the command:

DA000-A300<CR>





4. Disassemble




We call the disassembler from command mode with:

LA000<CR> ( List A000 )

The result is a back translation of the bytes we input from address A000.

Also here we can see the next block using:

+



And we end the disassembling with:



<CR>



-------------------------------------- 5 -------------------------------------



If the disassembler encounters a sequence of bytes which cannot be instructions, it will be reported with a "No Code" message.



We now have the opportunity to "scroll" in the "operating system" of the MSX using:

D0<CR>



+



or backwards with:



-



Disassemble directly with:



L0<CR>



And here you can go only forward with:

+



The disassembler can not differentiate between instructions and data, therefore data will be translated as instructions.

The disassembler understand to disassemble a larger memory block when you use:



LA000-A300<CR>

Outputting a dump or disassembly to a printer connected to the MSX is also possible.

For that we switch the output to printer with the command:

V+



And stop the output to the printer with:

V-



Especially for disassembling this feature is very useful. You can check in advance on the screen which parts of the disassembled software are "code" and which parts contain "data". By "switching" between "L", "D"

"V +/-" you can get a clean layout on paper.



We once again return to editing memory locations. It is possible to enter both hexadecimal bytes and alpha-numerical data, in the latter case it should be surrounded by single quotes.



We try this:



<CR> SA500<CR>

'ABC' 2F 3D '3' AA '789'.<CR>

And check it with:



DA500<CR>

-------------------------------------- 6 -------------------------------------



MSXtra automatically starts with "CAPS LOCK" enabled; we can of course also enter lower case by making use of the "CAPS" key, from here on indicated with <CL>.



SA500<CR>

<CL> 'abc' <CL> 'ABC'.<CR>

DA500<CR>

<CR>



We should never forget to return to "CAPS LOCK" enabled, because only then MSXtra will accept commands!



NB A single "quote" in a string is indicated by doubling it, like in 'can''t'.





5. FIND and KILL




The next option is finding a "string", or determining whether a certain sequence of bytes, or alpha-numeric characters occurs once or more in memory. We test it with the following and do note the lower case characters:



F'MSXtra'<CR> ( Find 'MSXtra' )

The program will report:



Found at: 4098



We repeatedly continue the search with:

+



The final result:



Found at: 409F

Found at: 6108

Found at: 6908

Found at: 7108

Found at: 7908

Found at: FC01 (depending on the system)

Not found



We don't forget "CAPS LOCK" and verify things with:

D409F<CR>

D6108<CR>

D6908<CR>

etc.



-------------------------------------- 7 -------------------------------------



Only in the latter case, we can find only the characters "tra"; the first part is overwritten with "06.". So here we have discovered an command buffer!



Searching for hexa-bytes works as well, of course; We try:

F1 2 3 4 5 6 7 8 9<CR>

+



and:



F1 2 3 4 5 6 7 9 8<CR>

In both cases the expected result. The next feature provides the possibility to fill a block of memory with a specific sequence of bytes:



K9000-9050,FF<CR> (Kill 9000-9050 with FF)

With this, the memory space starting from address 9000 to address 9050, will be filled with the byte FF. (Kill) We check this with:



D9000<CR>

We also try:



K9000-9100,1 2 3 'ABC'<CR>

And check this with:



D9000<CR>

Or alternatively:



K9100-9200,'DEF' 7 8 9<CR>





6. Assembling




In MSXtra we also have a simple assembler, which, like the disassembler, covers the entire Z80 instruction set, but does not, like in a real assembler, calculate and substitute the addresses of labels in a second pass.

This task - which is simple for relatively small programs -

we must execute ourselves, and MSXtra has the necessary tools built-in to do this.



We start the assembler from the command mode with input from address A000 by means of the command:



AA000<CR> (Assemble at A000)

MSXtra displays the address A000 and behind it the contents of this address. We type in:



LD A,20<CR>

On the bottom half of the screen a list builds up consisting of the address, hexa code and the instruction that was just entered. Before the cursor MSXtra

-------------------------------------- 8 -------------------------------------



displays the next free address A002. In the event of making an error while typing this, MSXtra will report "Error" after the closing <CR> followed by going back to command mode. We can now start the assembler again from this last, still unused, address.



We continue entering the following, ending each line with a <CR>:

LD B,60

PUSH BC

PUSH AF

RST 18

LD HL, 0

DEC HL

LD A,L

OR H

JR NZ,0FB

POP AF

INC A

POP BC

DJNZ 0F0

.<CR>



With the latter .<CR>, an "empty" line, we finish the assembling. When inputting instructions, hexadecimal numbers need starting with a "letter" must be preceded by a zero.

See the just entered instructions JR NZ,0FA and DJNZ 0F0. The necessity of prefixing with a zero can be made clear with the following example.

The instructions LD A,B and LD A,0B are clearly different. The first loads the register A with the contents of the register B, while the second loads the A register with the byte 0B.

The program can be reviewed with:



LA000<CR>

Result:

A000 3E 20 LD A,20

A002 06 60 LD B,60

A004 C5 PUSH BC

A005 F5 PUSH AF

A006 DF RST 18

A007 21 00 00 LD HL,0000

A00A 2B DEC HL

A00B 7D LD A,L

A00C B4 OR H

A00D 20 FB JR NZ,FB A00A A00F F1 POP AF

A010 3C INC A

A011 C1 POP BC

A012 10 DJNZ F0 A004



We can see at the addresses A012 and AOOD jump addresses to A00A and A004, respectively.



What does this short program do? Loading register A with 20, the ASCII equivalent to a space. Next, register B is loaded with 60, a counter for the number of characters to print.



The RST 18 instruction take cares that the character is printed using routines from the Basic-interpreter ROM. After the wait loop of address A006 to

-------------------------------------- 9 -------------------------------------



A012, the contents of register A is incremented by 1. As long as the contents of register B is not yet 0, the CPU will jump back and a next character will be printed.



Now some remarks about entering certain instructions. The RST

instructions should be entered in double digits and correctly with regards to the series 00, 08, 10, 18, .... etc.

However, this has only consequences for RST (0)8!

Incorrect input is interpreted as RST 00.



In instructions which make use of the index registers, a relative offset must always be given. Also in the case of 0; so not LD (IY),n but LD (IY+0),n.



On the other hand, for indirect jumps that use the index registers, the offset should not be given. So, for example, JP(IX) and JP(IY).





7. GO, QUIT and Video modes




The just entered program can be run in different ways now.

We start in the simplest way. We set the PC on the start address A000 and the Stack Pointer on B000 and then go to the execution mode:

RPC=A000<CR>

RSP=B000<CR>

X<CR>



We can run the software by entering:



G -A014 (Go until A014)

The program is now executed from the address indicated by the PC.

However, the drawback is that the output starts immediately after the last cursor position. As you can see, the program will stop nicely at address A014. We are dealing here with a primitive "break point". Later, we will get acquainted with advanced methods to break a program on any address - depending on certain conditions.

It is annoying that executing the program causes the output to overwrite the current text. We can improve this

by choosing video mode 1 instead of the video mode 2 in which MSXtra starts up.

We choose the video mode from command mode:

C

V1<CR> ( Video-mode 1 )

Then set the program counter and stack pointer to the correct values and let the program run:



RPC=A000<CR>

RSP=B000<CR>

X<CR>



G -A014<CR>

There is also video mode 0 which starts with a completely empty screen.

We demonstrate this as follows:



-------------------------------------- 10 -------------------------------------



C



V0<CR>



RPC=A000<CR>

RSP=B000<CR>

X<CR>



G -A014<CR>

The "primitive" breakpoint G -A014 does not entirely do this video mode justice. Real breakpoints will improve this.

It is also possible to make run this short program under control of MSX

Basic, as USR function. This requires our routine to end with a RET instruction, so:



C



AA014<CR>

RET<CR>



.<CR>



We will now temporarily leave MSXtra with:

Q<CR> ( Quit )

Here we find ourselves in familiar territory! We start the program:

DEFUSR=&HA000:A=USR(0)

We return after this trip to BASIC to MSXtra with:

_MSXtra



Although this is also possible from Basic, there is the possibility to directly writing this bit of machine language to tape from command mode:

WA000-A014,<name> ( Write A000-A014,'name' )

Where <name> can be filled in by you. There is also the possibility to load a machine code program to investigate it with MSXtra, e.g.



G,<name><CR>

During loading, starting at the bottom line, the names of the programs that are read from the tape are displayed which do not correspond with the desired name or are Basic programs. When the desired program is found, 'loading -' will be displayed. When the program is loaded successfully, the start address will be displayed.



Moreover MSXtra offers the possibility to load a machine language program with an offset with respect to the start address that was read from the tape, e.g.



G1000,<naam><CR>

The offset is subtracted from the start address. We have remember that the start address does not have to be the execution address.



-------------------------------------- 11 -------------------------------------





8. Breakpoints, Execute




MSXtra gives the possibility to set a maximum of eight breakpoints. This is pointing out addresses in the program where you want a "run" to be paused, for example to study intermediate results, or to timely prevent a possibly expected crash in the program.



We will verify this by means of the previous program which ended at address A014. We set the "break point" with:

B0:A014<CR>

MSXtra will now show an address, and in the same way as we have seen in the assembler, we can now enter a litte program, or rather a condition at which our program will break. We choose the "unconditional" option:

.U<CR>



And we see that this creates the instructions XOR A and RET. As we also did in the assembler we return to command mode using:

.<CR>



We have now set the first "break point", but we have not yet activated it. We can do this with:



B0+<CR>



We can always check which break points are activated. We do this with:



B<CR>



And on the bottom half of the screen we see:

0 A014 + 0000

1 0000 - 0000

2 0000 - 0000

3 0000 - 0000

4 0000 - 0000

5 0000 - 0000

6 0000 - 0000

7 0000 - 0000



The meaning of the four columns is as follows: the first column indicates the number of the break point, while the second column indicates the address where it is set. The third column indicates whether the break point is activated, the last column represents a counter which keeps track of the amount of evaluations of the breakpoint condition.



We can also check for which condition a breakpoint is set. We do this for the first break point using:

B0<CR>



And then we see all the information relating to the breakpoint:

-------------------------------------- 12 -------------------------------------



0 A014 + 0000



7998 AF XOR A

7999 C9 RET

799A 00 NOP

799B 00 NOP

etc.



Let's run our program again in video mode 0:

V0<CR>

RPC=A000<CR> RSP=B000<CR> X<CR> ( eXecute until Breakpoint. )

And we see the output start nicely at the top of the screen. To check that the program properly stopped at address A014 we return to command mode:

C



Before we continue with breakpoints we first get acquinted with video mode 3, the last in the series. This video mode only displays the status of the registers and is particularly useful if the output of a program is logged to a printer.



We turn on the printer and enter the following commands:

C

V3<CR>

V+<CR>

RPC=A000<CR> RSP=B000<CR> X<CR>



We choose to execute step-by-step in which the RST 18 is stepped through with the S-key (see 9). Video mode 3 outputs a single header in which the registers are shown. Then at every step the address, the instruction and the contents of the registers. On the printer one line is produced here for each step.

The limited amount of characters on e.g. a MSX-1 does not allow this.



We're going to set a second breakpoint in our program in which the status is shown without breaking:



B1:A010<CR> .S<CR>

.N<CR>

.<CR>



And activate it with:



B1+



We choose video mode 3, set the registers to the proper values and start:

-------------------------------------- 13 -------------------------------------



V3<CR>

RPC=A000<CR> RSP=B000<CR> X<CR>

E



We are now seeing the status of the registers at address A010, in which, in accordance with our short program, only the registers A, B, and F change.



Let's take a look at a conditional breakpoint. In contrast to what we have seen before, for this the break point is evaluated by means of a short program:

B2:A004<CR> LD A,B<CR> CP 20<CR> RET<CR>

.<CR>



We activate this break point but we don't want to get disturbed by breakpoint 1:

B1-<CR>

B2+<CR>

RPC=A000<CR> RPS=B000<CR> V1<CR>

X<CR>

E



We now see the program end as we already saw before, however, when it reaches the character '_', the program is stopped at address A004

with the value of 20 in register B. In a closer view of the instructions that evaluate the breakpoint we see that a "break" occurs when the Z-flag is set.

This evaluation can last quite long and we will demonstrate it with the following example. We also disable breakpoint 2 and set break point three:

B2-<CR>

B3:A00D<CR> LD A,H<CR> CP 12<CR> RET NZ<CR> LD A,L<CR> CP 34<CR> RET<CR>

.<CR>



Then we initialize the PC and SP, select video mode 2, activate the breakpoint and start:



RPC=A000<CR> RSP=B000<CR> B3+<CR>

X<CR>

E



We can now spend a few minutes to drink a cup of coffee! When the program finally stops on the breakpoint, we see that

-------------------------------------- 14 -------------------------------------



register HL indeed contain the value 1234. We also take a look at the break point counters using:



B<CR>



and see that the counter of break point 3 contains the value EDCC, the complement of 1234. The counter of B2 contains 41; it indeed stopped at the printing of the 41-th character.



HIER GEBLEVEN





9. Subroutine




To run in a time of a subroutine (CALL) and routines initiated by the RST instruction is execute under a special command mode "S" (subroutine). This command works out a subroutine in its entirety. we will go this view by the wait loop in the program include in a subroutine. We use the existing in-command mode "copy"

assignment. This command gives the possibility of memory blocks, or else move said program parts. Bring MSXtra above in the command fashion and test the following:



CA007-A00E,A020<CR>

Which part of the program to address A00C A00E is copied to the piece memory starting at address A020. We have copied this piece yet to make a subroutine. We conclude, therefore, with a RET, so ::

AA028<CR> RET<CR>

.<CR>



We complete the original program which again each line ends with a <CR>:



AA007

CALL 0A020

POP AF

INC A

POP BC

DJNZ 0F5



Again, we additionally initiate the PC and SP and put all security a breakpoint on A00F:



RPC=A000<CR> RSP=B000<CR> B0:A00F<CR> .U<CR>

,<CR>

B0+<CR>

X<CR>

E



We put the PC on A000 and then can with the space bar, the program by steps. Where the PC designates a CALL or RST we consistently Use of the key S.



-------------------------------------- 15 -------------------------------------





10. Practice




We find in a textbook on the Z80 the following simple pro-gramma, that the contents of registers C and E, and multiplies the result in the register pair HL move.



LD B,8

LD C,9

LD D,0

LD E,5

LD HL,0

MUL SRL C

JR NC,EVEN

ADD HL,DE

EVEN SLA E

RL D

DEC B

JR NZ,MUL

HALT



We conduct this program as follows; each line ends with a <CR>.



A9000

LD B,8

LD C,9

LD D,0

LD E,5

LD HL,0

SRL C

JR NC,7F

ADD HL,DE

SLA E

RL D

DEC B

JR NZ,0FF

<CR>



We have the relative jumps at the labels EVEN and MUL provisionally the value 7F (forward) and 0FF (reverse) completed. We take another look at the "list":

L9000<CR>

with result:



9000 06 08 LD B,8

9002 0E 09 LD C,9

9004 16 00 LD D,0

9006 1E 05 LD E,5

9008 21 00 00 LD HL,0

900B CB 39 SRL C

900D 30 7F JR NC,7F 908E

900F 19 ADD HL,DE

9010 CB 23 SLA E

9012 CB 12 RL D

9014 05 DEC B

9015 20 FF JR NZ,FF 9016



-------------------------------------- 16 -------------------------------------



However, the relative jumps to addresses 900D and 9015 still refer to indicated (erroneous) addresses. If the instruction at address 900D (JR

NC, EVEN) is executed, the PC will temporarily to the next, yet off tevoeren, point instruction. In this case to 900F. The relative jump However, it should be to address 9010. We can now calculate this leap with command H. Enter the following:



<CX>

H900F,9010<CR>

MSXtra which responds with:



Sum: 201F Diff: FFFF 0001



The jump is 01; we fill this jump so correctly with:

A900D<CR> JR NC,1<CR>

In the same way we calculate the relative jump to address 9015 (JR

NZ, MUL) with:



H9017,900B<CR>

With result:



Sum: 2022 Diff: 000C, FFF4



So here one - in two complements show - relative jump in size of F4, so that now:



A9015<CR> JR NZ,0F4<CR> .<CR>



We now check with:



L9000<CR>

Now with the correct result:



9000 06 08 LD B,8

9002 0E 09 LD C,9

9004 16 00 LD D,0

9006 1E 05 LD E,5

9008 21 00 00 LD HL,0

900B CB 39 SRL C

900D 30 01 JR NC,01 9010

900F 19 ADD HL,DE

9010 CB 23 SLA E

9012 CB 12 RL D

9014 05 DEC B

9015 20 F4 JR NZ,F4 900B



We can run this program in the 7 various listed ways.



-------------------------------------- 17 -------------------------------------





11. A graphical exercise




By means of the assembler, we perform the following program in which each line - of course without comment - ends with a return.



A9000

LD A,2

CALL 5F ; select screen 2

LD A,(0F3E9) ; forground LD (0F3F2),A ; to ATRBYT

XOR A

LD B,A

LD C,A

LD D,A

LD E,A

PUSH AF

PUSH BC

PUSH DE

CALL 111 ; maps coord. to physical address CALL 120 ; set pixel to forground color POP DE

POP BC

POP AF

INC BC

INC DE

DEC A

JR NZ,0EF XOR A CALL 5F ; back to screen 0

.



We set a breakpoint after the last instruction and activate it:





B0:9025


.U

.

B0+



Then we put the PC and SP and starting:

RPC=9000

RSP=B000

X

E



We see the short time plot of a diagonal line, after which a return to MSXtra. If we want to look at the plot better we should try it just to keep on schedule. We do this with a special breakpoint that we 'B7 will call and we go places just to return to screen





0.




We turn first to return to command mode:

C





B7:9021


CALL 0B7


LD A,0



-------------------------------------- 18 -------------------------------------



ADC A,0FF

JR NZ,0F7

.N

.



We repair various registries, also trigger this breakpoint and B7

Restart:



RPC=9000

RSP=B000

B7+

X

E



The program is now waiting for the address where the B7 breakpoint put and will only continue if the CTRL and STOP simultaneously printed. This B7 breakpoint is definitely a very in many other situations handy tool! The name B7 has of course nothing to do with the CALL 0B7 but it is a nice mnemonic.



Finally, a simple input-routine in which once again the use of the conditional breakpoint is demonstrated.



AA00

CALL 9F

CALL 0A2

JR 0F8

.

RPC=A000

RSP=C000





B0:A003


CP 1B


RET

.

B0+

V0

X

E



We can now begin our walk with input from the keyboard and escape from this small program with <ESC>





12. Private utillities




MSXtra has to be a local variable RAM. This RAM is still a large piece suitable for the accommodation of their own utilities. This free piece runs from 7C00 to 7FFF. In order to make it usable for this piece is the RAM

question mark even if additional commands are available. Upon startup for this command a 'hook' placed on 7FFD address. Do we want to use This expansion than 7FFD address to be overwritten with a jump to e.g. address 7C00 where we put our utility.



In the previous sections we have regularly registers as the PC and SP should recover. It would be useful if we followed this with a single command can perform. The contents of these registers SP and PC are MSXtra-RAM and stored it on addresses 7AB1 and 7AB3. Our utility must

-------------------------------------- 19 -------------------------------------



therefore ensure that these addresses are the values we want inserted. We Proceed as follows:



A7FFD

JP 7C00 ; overwrite the hook .

A7C00

LD BC,4

LD DE,7AB1

LD HL,7E00

LDIR

RET

.



This piece of program copies four bytes from address 7E00 to the memory block starting at address 7AB1. So we have now the desired values 7E00 places:



S7E00

00 B0 00 A0.



We turn now to check the whole PC and SP to zero, and determine what happens to enter the question mark:



RPC=0

RSP=0

?



It is also quite possible to have more than one utility under the question mark to places. We demonstrate this on the basis of the following example, Assuming that the hook has been overwritten. For better readability of this example is to introduce next to the keyboard by means of the left column placed right still an explanatory version.



A7C00

LD A,(DE) LD A,(DE) CP 53 CP 'S'

JR Z,09 JR Z,SAVE

CP 52 CP 'R'

JR Z,11 JR Z,RESTORE

CP 43 CP 'C'

JR Z,19 JR Z,CLEAR

RET RET

LD BC,18 SAVE: LD BC,18H

LD DE,7C32 LD DE,SAVREG

LD HL,7AB7 LD HL,RSA LDIR LDIR

RET RET

LD BC,18 RESTORE: LD BC,18H

LD DE,7AB7 LD DE,RSA LD HL,7C32 LD HL,SAVREG

LDIR LDIR

RET RET

LD BC,18 CLEAR: LD BC,18H

LD DE,7AB7 LD DE,SRA LD HL,7C56 LD HL,ZEROBLOCK

LDIR LDIR

RET RET

.



-------------------------------------- 20 -------------------------------------



And we still set 24 bytes to zero



K7C56-7C7A,00



We now have about 3 commands:? S 'saves all the registers in the memory space from 7C32; ? R 'resets all registers again with those values which are secured with? 'S'. Finally, with "? C" all registers zero are put. This simple routine can still be reasonably quickly the keyboard insertion, however, it is considerably extended it can be better written to tape with:



W7C00-8000,UTIL



When laying the finishing touches on MSXtra utility could top standing still be lost in the remaining bytes of the ROM. We can now e.e.a.

reach:



PS ( Processor Save ) PR ( Processor Restore ) PC ( Processor Clear )

Sometimes BASIC program included in the appendix is an example of a autorun program to install a utility (AUTOEXEC.BAS).

In this example, use is made of the above-register manipulations but this can of course be reworked for e.g. disk-routines.





13. MSXtra and BASIC




We reset our MSX and will introduce the following Basic program:

10 RESTORE

20 DEFUSR=&HA000

30 READ N

40 FOR I=0 TO N

50 READ D$: D=VAL("&H"+D$) 60 POKE &HA000+I,D

80 CLS: INPUT"Geef getal";X%

90 R=USR(X%)

100 PRINT "+1 wordt: ";R

110 END 120 DATA 14,3A,63,F6,FE,02,20,07

130 DATA 2A,F8,F7,23,22,F8,F7,C9



We soon see that a user function is in the Basic. Let the program walk we find it to enter numbers increased by one. what exactly in the user mode is done, however, is not so simple back fetch.

MSXtra but also offers a solution here! We add an extra line correctly Before the machine language routine is invoked:

85 CALL MSXTRA (or shorter: 85 _MSXTRA)

If we let the program run than we naturally come in MSXtra justified and can then begin to see what exactly is in it by DEFUSR specified address A000 with:



-------------------------------------- 21 -------------------------------------



LA000



Resulting in:



A000 3A 63 F6 LD A,(F663) A003 FE 02 CP 02

A005 20 07 JR NZ,07

A007 2A F8 F7 LD HL,(F7F8) A00A 23 INC HL

A00B 22 F8 F7 LD (F7F8),HL

A00E C9 RET



Addresses above F000 are system variables of the MSX-Basic, and in a handbook we can look up what addresses F663 and F7F8 precise proposals len. For F7F8 we find that that address is located in the area where the parameter is placed on an USR-function, while the F663 this type of parameter can be found.

If we look in the handbook the basic instruction USR more closely than it appears to involve an parameter of type integer.



Turns out this USR mode then still simple, can MSXtra us in difficult cases help USR break point.

We can demonstrate this USR-break point on the basis of the currently proposed Basic program includes hands being added rule 85. We leave it program run and once again we are in MSXtra we give it comando:



UA000<CR> ( User-breakpoint op A000 )

We then return to Basic with:



Q<CR>



The next Basic rule - the USR function - is now under review and We are sliding back into MSXtra and put it with the PC address A000.

We can now proceed to execution mode and the machine language by steps the previously available commands. We must not, however, the standard use and also we must break points in time ie before the last machine language instruction RET. Returning to Basic must for this RET

with:



UQ<CR> ( User-Quit )

If we omit in Rule 80 and the 90% mark is the effect of it subroutine obviously something wrong. We would using the USR-breakpoint once ascertain exactly what. And finally: there is only one USR-break point, but for uitplussen Basic recorded machinetaal-routines, this is sufficient.





14. MSXtra and other cartridges




MSXtra gives the tools to the software of other cartridges See. Before we discuss here we will first look at how a global MSX-1 handles cartridges. If the machine is booted be first RAM many pages as possible - if necessary from different slots - together sought, and such a way that results in a contiguous block. Then

-------------------------------------- 22 -------------------------------------



MSX-Basic examines all slots - starting with slot0 - whether in the address area 4000 to BFFF a cartridge is present. For this purpose, in a cartridge reserved the first 8 x 2 bytes. The first pair constitutes the actual identification and therefore contains the code "AB" (in ASCII). The second pair of can contain the address of an initialization procedure, but often is here '00

00 'as for most game-cartridges. The third pair forms a start address where the Basic CALL appeals. The last two addresses also the conclusion about which address field the cartridge is intended.



The fourth pair contains the address of the so-called "device handler"; this as the cartridge is not intended only for software. If the fifth pair no zeros are then placed in the cartridge, a basic program. The presence from that address means that such a cartridge when switching on the machine start immediately. The remaining bytes are provided as a reserve. Those who concerning want to know a little more of the foregoing, found at the end of This manual contains a literature list.



To a self-booting cartridge with a Basic program intrusion, we proceed as follows. We place MSXtra and through us examine every cartridge in a slot. Next, we switch the machine and press and hold simultaneously the CTRL and STOP values by we take the auto-start of MSXtra. We perform the following:

AD000<CR> LD A,1 ; selecteer slotnummer 1

LD H,80 ; selecteer pagina 2

CALL 24



We set e.e.a. ready and executed with steps:

RPC=D000<CR> RSP=F000<CR> X<CR>

<spatie>

<spatie>

S

C



LD A, first we try to select the slot in which the test cartridge is. So we must consider whether we have selected the right slot ted and do that:



D000<CR>



We find nonsense, for example, only FF or 1A, then the choice of the lock was not right and we do it all again with about LD A, 2 instead of LD

A, 1. The latter is easy to carry out by:

SD001<CR> 02.<CR>



Only when we get to a dump from address 8000 first find the bytes 41 and 42

we have succeeded and can use all the available tools have further explore the pen cartridge.



Cartridges which are intended to address range from 4000 to ask what more effort. This must after selecting the proper slot, the contents thereof to be moved also. This can then be as follows:

-------------------------------------- 23 -------------------------------------



LD A,2

LD H,40

CALL 24

LD HL,4000

LD DE,8000

LD BC,4000

LDIR

LD A,1

LD H,40

CALL 24



When going back to MSXtra has been assumed that it is placed in slot 1.

If eea not work as expected must also another here slot number are chosen.





15. Command Summary




Format:



addr: hexadecimal address eg. AB25, E46, 12345 (=2345)

data: hexadecimal or alphanumeric data eg. 12 ED 34 0 12

'string'

1 2 3 'ABC' 4 5 6

'"s morgens'



n: hexadecimal values bv. 55, 0,AE4E, EEDC2 (=edc2)

[..] the part between the brackets is optional

|: separation between different possibilities

Edit capabilities of the command-line or execution

INS toggles: Insert -on and -off DEL remove character under the cursor <- cursor left -> cursor right BS backspace

CLR/HOME erase entire line

-------------------------------------- 24 -------------------------------------



Command mode:



A Assemble: Starting the import of a program.



Format: Aaddr



Description: Imports may consist of instructions by the ZILOG

specified format. Hexadecimal values beginning with a letter must begin with a zero.

With a point, '.', the input can be terminated.



Example: A9000

LD HL,0

DEC HL

LD A,H

OR L

JR NZ,0FB



B Breakpoints: Set, and display on or off of the conditional breakpoints.



Format: B[|+|-|n]

Bn[+|-]

Bn:addr



Description: There are a total of eight conditional breakpoints available.

The condition (condition) is formed by a small bit program that evaluates a condition or a Z

NZ state; Z state leads to termination of the running program. The condition is closed with a RET instruction.



B View the status of all eight break points: number, address, at (+) Or (-) and the number of times the breakpoint is reached.



B+ Turn all breakpoints on; B- Turn all breakpoints off;

Bn+ Turn breakpoint n on; Bn- Turn breakpoint n off (n=0-7).



Bn View the status and condition of break point n.



-------------------------------------- 25 -------------------------------------



Bn:addr Set breakpoint n at address addr and set the condition. The condition is entered in the same way as a program (see the A command). There are 32 memory places reserved for the condition; this corresponds to about 14 lines of program text. The program with the specific condition (Z or NZ) may change all register values.

There are 3 additional 'instructions' present:

.U returns a Z condition (unconditional break); .N returns a NZ condition (no break); .S shows the status of the program (the registers and the flags).



Example: (of conditions) stop always:

.U



show the status without stopping: .S

.N



stop as B=20;

LD A,B

CP 20

RET



stop as HL=1234

LD A,H

CP 12

RET NZ

LD A,L

CP 34

RET



stop as (562A)>80

LD A,(562A)

CP 81

JR NC,3 ;jump to .U

.N

.U



C Copy: Copying and moving a piece of memory.



Format: Caddr1-addr2,addr3



Description: The piece of memory addr1 to addr2

to move addr3; with is potential overlap taken into account.



Example: C1000-2000,1001



D Dump: Showing a lot of memory.

Format: Daddr[-addr1]

Description: The piece of memory from addr to addr1 (or addr + 64

addr1 if not specified) is shown. With a

-------------------------------------- 26 -------------------------------------



plus, "+", the next block can be of the same size to be viewed, with a minus, "-" the previous block.

The command is terminated with <CR>.



Example: D100



F Find: Searching for a string.



Format: Fdata



Description: The search for the specified string occurs from address 0. With a plus, "+", can go to the next occurrence be sought from the string. Aborting is possible with <CR>.



Examples: F'MSXtra'



F4D 53 58 74 72 61



G Get: Reading machine language cassette.



Format: G[addr],<naam>

Description: Reading data stored on cassette tape according to the for the MSX specified "Machine language file format "addr With an offset can be set. Not with <name> matching files are reported. after loading the starting address is reported.



H Hexadecimaal: Calculate hexadecimal.



Format: Hn1[,n2]



Description: The sum n1 + n2, and the differences n1-n2-n1 and n2

is shown. If n2 is not specified n2 = 0 will presupposed.



Example: H23EF,8E79



K Kill: Filling the memory with a repeat of a string.



Format: Kaddr1-addr2,data

Description: The memory of addr1 to addr2 filled with as many repetitions of the string as needed.



Example: KA100-A200,'Hallo' 3E 2E 23



L List: Disassembling a program.



Format: Laddr[-addr2]



Description: Disassembly from addr1 to addr2, of 14 rules addr2 is not specified. With "+" next to block can be disassembled; abort with <CR>.



-------------------------------------- 27 -------------------------------------



Example: L100



M Move: Moving up the stack of MSXtra.



Format: Maddr



Description: The stack of MSXtra normally begins 64 bytes under the BASIC stack. In some cases it may be be desirable to move the stack to a different memory section. This happens with this command where the new stack starts at the specified address addr.

Note from 7904 address in the RAM space MSXtra created for the stack. However, this location is only useful if no use of a disk is made!



Example: M7904



P Processor: Simultaneous treatment of processor registers.



Format: Px

met x : S, R, C



Description: S: Keep all registers temporary; R: retore all registers preserved with S

C: set all registers to zero.

The information is retained after resetting the machine.



Q Quit: Leaving MSXtra.



Format: Q



R Registers: Changing registers.



Format: Rreg=n

met reg : A , B , C , D , E , H , L , A', B', C', D', E', H', L', BC, DE, HL, BC', DE', HL', IX, IY, SP, PC .

R[F|F']=flag

met flag: M, Z, H, P, N, C



Description: all registers, other than the interrupt register IV and the refresh register R, can be changed. the flags can be changed individually, this works as a on- and off- toggle switch.



Examples: RD=34

RBC'=4321

RF=Z

RF=Z



S Set: Changing and inspecting the memory.



Format: Saddr



-------------------------------------- 28 -------------------------------------



Description: The memory can be filled with hexadecimal values or Strings. The entry ends with a point, '.'. If a blank line is provided (with a <CR> that location is not changed.



Example: SA139

1 2 3 'ABC'.24 4.



U User: Putting a breakpoint in a BASIC USR () function.



Format: Uaddr

UQ



Description: Put a (usr) breakpoint at the address addr. upon execution the BASIC program containing the USR() function, will upon reaching the address addr automatically jump to MSXtra. The PC and SP are to be initialized before; all other registers have value of zero. There is only one USR() breakpoint! After the USR() function is executed because of the need MSXtra special start terminate with UQ (User Quit) instead Q. The BASIC program then resumes.



V Video: Changing the layout in execution mode; On and Off of the printer.



Format: V+|-

Vn



Description: There are various forms of output in execution mode available.

mode 0: no output; mode 1: only register block; mode 2: pointer registers with memory content; mode 3: scrolling format.

With V+ all output goes to the printer, for both command and execution mode. With V-, the output to the printer turned off. Assumed standard is V- and V2



Example: V+

V3



W Write: Writing machine language to tape.



Format: Waddr1-addr2,<naam>

Description: The memory part of addr1 to be addr2

according to the MSX specified "Machine language file format" written to cassette tape.



X eXit: Leave the command mode, starting the execution mode.



Format: X



-------------------------------------- 29 -------------------------------------



Execution mode:



C Command: To return to the command mode.



Format: C



E Execute: Starting a program.



Format: E



Description: The implementation of the program starts from the current program counter. The execution stops only after reaching introduced a conditional breakpoint (if the condition is met).



G Go: Starting a program from, respectively to Reaching a certain address.



Format: G [-]addr

Description: Gaddr has the same effect as E (see above), but the implementation will start from addr instead of the current program level. G-addr is the same as E, but there is now an additional (implicit) breakpoint put on addr.



Examples: G

G -3454



S Single step: Performing an instruction.



Format: S

(spacebar!)



Description: The instruction to which the program counter is pointing performed. If the instruction is a CALL or RST instruction, then S is entirely executes the subroutine with (space), only the CALL or RST

instructions are executed.



T Trace: Step by step execution of a sequence of instructions.



Format: T [S]n

T [S]-addr



Description: With Tn are n (n hexadecimal) instructions from the program counter executed. After each statement is the status displayed. With T -addr are the instructions carried out until the program counter is addr. If the S option is specified, all subroutines are completely executed.



Example: T 10

T S-96AF



-------------------------------------- 30 -------------------------------------



Note: With the exception of the assembler, are all to enter data in hexadecimal (byte) or alphanumeric surrounded by single quotes. is also not permitted by the assembler alphanumeric input.



The interrupt vector register only under the use of the commands E or G <addr> be changed temporarily. I.e. that, for the achievement of any "break point" to the original value of this register must be restored.

This register can also be changed in a subroutine, provided it is run through with the command value S and the original for the achievement of the associated RET is restored.



Literature:



MSX Technical Data Book. - Hardware/Software Specifications -

Issuer: SONY



The complete MSX Programmers Guide.

Authors: Toshuyuki Sato / Paul Mapstone / Isabella Muriel Issuer: Melbourne House.



MSX Rom-BIOS hand book.

Issuer: Terminal Software Publications.



-------------------------------------- 31 -------------------------------------





17. Diagram of the MSXtra cartridge




The cartridge contains five parts: 1) 2764 = 8K x 8 EPROM (of 27C64) 2) 81C28 = 2K x 8 SRAM

3) 74LS138 = 3 to 8 address selector 4) + 5) = ceramic capacitors of 47nF



2764 81C28

MSX-SLOT 8K x 8 EPROM 2K x 8 SRAM

| | |

D0-----------------D0--------------D0

D1-----------------D1--------------D1

D2-----------------D2--------------D2

D3-----------------D3--------------D3

D4-----------------D4--------------D4

D5-----------------D5--------------D5

D6-----------------D6--------------D6

D7-----------------D7--------------D7

| | |

A0-----------------A0--------------A0

A1-----------------A1--------------A1

A2-----------------A2--------------A2

A3-----------------A3--------------A3

A4-----------------A4--------------A4

A5-----------------A5--------------A5

A6-----------------A6--------------A6

A7-----------------A7--------------A7

A8-----------------A8--------------A8

A9-----------------A9--------------A9

A10----------------A10-------------A10

A11----------------A11- - - - - - (A11) *)see note A12----------------A12- - - - - - (A12) *)see note | | |

| 74LS138 | |

| +-------+ | |

A14---|A Y0| | |

A13---|B Y1| | |

| |C Y2| | |

SLTSL---|G2A Y3| | |

A15---|G2B Y4| | |

+5V---|G1 Y5|-----CE |

| | Y6| | |

+5V---|VCC Y7|-----------------ALE/CS

GND---|GND | | |

| +-------+ | |

| | |

RD-----------------OE--------------OE

WR---------------------------------WE

| | |

| +---Vpp |

| +---PGM |

+5V------------+---VCC-------------VCC

-GND----------------GND-------------GND



In close proximity to the EPROM and the SRAM a ceramic capacitor of 47nF between + 5V and GND.



Memorymap of the MSXtra cartridge.



4000 - 5FFF EPROM

6000 - 67FF SRAM

6800 - 6FFF shadow of SRAM

7000 - 77FF shadow of SRAM

7800 - 7FFF shadow of SRAM



Through the built-in SRAM, this cartridge is completely transparent to the system, ie no memory of the MSX computer is used for the operation of the program.



Note) i.p.v. 2K-SRAM can also use 8K-SRAM.

of course, must then A11 and A12 are connected.

The three shadows in the memorymap then lapse, and memorymap changed:

4000 - 5FFF EPROM

6000 - 7FFF SRAM

</body>
</html>
